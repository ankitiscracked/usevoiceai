var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_modules_watch_stub();
  }
});

// ../../node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "../../node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// ../../node_modules/events/events.js
var require_events = __commonJS({
  "../../node_modules/events/events.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : /* @__PURE__ */ __name(function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    }, "ReflectApply");
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = /* @__PURE__ */ __name(function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      }, "ReflectOwnKeys");
    } else {
      ReflectOwnKeys = /* @__PURE__ */ __name(function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      }, "ReflectOwnKeys");
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    __name(ProcessEmitWarning, "ProcessEmitWarning");
    var NumberIsNaN = Number.isNaN || /* @__PURE__ */ __name(function NumberIsNaN2(value) {
      return value !== value;
    }, "NumberIsNaN");
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    __name(EventEmitter2, "EventEmitter");
    module.exports = EventEmitter2;
    module.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    __name(checkListener, "checkListener");
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return defaultMaxListeners;
      }, "get"),
      set: /* @__PURE__ */ __name(function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }, "set")
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = /* @__PURE__ */ __name(function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    }, "setMaxListeners");
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    __name(_getMaxListeners, "_getMaxListeners");
    EventEmitter2.prototype.getMaxListeners = /* @__PURE__ */ __name(function getMaxListeners() {
      return _getMaxListeners(this);
    }, "getMaxListeners");
    EventEmitter2.prototype.emit = /* @__PURE__ */ __name(function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    }, "emit");
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    __name(_addListener, "_addListener");
    EventEmitter2.prototype.addListener = /* @__PURE__ */ __name(function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    }, "addListener");
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = /* @__PURE__ */ __name(function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    }, "prependListener");
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    __name(onceWrapper, "onceWrapper");
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    __name(_onceWrap, "_onceWrap");
    EventEmitter2.prototype.once = /* @__PURE__ */ __name(function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    }, "once");
    EventEmitter2.prototype.prependOnceListener = /* @__PURE__ */ __name(function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    }, "prependOnceListener");
    EventEmitter2.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    }, "removeListener");
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    }, "removeAllListeners");
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    __name(_listeners, "_listeners");
    EventEmitter2.prototype.listeners = /* @__PURE__ */ __name(function listeners(type) {
      return _listeners(this, type, true);
    }, "listeners");
    EventEmitter2.prototype.rawListeners = /* @__PURE__ */ __name(function rawListeners(type) {
      return _listeners(this, type, false);
    }, "rawListeners");
    EventEmitter2.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    __name(listenerCount, "listenerCount");
    EventEmitter2.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    }, "eventNames");
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    __name(arrayClone, "arrayClone");
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    __name(spliceOne, "spliceOne");
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    __name(unwrapListeners, "unwrapListeners");
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        __name(errorListener, "errorListener");
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        __name(resolver, "resolver");
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    __name(once, "once");
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    __name(addErrorHandlerIfEventEmitter, "addErrorHandlerIfEventEmitter");
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, /* @__PURE__ */ __name(function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        }, "wrapListener"));
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
    __name(eventTargetAgnosticAddListener, "eventTargetAgnosticAddListener");
  }
});

// ../../node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "../../node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    init_modules_watch_stub();
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      __name(F, "F");
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var g = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g,
          iterable: "Symbol" in g && "iterator" in Symbol,
          blob: "FileReader" in g && "Blob" in g && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in g,
          arrayBuffer: "ArrayBuffer" in g
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        __name(isDataView, "isDataView");
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        __name(normalizeName, "normalizeName");
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        __name(normalizeValue, "normalizeValue");
        function iteratorFor(items) {
          var iterator = {
            next: /* @__PURE__ */ __name(function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }, "next")
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        __name(iteratorFor, "iteratorFor");
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        __name(Headers2, "Headers");
        Headers2.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers2.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers2.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers2.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers2.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        __name(consumed, "consumed");
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        __name(fileReaderReady, "fileReaderReady");
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        __name(readBlobAsArrayBuffer, "readBlobAsArrayBuffer");
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        __name(readBlobAsText, "readBlobAsText");
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        __name(readArrayBufferAsText, "readArrayBufferAsText");
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        __name(bufferClone, "bufferClone");
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        __name(Body, "Body");
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        __name(normalizeMethod, "normalizeMethod");
        function Request2(input, options) {
          if (!(this instanceof Request2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || function() {
            if ("AbortController" in g) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          }();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        __name(Request2, "Request");
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        __name(decode, "decode");
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        __name(parseHeaders, "parseHeaders");
        Body.call(Request2.prototype);
        function Response2(bodyInit, options) {
          if (!(this instanceof Response2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        __name(Response2, "Response");
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request2(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            __name(abortXhr, "abortXhr");
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response2(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g.location.href ? g.location.href : url;
              } catch (e) {
                return url;
              }
            }
            __name(fixUrl, "fixUrl");
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g.Headers && init.headers instanceof g.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
              request.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        __name(fetch2, "fetch");
        fetch2.polyfill = true;
        if (!g.fetch) {
          g.fetch = fetch2;
          g.Headers = Headers2;
          g.Request = Request2;
          g.Response = Response2;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request2;
        exports2.Response = Response2;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// ../../node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var isMergeableObject = /* @__PURE__ */ __name(function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    }, "isMergeableObject");
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    __name(isNonNullObject, "isNonNullObject");
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    __name(isSpecial, "isSpecial");
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    __name(isReactElement, "isReactElement");
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    __name(emptyTarget, "emptyTarget");
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    __name(cloneUnlessOtherwiseSpecified, "cloneUnlessOtherwiseSpecified");
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    __name(defaultArrayMerge, "defaultArrayMerge");
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    __name(getMergeFunction, "getMergeFunction");
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    __name(getEnumerableOwnPropertySymbols, "getEnumerableOwnPropertySymbols");
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    __name(getKeys, "getKeys");
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    __name(propertyIsOnObject, "propertyIsOnObject");
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    __name(propertyIsUnsafe, "propertyIsUnsafe");
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    __name(mergeObject, "mergeObject");
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    __name(deepmerge, "deepmerge");
    deepmerge.all = /* @__PURE__ */ __name(function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    }, "deepmergeAll");
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// ../../node_modules/ws/browser.js
var require_browser = __commonJS({
  "../../node_modules/ws/browser.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/apiStatus/types/ApiInfo.js
var require_ApiInfo = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/apiStatus/types/ApiInfo.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/apiStatus/types/index.js
var require_types = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/apiStatus/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ApiInfo(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/apiStatus/client/index.js
var require_client = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/apiStatus/client/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/apiStatus/index.js
var require_apiStatus = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/apiStatus/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types(), exports);
    __exportStar(require_client(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/auth/types/TokenGrant.js
var require_TokenGrant = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/auth/types/TokenGrant.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/auth/types/TokenRequest.js
var require_TokenRequest = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/auth/types/TokenRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/auth/types/TokenResponse.js
var require_TokenResponse = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/auth/types/TokenResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/auth/types/index.js
var require_types2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/auth/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_TokenGrant(), exports);
    __exportStar(require_TokenRequest(), exports);
    __exportStar(require_TokenResponse(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/auth/client/index.js
var require_client2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/auth/client/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/auth/index.js
var require_auth = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/auth/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types2(), exports);
    __exportStar(require_client2(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/embedding/types/Embedding.js
var require_Embedding = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/embedding/types/Embedding.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/embedding/types/index.js
var require_types3 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/embedding/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Embedding(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/embedding/index.js
var require_embedding = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/embedding/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types3(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/TimestampGranularity.js
var require_TimestampGranularity = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/TimestampGranularity.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimestampGranularity = void 0;
    exports.TimestampGranularity = {
      Word: "word"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/TranscriptionWord.js
var require_TranscriptionWord = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/TranscriptionWord.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/TranscriptionResponse.js
var require_TranscriptionResponse = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/TranscriptionResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/StreamingTranscriptionResponse.js
var require_StreamingTranscriptionResponse = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/StreamingTranscriptionResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/TranscriptMessage.js
var require_TranscriptMessage = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/TranscriptMessage.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/FlushDoneMessage.js
var require_FlushDoneMessage = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/FlushDoneMessage.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/DoneMessage.js
var require_DoneMessage = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/DoneMessage.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/ErrorMessage.js
var require_ErrorMessage = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/ErrorMessage.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/SttEncoding.js
var require_SttEncoding = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/SttEncoding.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SttEncoding = void 0;
    exports.SttEncoding = {
      PcmS16Le: "pcm_s16le",
      PcmS32Le: "pcm_s32le",
      PcmF16Le: "pcm_f16le",
      PcmF32Le: "pcm_f32le",
      PcmMulaw: "pcm_mulaw",
      PcmAlaw: "pcm_alaw"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/index.js
var require_types4 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_TimestampGranularity(), exports);
    __exportStar(require_TranscriptionWord(), exports);
    __exportStar(require_TranscriptionResponse(), exports);
    __exportStar(require_StreamingTranscriptionResponse(), exports);
    __exportStar(require_TranscriptMessage(), exports);
    __exportStar(require_FlushDoneMessage(), exports);
    __exportStar(require_DoneMessage(), exports);
    __exportStar(require_ErrorMessage(), exports);
    __exportStar(require_SttEncoding(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/client/requests/index.js
var require_requests = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/client/requests/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/client/index.js
var require_client3 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/client/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_requests(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/index.js
var require_stt = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types4(), exports);
    __exportStar(require_client3(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/ContextId.js
var require_ContextId = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/ContextId.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/FlushId.js
var require_FlushId = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/FlushId.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/ModelSpeed.js
var require_ModelSpeed = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/ModelSpeed.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModelSpeed = void 0;
    exports.ModelSpeed = {
      Slow: "slow",
      Normal: "normal",
      Fast: "fast"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketBaseResponse.js
var require_WebSocketBaseResponse = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketBaseResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketResponse.js
var require_WebSocketResponse = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketErrorResponse.js
var require_WebSocketErrorResponse = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketErrorResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketChunkResponse.js
var require_WebSocketChunkResponse = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketChunkResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketTimestampsResponse.js
var require_WebSocketTimestampsResponse = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketTimestampsResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketPhonemeTimestampsResponse.js
var require_WebSocketPhonemeTimestampsResponse = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketPhonemeTimestampsResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketTtsOutput.js
var require_WebSocketTtsOutput = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketTtsOutput.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketStreamOptions.js
var require_WebSocketStreamOptions = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketStreamOptions.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WordTimestamps.js
var require_WordTimestamps = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WordTimestamps.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/PhonemeTimestamps.js
var require_PhonemeTimestamps = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/PhonemeTimestamps.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketDoneResponse.js
var require_WebSocketDoneResponse = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketDoneResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketFlushDoneResponse.js
var require_WebSocketFlushDoneResponse = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketFlushDoneResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/CancelContextRequest.js
var require_CancelContextRequest = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/CancelContextRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/GenerationRequest.js
var require_GenerationRequest = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/GenerationRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketRawOutputFormat.js
var require_WebSocketRawOutputFormat = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketRawOutputFormat.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketRequest.js
var require_WebSocketRequest = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketTtsRequest.js
var require_WebSocketTtsRequest = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WebSocketTtsRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/TtsRequest.js
var require_TtsRequest = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/TtsRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/TtssseRequest.js
var require_TtssseRequest = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/TtssseRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/SupportedLanguage.js
var require_SupportedLanguage = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/SupportedLanguage.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupportedLanguage = void 0;
    exports.SupportedLanguage = {
      En: "en",
      Fr: "fr",
      De: "de",
      Es: "es",
      Pt: "pt",
      Zh: "zh",
      Ja: "ja",
      Hi: "hi",
      It: "it",
      Ko: "ko",
      Nl: "nl",
      Pl: "pl",
      Ru: "ru",
      Sv: "sv",
      Tr: "tr"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/GenerationConfig.js
var require_GenerationConfig = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/GenerationConfig.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/Emotion.js
var require_Emotion = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/Emotion.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/OutputFormat.js
var require_OutputFormat = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/OutputFormat.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/RawOutputFormat.js
var require_RawOutputFormat = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/RawOutputFormat.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/SseOutputFormat.js
var require_SseOutputFormat = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/SseOutputFormat.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/RawEncoding.js
var require_RawEncoding = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/RawEncoding.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RawEncoding = void 0;
    exports.RawEncoding = {
      PcmF32Le: "pcm_f32le",
      PcmS16Le: "pcm_s16le",
      PcmMulaw: "pcm_mulaw",
      PcmAlaw: "pcm_alaw"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WavOutputFormat.js
var require_WavOutputFormat = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/WavOutputFormat.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/Mp3OutputFormat.js
var require_Mp3OutputFormat = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/Mp3OutputFormat.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/TtsRequestVoiceSpecifier.js
var require_TtsRequestVoiceSpecifier = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/TtsRequestVoiceSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/TtsRequestIdSpecifier.js
var require_TtsRequestIdSpecifier = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/TtsRequestIdSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/TtsRequestEmbeddingSpecifier.js
var require_TtsRequestEmbeddingSpecifier = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/TtsRequestEmbeddingSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/Controls.js
var require_Controls = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/Controls.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/Speed.js
var require_Speed = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/Speed.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/NumericalSpecifier.js
var require_NumericalSpecifier = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/NumericalSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/NaturalSpecifier.js
var require_NaturalSpecifier = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/NaturalSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NaturalSpecifier = void 0;
    exports.NaturalSpecifier = {
      Slowest: "slowest",
      Slow: "slow",
      Normal: "normal",
      Fast: "fast",
      Fastest: "fastest"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/EmotionDeprecated.js
var require_EmotionDeprecated = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/EmotionDeprecated.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmotionDeprecated = void 0;
    exports.EmotionDeprecated = {
      AngerLowest: "anger:lowest",
      AngerLow: "anger:low",
      Anger: "anger",
      AngerHigh: "anger:high",
      AngerHighest: "anger:highest",
      PositivityLowest: "positivity:lowest",
      PositivityLow: "positivity:low",
      Positivity: "positivity",
      PositivityHigh: "positivity:high",
      PositivityHighest: "positivity:highest",
      SurpriseLowest: "surprise:lowest",
      SurpriseLow: "surprise:low",
      Surprise: "surprise",
      SurpriseHigh: "surprise:high",
      SurpriseHighest: "surprise:highest",
      SadnessLowest: "sadness:lowest",
      SadnessLow: "sadness:low",
      Sadness: "sadness",
      SadnessHigh: "sadness:high",
      SadnessHighest: "sadness:highest",
      CuriosityLowest: "curiosity:lowest",
      CuriosityLow: "curiosity:low",
      Curiosity: "curiosity",
      CuriosityHigh: "curiosity:high",
      CuriosityHighest: "curiosity:highest"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/index.js
var require_types5 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ContextId(), exports);
    __exportStar(require_FlushId(), exports);
    __exportStar(require_ModelSpeed(), exports);
    __exportStar(require_WebSocketBaseResponse(), exports);
    __exportStar(require_WebSocketResponse(), exports);
    __exportStar(require_WebSocketErrorResponse(), exports);
    __exportStar(require_WebSocketChunkResponse(), exports);
    __exportStar(require_WebSocketTimestampsResponse(), exports);
    __exportStar(require_WebSocketPhonemeTimestampsResponse(), exports);
    __exportStar(require_WebSocketTtsOutput(), exports);
    __exportStar(require_WebSocketStreamOptions(), exports);
    __exportStar(require_WordTimestamps(), exports);
    __exportStar(require_PhonemeTimestamps(), exports);
    __exportStar(require_WebSocketDoneResponse(), exports);
    __exportStar(require_WebSocketFlushDoneResponse(), exports);
    __exportStar(require_CancelContextRequest(), exports);
    __exportStar(require_GenerationRequest(), exports);
    __exportStar(require_WebSocketRawOutputFormat(), exports);
    __exportStar(require_WebSocketRequest(), exports);
    __exportStar(require_WebSocketTtsRequest(), exports);
    __exportStar(require_TtsRequest(), exports);
    __exportStar(require_TtssseRequest(), exports);
    __exportStar(require_SupportedLanguage(), exports);
    __exportStar(require_GenerationConfig(), exports);
    __exportStar(require_Emotion(), exports);
    __exportStar(require_OutputFormat(), exports);
    __exportStar(require_RawOutputFormat(), exports);
    __exportStar(require_SseOutputFormat(), exports);
    __exportStar(require_RawEncoding(), exports);
    __exportStar(require_WavOutputFormat(), exports);
    __exportStar(require_Mp3OutputFormat(), exports);
    __exportStar(require_TtsRequestVoiceSpecifier(), exports);
    __exportStar(require_TtsRequestIdSpecifier(), exports);
    __exportStar(require_TtsRequestEmbeddingSpecifier(), exports);
    __exportStar(require_Controls(), exports);
    __exportStar(require_Speed(), exports);
    __exportStar(require_NumericalSpecifier(), exports);
    __exportStar(require_NaturalSpecifier(), exports);
    __exportStar(require_EmotionDeprecated(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/client/index.js
var require_client4 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/client/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/index.js
var require_tts = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types5(), exports);
    __exportStar(require_client4(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/types/OutputFormatContainer.js
var require_OutputFormatContainer = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/types/OutputFormatContainer.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutputFormatContainer = void 0;
    exports.OutputFormatContainer = {
      Raw: "raw",
      Wav: "wav",
      Mp3: "mp3"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/types/StreamingResponse.js
var require_StreamingResponse = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/types/StreamingResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/types/index.js
var require_types6 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_OutputFormatContainer(), exports);
    __exportStar(require_StreamingResponse(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/client/requests/index.js
var require_requests2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/client/requests/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/client/index.js
var require_client5 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/client/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_requests2(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/index.js
var require_voiceChanger = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types6(), exports);
    __exportStar(require_client5(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/VoiceId.js
var require_VoiceId = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/VoiceId.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/BaseVoiceId.js
var require_BaseVoiceId = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/BaseVoiceId.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/Voice.js
var require_Voice = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/Voice.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/VoiceMetadata.js
var require_VoiceMetadata = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/VoiceMetadata.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/CreateVoiceRequest.js
var require_CreateVoiceRequest = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/CreateVoiceRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/UpdateVoiceRequest.js
var require_UpdateVoiceRequest = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/UpdateVoiceRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizeTargetLanguage.js
var require_LocalizeTargetLanguage = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizeTargetLanguage.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizeTargetLanguage = void 0;
    exports.LocalizeTargetLanguage = {
      En: "en",
      De: "de",
      Es: "es",
      Fr: "fr",
      Ja: "ja",
      Pt: "pt",
      Zh: "zh",
      Hi: "hi",
      It: "it",
      Ko: "ko",
      Nl: "nl",
      Pl: "pl",
      Ru: "ru",
      Sv: "sv",
      Tr: "tr"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizeEnglishDialect.js
var require_LocalizeEnglishDialect = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizeEnglishDialect.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizeEnglishDialect = void 0;
    exports.LocalizeEnglishDialect = {
      Au: "au",
      In: "in",
      So: "so",
      Uk: "uk",
      Us: "us"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizeFrenchDialect.js
var require_LocalizeFrenchDialect = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizeFrenchDialect.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizeFrenchDialect = void 0;
    exports.LocalizeFrenchDialect = {
      Eu: "eu",
      Ca: "ca"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizeSpanishDialect.js
var require_LocalizeSpanishDialect = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizeSpanishDialect.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizeSpanishDialect = void 0;
    exports.LocalizeSpanishDialect = {
      Mx: "mx",
      Pe: "pe"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizePortugueseDialect.js
var require_LocalizePortugueseDialect = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizePortugueseDialect.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizePortugueseDialect = void 0;
    exports.LocalizePortugueseDialect = {
      Br: "br",
      Eu: "eu"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizeDialect.js
var require_LocalizeDialect = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizeDialect.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/Gender.js
var require_Gender = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/Gender.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gender = void 0;
    exports.Gender = {
      Male: "male",
      Female: "female"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizeVoiceRequest.js
var require_LocalizeVoiceRequest = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/LocalizeVoiceRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/EmbeddingResponse.js
var require_EmbeddingResponse = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/EmbeddingResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/MixVoicesRequest.js
var require_MixVoicesRequest = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/MixVoicesRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/Weight.js
var require_Weight = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/Weight.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/IdSpecifier.js
var require_IdSpecifier = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/IdSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/EmbeddingSpecifier.js
var require_EmbeddingSpecifier = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/EmbeddingSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/MixVoiceSpecifier.js
var require_MixVoiceSpecifier = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/MixVoiceSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/CloneMode.js
var require_CloneMode = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/CloneMode.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CloneMode = void 0;
    exports.CloneMode = {
      Similarity: "similarity",
      Stability: "stability"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/index.js
var require_types7 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_VoiceId(), exports);
    __exportStar(require_BaseVoiceId(), exports);
    __exportStar(require_Voice(), exports);
    __exportStar(require_VoiceMetadata(), exports);
    __exportStar(require_CreateVoiceRequest(), exports);
    __exportStar(require_UpdateVoiceRequest(), exports);
    __exportStar(require_LocalizeTargetLanguage(), exports);
    __exportStar(require_LocalizeEnglishDialect(), exports);
    __exportStar(require_LocalizeFrenchDialect(), exports);
    __exportStar(require_LocalizeSpanishDialect(), exports);
    __exportStar(require_LocalizePortugueseDialect(), exports);
    __exportStar(require_LocalizeDialect(), exports);
    __exportStar(require_Gender(), exports);
    __exportStar(require_LocalizeVoiceRequest(), exports);
    __exportStar(require_EmbeddingResponse(), exports);
    __exportStar(require_MixVoicesRequest(), exports);
    __exportStar(require_Weight(), exports);
    __exportStar(require_IdSpecifier(), exports);
    __exportStar(require_EmbeddingSpecifier(), exports);
    __exportStar(require_MixVoiceSpecifier(), exports);
    __exportStar(require_CloneMode(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/client/requests/index.js
var require_requests3 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/client/requests/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/client/index.js
var require_client6 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/client/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_requests3(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/index.js
var require_voices = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types7(), exports);
    __exportStar(require_client6(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/infill/client/requests/index.js
var require_requests4 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/infill/client/requests/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/infill/client/index.js
var require_client7 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/infill/client/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_requests4(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/infill/index.js
var require_infill = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/infill/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_client7(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/index.js
var require_resources = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.infill = exports.voices = exports.voiceChanger = exports.tts = exports.stt = exports.embedding = exports.auth = exports.apiStatus = void 0;
    exports.apiStatus = __importStar(require_apiStatus());
    __exportStar(require_types(), exports);
    exports.auth = __importStar(require_auth());
    __exportStar(require_types2(), exports);
    exports.embedding = __importStar(require_embedding());
    __exportStar(require_types3(), exports);
    exports.stt = __importStar(require_stt());
    __exportStar(require_types4(), exports);
    exports.tts = __importStar(require_tts());
    __exportStar(require_types5(), exports);
    exports.voiceChanger = __importStar(require_voiceChanger());
    __exportStar(require_types6(), exports);
    exports.voices = __importStar(require_voices());
    __exportStar(require_types7(), exports);
    exports.infill = __importStar(require_infill());
    __exportStar(require_requests4(), exports);
    __exportStar(require_requests(), exports);
    __exportStar(require_requests2(), exports);
    __exportStar(require_requests3(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/index.js
var require_api = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_resources(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/environments.js
var require_environments = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/environments.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CartesiaEnvironment = void 0;
    exports.CartesiaEnvironment = {
      Production: "https://api.cartesia.ai"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/json.js
var require_json = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/json.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toJson = void 0;
    exports.fromJson = fromJson;
    var toJson = /* @__PURE__ */ __name((value, replacer, space) => {
      return JSON.stringify(value, replacer, space);
    }, "toJson");
    exports.toJson = toJson;
    function fromJson(text, reviver) {
      return JSON.parse(text, reviver);
    }
    __name(fromJson, "fromJson");
  }
});

// ../../node_modules/es-errors/type.js
var require_type = __commonJS({
  "../../node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = TypeError;
  }
});

// (disabled):../../node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):../../node_modules/object-inspect/util.inspect"() {
    init_modules_watch_stub();
  }
});

// ../../node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../../node_modules/object-inspect/index.js"(exports, module) {
    init_modules_watch_stub();
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    __name(addNumericSeparator, "addNumericSeparator");
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    module.exports = /* @__PURE__ */ __name(function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      __name(inspect, "inspect");
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    }, "inspect_");
    function wrapQuotes(s, defaultStyle, opts) {
      var style = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style];
      return quoteChar + s + quoteChar;
    }
    __name(wrapQuotes, "wrapQuotes");
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    __name(quote, "quote");
    function canTrustToString(obj) {
      return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
    }
    __name(canTrustToString, "canTrustToString");
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && canTrustToString(obj);
    }
    __name(isArray, "isArray");
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && canTrustToString(obj);
    }
    __name(isDate, "isDate");
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
    }
    __name(isRegExp, "isRegExp");
    function isError(obj) {
      return toStr(obj) === "[object Error]" && canTrustToString(obj);
    }
    __name(isError, "isError");
    function isString(obj) {
      return toStr(obj) === "[object String]" && canTrustToString(obj);
    }
    __name(isString, "isString");
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && canTrustToString(obj);
    }
    __name(isNumber, "isNumber");
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
    }
    __name(isBoolean, "isBoolean");
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isSymbol, "isSymbol");
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isBigInt, "isBigInt");
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    __name(has, "has");
    function toStr(obj) {
      return objectToString.call(obj);
    }
    __name(toStr, "toStr");
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    __name(nameOf, "nameOf");
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    __name(indexOf, "indexOf");
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    __name(isMap, "isMap");
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    __name(isWeakMap, "isWeakMap");
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isWeakRef, "isWeakRef");
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    __name(isSet, "isSet");
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    __name(isWeakSet, "isWeakSet");
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    __name(isElement, "isElement");
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    __name(inspectString, "inspectString");
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    __name(lowbyte, "lowbyte");
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    __name(markBoxed, "markBoxed");
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    __name(weakCollectionOf, "weakCollectionOf");
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    __name(collectionOf, "collectionOf");
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    __name(singleLineValues, "singleLineValues");
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    __name(getIndent, "getIndent");
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    __name(indentedJoin, "indentedJoin");
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
    __name(arrObjKeys, "arrObjKeys");
  }
});

// ../../node_modules/side-channel-list/index.js
var require_side_channel_list = __commonJS({
  "../../node_modules/side-channel-list/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var listGetNode = /* @__PURE__ */ __name(function(list, key, isDelete) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) != null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          if (!isDelete) {
            curr.next = /** @type {NonNullable<typeof list.next>} */
            list.next;
            list.next = curr;
          }
          return curr;
        }
      }
    }, "listGetNode");
    var listGet = /* @__PURE__ */ __name(function(objects, key) {
      if (!objects) {
        return void 0;
      }
      var node = listGetNode(objects, key);
      return node && node.value;
    }, "listGet");
    var listSet = /* @__PURE__ */ __name(function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    }, "listSet");
    var listHas = /* @__PURE__ */ __name(function(objects, key) {
      if (!objects) {
        return false;
      }
      return !!listGetNode(objects, key);
    }, "listHas");
    var listDelete = /* @__PURE__ */ __name(function(objects, key) {
      if (objects) {
        return listGetNode(objects, key, true);
      }
    }, "listDelete");
    module.exports = /* @__PURE__ */ __name(function getSideChannelList() {
      var $o;
      var channel = {
        assert: /* @__PURE__ */ __name(function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        }, "assert"),
        "delete": /* @__PURE__ */ __name(function(key) {
          var root = $o && $o.next;
          var deletedNode = listDelete($o, key);
          if (deletedNode && root && root === deletedNode) {
            $o = void 0;
          }
          return !!deletedNode;
        }, "delete"),
        get: /* @__PURE__ */ __name(function(key) {
          return listGet($o, key);
        }, "get"),
        has: /* @__PURE__ */ __name(function(key) {
          return listHas($o, key);
        }, "has"),
        set: /* @__PURE__ */ __name(function(key, value) {
          if (!$o) {
            $o = {
              next: void 0
            };
          }
          listSet(
            /** @type {NonNullable<typeof $o>} */
            $o,
            key,
            value
          );
        }, "set")
      };
      return channel;
    }, "getSideChannelList");
  }
});

// ../../node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "../../node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = Object;
  }
});

// ../../node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "../../node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = Error;
  }
});

// ../../node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "../../node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = EvalError;
  }
});

// ../../node_modules/es-errors/range.js
var require_range = __commonJS({
  "../../node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = RangeError;
  }
});

// ../../node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "../../node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = ReferenceError;
  }
});

// ../../node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "../../node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = SyntaxError;
  }
});

// ../../node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "../../node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = URIError;
  }
});

// ../../node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "../../node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = Math.abs;
  }
});

// ../../node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "../../node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = Math.floor;
  }
});

// ../../node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "../../node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = Math.max;
  }
});

// ../../node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "../../node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = Math.min;
  }
});

// ../../node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "../../node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = Math.pow;
  }
});

// ../../node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "../../node_modules/math-intrinsics/round.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = Math.round;
  }
});

// ../../node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "../../node_modules/math-intrinsics/isNaN.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = Number.isNaN || /* @__PURE__ */ __name(function isNaN2(a) {
      return a !== a;
    }, "isNaN");
  }
});

// ../../node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "../../node_modules/math-intrinsics/sign.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var $isNaN = require_isNaN();
    module.exports = /* @__PURE__ */ __name(function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    }, "sign");
  }
});

// ../../node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "../../node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// ../../node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../../node_modules/gopd/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// ../../node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "../../node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// ../../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = /* @__PURE__ */ __name(function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    }, "hasSymbols");
  }
});

// ../../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = /* @__PURE__ */ __name(function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    }, "hasNativeSymbols");
  }
});

// ../../node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "../../node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// ../../node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "../../node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = /* @__PURE__ */ __name(function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    }, "concatty");
    var slicy = /* @__PURE__ */ __name(function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    }, "slicy");
    var joiny = /* @__PURE__ */ __name(function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    }, "joiny");
    module.exports = /* @__PURE__ */ __name(function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = /* @__PURE__ */ __name(function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      }, "binder");
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = /* @__PURE__ */ __name(function Empty2() {
        }, "Empty");
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    }, "bind");
  }
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "../../node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = Function.prototype.call;
  }
});

// ../../node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = Function.prototype.apply;
  }
});

// ../../node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// ../../node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// ../../node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "../../node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = /* @__PURE__ */ __name(function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    }, "callBindBasic");
  }
});

// ../../node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "../../node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      /* @__PURE__ */ __name(function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }, "getDunder")
    ) : false;
  }
});

// ../../node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "../../node_modules/get-proto/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? /* @__PURE__ */ __name(function getProto(O) {
      return reflectGetProto(O);
    }, "getProto") : originalGetProto ? /* @__PURE__ */ __name(function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    }, "getProto") : getDunderProto ? /* @__PURE__ */ __name(function getProto(O) {
      return getDunderProto(O);
    }, "getProto") : null;
  }
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/hasown/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// ../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = /* @__PURE__ */ __name(function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    }, "getEvalledConstructor");
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = /* @__PURE__ */ __name(function() {
      throw new $TypeError();
    }, "throwTypeError");
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = /* @__PURE__ */ __name(function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    }, "doEval");
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = /* @__PURE__ */ __name(function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    }, "stringToPath");
    var getBaseIntrinsic = /* @__PURE__ */ __name(function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    }, "getBaseIntrinsic");
    module.exports = /* @__PURE__ */ __name(function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    }, "GetIntrinsic");
  }
});

// ../../node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "../../node_modules/call-bound/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module.exports = /* @__PURE__ */ __name(function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    }, "callBoundIntrinsic");
  }
});

// ../../node_modules/side-channel-map/index.js
var require_side_channel_map = __commonJS({
  "../../node_modules/side-channel-map/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $Map = GetIntrinsic("%Map%", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapDelete = callBound("Map.prototype.delete", true);
    var $mapSize = callBound("Map.prototype.size", true);
    module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */
    /* @__PURE__ */ __name(function getSideChannelMap() {
      var $m;
      var channel = {
        assert: /* @__PURE__ */ __name(function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        }, "assert"),
        "delete": /* @__PURE__ */ __name(function(key) {
          if ($m) {
            var result = $mapDelete($m, key);
            if ($mapSize($m) === 0) {
              $m = void 0;
            }
            return result;
          }
          return false;
        }, "delete"),
        get: /* @__PURE__ */ __name(function(key) {
          if ($m) {
            return $mapGet($m, key);
          }
        }, "get"),
        has: /* @__PURE__ */ __name(function(key) {
          if ($m) {
            return $mapHas($m, key);
          }
          return false;
        }, "has"),
        set: /* @__PURE__ */ __name(function(key, value) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        }, "set")
      };
      return channel;
    }, "getSideChannelMap");
  }
});

// ../../node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = __commonJS({
  "../../node_modules/side-channel-weakmap/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var getSideChannelMap = require_side_channel_map();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
    module.exports = $WeakMap ? (
      /** @type {Exclude<import('.'), false>} */
      /* @__PURE__ */ __name(function getSideChannelWeakMap() {
        var $wm;
        var $m;
        var channel = {
          assert: /* @__PURE__ */ __name(function(key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          }, "assert"),
          "delete": /* @__PURE__ */ __name(function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapDelete($wm, key);
              }
            } else if (getSideChannelMap) {
              if ($m) {
                return $m["delete"](key);
              }
            }
            return false;
          }, "delete"),
          get: /* @__PURE__ */ __name(function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            }
            return $m && $m.get(key);
          }, "get"),
          has: /* @__PURE__ */ __name(function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            }
            return !!$m && $m.has(key);
          }, "has"),
          set: /* @__PURE__ */ __name(function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if (getSideChannelMap) {
              if (!$m) {
                $m = getSideChannelMap();
              }
              $m.set(key, value);
            }
          }, "set")
        };
        return channel;
      }, "getSideChannelWeakMap")
    ) : getSideChannelMap;
  }
});

// ../../node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "../../node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var getSideChannelList = require_side_channel_list();
    var getSideChannelMap = require_side_channel_map();
    var getSideChannelWeakMap = require_side_channel_weakmap();
    var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
    module.exports = /* @__PURE__ */ __name(function getSideChannel() {
      var $channelData;
      var channel = {
        assert: /* @__PURE__ */ __name(function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        }, "assert"),
        "delete": /* @__PURE__ */ __name(function(key) {
          return !!$channelData && $channelData["delete"](key);
        }, "delete"),
        get: /* @__PURE__ */ __name(function(key) {
          return $channelData && $channelData.get(key);
        }, "get"),
        has: /* @__PURE__ */ __name(function(key) {
          return !!$channelData && $channelData.has(key);
        }, "has"),
        set: /* @__PURE__ */ __name(function(key, value) {
          if (!$channelData) {
            $channelData = makeChannel();
          }
          $channelData.set(key, value);
        }, "set")
      };
      return channel;
    }, "getSideChannel");
  }
});

// ../../node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "../../node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: /* @__PURE__ */ __name(function(value) {
          return replace.call(value, percentTwenties, "+");
        }, "RFC1738"),
        RFC3986: /* @__PURE__ */ __name(function(value) {
          return String(value);
        }, "RFC3986")
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// ../../node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = /* @__PURE__ */ __name(function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    }, "compactQueue");
    var arrayToObject = /* @__PURE__ */ __name(function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? { __proto__: null } : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    }, "arrayToObject");
    var merge3 = /* @__PURE__ */ __name(function merge4(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object" && typeof source !== "function") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge4(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge4(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    }, "merge");
    var assign = /* @__PURE__ */ __name(function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    }, "assignSingleSource");
    var decode = /* @__PURE__ */ __name(function(str, defaultDecoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    }, "decode");
    var limit = 1024;
    var encode = /* @__PURE__ */ __name(function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    }, "encode");
    var compact = /* @__PURE__ */ __name(function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    }, "compact");
    var isRegExp = /* @__PURE__ */ __name(function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    }, "isRegExp");
    var isBuffer = /* @__PURE__ */ __name(function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    }, "isBuffer");
    var combine = /* @__PURE__ */ __name(function combine2(a, b) {
      return [].concat(a, b);
    }, "combine");
    var maybeMap = /* @__PURE__ */ __name(function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    }, "maybeMap");
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge: merge3
    };
  }
});

// ../../node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: /* @__PURE__ */ __name(function brackets(prefix) {
        return prefix + "[]";
      }, "brackets"),
      comma: "comma",
      indices: /* @__PURE__ */ __name(function indices(prefix, key) {
        return prefix + "[" + key + "]";
      }, "indices"),
      repeat: /* @__PURE__ */ __name(function repeat(prefix) {
        return prefix;
      }, "repeat")
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = /* @__PURE__ */ __name(function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    }, "pushToArray");
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      commaRoundTrip: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      filter: void 0,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: /* @__PURE__ */ __name(function serializeDate(date) {
        return toISO.call(date);
      }, "serializeDate"),
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = /* @__PURE__ */ __name(function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    }, "isNonNullishPrimitive");
    var sentinel = {};
    var stringify = /* @__PURE__ */ __name(function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    }, "stringify");
    var normalizeStringifyOptions = /* @__PURE__ */ __name(function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    }, "normalizeStringifyOptions");
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];
        if (options.skipNulls && value === null) {
          continue;
        }
        pushToArray(keys, stringify(
          value,
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// ../../node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false,
      throwOnLimitExceeded: false
    };
    var interpretNumericEntities = /* @__PURE__ */ __name(function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    }, "interpretNumericEntities");
    var parseArrayValue = /* @__PURE__ */ __name(function(val, options, currentArrayLength) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
        throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
      }
      return val;
    }, "parseArrayValue");
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = /* @__PURE__ */ __name(function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(
        options.delimiter,
        options.throwOnLimitExceeded ? limit + 1 : limit
      );
      if (options.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
      }
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key;
        var val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(
              part.slice(pos + 1),
              options,
              isArray(obj[key]) ? obj[key].length : 0
            ),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(String(val));
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    }, "parseQueryStringValues");
    var parseObject = /* @__PURE__ */ __name(function(chain, val, options, valuesParsed) {
      var currentArrayLength = 0;
      if (chain.length > 0 && chain[chain.length - 1] === "[]") {
        var parentKey = chain.slice(0, -1).join("");
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
      }
      var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
        } else {
          obj = options.plainObjects ? { __proto__: null } : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    }, "parseObject");
    var parseKeys = /* @__PURE__ */ __name(function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        if (options.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
        }
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    }, "parseQueryStringKeys");
    var normalizeParseOptions = /* @__PURE__ */ __name(function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
        throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
      };
    }, "normalizeParseOptions");
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? { __proto__: null } : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? { __proto__: null } : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// ../../node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var stringify = require_stringify();
    var parse = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/createRequestUrl.js
var require_createRequestUrl = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/createRequestUrl.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRequestUrl = createRequestUrl;
    var qs_1 = __importDefault(require_lib());
    function createRequestUrl(baseUrl, queryParameters) {
      return Object.keys(queryParameters !== null && queryParameters !== void 0 ? queryParameters : {}).length > 0 ? `${baseUrl}?${qs_1.default.stringify(queryParameters, { arrayFormat: "repeat" })}` : baseUrl;
    }
    __name(createRequestUrl, "createRequestUrl");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/runtime/runtime.js
var require_runtime = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/runtime/runtime.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RUNTIME = void 0;
    exports.RUNTIME = evaluateRuntime();
    function evaluateRuntime() {
      var _a, _b, _c, _d, _e;
      const isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined";
      if (isBrowser2) {
        return {
          type: "browser",
          version: window.navigator.userAgent
        };
      }
      const isCloudflare = typeof globalThis !== "undefined" && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === "Cloudflare-Workers";
      if (isCloudflare) {
        return {
          type: "workerd"
        };
      }
      const isEdgeRuntime = typeof EdgeRuntime === "string";
      if (isEdgeRuntime) {
        return {
          type: "edge-runtime"
        };
      }
      const isWebWorker = typeof self === "object" && // @ts-ignore
      typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "DedicatedWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "ServiceWorkerGlobalScope" || ((_d = self.constructor) === null || _d === void 0 ? void 0 : _d.name) === "SharedWorkerGlobalScope");
      if (isWebWorker) {
        return {
          type: "web-worker"
        };
      }
      const isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
      if (isDeno) {
        return {
          type: "deno",
          version: Deno.version.deno
        };
      }
      const isBun2 = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
      if (isBun2) {
        return {
          type: "bun",
          version: Bun.version
        };
      }
      const isNode2 = typeof process !== "undefined" && "version" in process && !!process.version && "versions" in process && !!((_e = process.versions) === null || _e === void 0 ? void 0 : _e.node);
      if (isNode2) {
        return {
          type: "node",
          version: process.versions.node,
          parsedVersion: Number(process.versions.node.split(".")[0])
        };
      }
      const isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
      if (isReactNative) {
        return {
          type: "react-native"
        };
      }
      return {
        type: "unknown"
      };
    }
    __name(evaluateRuntime, "evaluateRuntime");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/runtime/index.js
var require_runtime2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/runtime/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RUNTIME = void 0;
    var runtime_1 = require_runtime();
    Object.defineProperty(exports, "RUNTIME", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return runtime_1.RUNTIME;
    }, "get") });
  }
});

// ../../node_modules/node-fetch/browser.js
var require_browser2 = __commonJS({
  "../../node_modules/node-fetch/browser.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var getGlobal = /* @__PURE__ */ __name(function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    }, "getGlobal");
    var globalObject = getGlobal();
    module.exports = exports = globalObject.fetch;
    if (globalObject.fetch) {
      exports.default = globalObject.fetch.bind(globalObject);
    }
    exports.Headers = globalObject.Headers;
    exports.Request = globalObject.Request;
    exports.Response = globalObject.Response;
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/getFetchFn.js
var require_getFetchFn = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/getFetchFn.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFetchFn = getFetchFn;
    var runtime_1 = require_runtime2();
    function getFetchFn() {
      return __awaiter11(this, void 0, void 0, function* () {
        if (runtime_1.RUNTIME.type === "node" && runtime_1.RUNTIME.parsedVersion != null && runtime_1.RUNTIME.parsedVersion >= 18) {
          return fetch;
        }
        if (runtime_1.RUNTIME.type === "node") {
          return (yield Promise.resolve().then(() => __importStar(require_browser2()))).default;
        }
        if (typeof fetch == "function") {
          return fetch;
        }
        return (yield Promise.resolve().then(() => __importStar(require_browser2()))).default;
      });
    }
    __name(getFetchFn, "getFetchFn");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/getRequestBody.js
var require_getRequestBody = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/getRequestBody.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRequestBody = getRequestBody;
    var json_1 = require_json();
    function getRequestBody(_a) {
      return __awaiter11(this, arguments, void 0, function* ({ body, type }) {
        if (type.includes("json")) {
          return (0, json_1.toJson)(body);
        } else {
          return body;
        }
      });
    }
    __name(getRequestBody, "getRequestBody");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/stream-wrappers/Node18UniversalStreamWrapper.js
var require_Node18UniversalStreamWrapper = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/stream-wrappers/Node18UniversalStreamWrapper.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Node18UniversalStreamWrapper = void 0;
    var Node18UniversalStreamWrapper = class _Node18UniversalStreamWrapper {
      static {
        __name(this, "Node18UniversalStreamWrapper");
      }
      constructor(readableStream) {
        this.readableStream = readableStream;
        this.reader = this.readableStream.getReader();
        this.events = {
          data: [],
          end: [],
          error: [],
          readable: [],
          close: [],
          pause: [],
          resume: []
        };
        this.paused = false;
        this.resumeCallback = null;
        this.encoding = null;
      }
      on(event, callback) {
        var _a;
        (_a = this.events[event]) === null || _a === void 0 ? void 0 : _a.push(callback);
      }
      off(event, callback) {
        var _a;
        this.events[event] = (_a = this.events[event]) === null || _a === void 0 ? void 0 : _a.filter((cb) => cb !== callback);
      }
      pipe(dest) {
        this.on("data", (chunk) => __awaiter11(this, void 0, void 0, function* () {
          if (dest instanceof _Node18UniversalStreamWrapper) {
            dest._write(chunk);
          } else if (dest instanceof WritableStream) {
            const writer = dest.getWriter();
            writer.write(chunk).then(() => writer.releaseLock());
          } else {
            dest.write(chunk);
          }
        }));
        this.on("end", () => __awaiter11(this, void 0, void 0, function* () {
          if (dest instanceof _Node18UniversalStreamWrapper) {
            dest._end();
          } else if (dest instanceof WritableStream) {
            const writer = dest.getWriter();
            writer.close();
          } else {
            dest.end();
          }
        }));
        this.on("error", (error) => __awaiter11(this, void 0, void 0, function* () {
          if (dest instanceof _Node18UniversalStreamWrapper) {
            dest._error(error);
          } else if (dest instanceof WritableStream) {
            const writer = dest.getWriter();
            writer.abort(error);
          } else {
            dest.destroy(error);
          }
        }));
        this._startReading();
        return dest;
      }
      pipeTo(dest) {
        return this.pipe(dest);
      }
      unpipe(dest) {
        this.off("data", (chunk) => __awaiter11(this, void 0, void 0, function* () {
          if (dest instanceof _Node18UniversalStreamWrapper) {
            dest._write(chunk);
          } else if (dest instanceof WritableStream) {
            const writer = dest.getWriter();
            writer.write(chunk).then(() => writer.releaseLock());
          } else {
            dest.write(chunk);
          }
        }));
        this.off("end", () => __awaiter11(this, void 0, void 0, function* () {
          if (dest instanceof _Node18UniversalStreamWrapper) {
            dest._end();
          } else if (dest instanceof WritableStream) {
            const writer = dest.getWriter();
            writer.close();
          } else {
            dest.end();
          }
        }));
        this.off("error", (error) => __awaiter11(this, void 0, void 0, function* () {
          if (dest instanceof _Node18UniversalStreamWrapper) {
            dest._error(error);
          } else if (dest instanceof WritableStream) {
            const writer = dest.getWriter();
            writer.abort(error);
          } else {
            dest.destroy(error);
          }
        }));
      }
      destroy(error) {
        this.reader.cancel(error).then(() => {
          this._emit("close");
        }).catch((err) => {
          this._emit("error", err);
        });
      }
      pause() {
        this.paused = true;
        this._emit("pause");
      }
      resume() {
        if (this.paused) {
          this.paused = false;
          this._emit("resume");
          if (this.resumeCallback) {
            this.resumeCallback();
            this.resumeCallback = null;
          }
        }
      }
      get isPaused() {
        return this.paused;
      }
      read() {
        return __awaiter11(this, void 0, void 0, function* () {
          if (this.paused) {
            yield new Promise((resolve) => {
              this.resumeCallback = resolve;
            });
          }
          const { done, value } = yield this.reader.read();
          if (done) {
            return void 0;
          }
          return value;
        });
      }
      setEncoding(encoding) {
        this.encoding = encoding;
      }
      text() {
        return __awaiter11(this, void 0, void 0, function* () {
          const chunks = [];
          while (true) {
            const { done, value } = yield this.reader.read();
            if (done) {
              break;
            }
            if (value) {
              chunks.push(value);
            }
          }
          const decoder = new TextDecoder(this.encoding || "utf-8");
          return decoder.decode(yield new Blob(chunks).arrayBuffer());
        });
      }
      json() {
        return __awaiter11(this, void 0, void 0, function* () {
          const text = yield this.text();
          return JSON.parse(text);
        });
      }
      _write(chunk) {
        this._emit("data", chunk);
      }
      _end() {
        this._emit("end");
      }
      _error(error) {
        this._emit("error", error);
      }
      _emit(event, data) {
        if (this.events[event]) {
          for (const callback of this.events[event] || []) {
            callback(data);
          }
        }
      }
      _startReading() {
        return __awaiter11(this, void 0, void 0, function* () {
          try {
            this._emit("readable");
            while (true) {
              if (this.paused) {
                yield new Promise((resolve) => {
                  this.resumeCallback = resolve;
                });
              }
              const { done, value } = yield this.reader.read();
              if (done) {
                this._emit("end");
                this._emit("close");
                break;
              }
              if (value) {
                this._emit("data", value);
              }
            }
          } catch (error) {
            this._emit("error", error);
          }
        });
      }
      [Symbol.asyncIterator]() {
        return {
          next: /* @__PURE__ */ __name(() => __awaiter11(this, void 0, void 0, function* () {
            if (this.paused) {
              yield new Promise((resolve) => {
                this.resumeCallback = resolve;
              });
            }
            const { done, value } = yield this.reader.read();
            if (done) {
              return { done: true, value: void 0 };
            }
            return { done: false, value };
          }), "next"),
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
    };
    exports.Node18UniversalStreamWrapper = Node18UniversalStreamWrapper;
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/stream-wrappers/UndiciStreamWrapper.js
var require_UndiciStreamWrapper = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/stream-wrappers/UndiciStreamWrapper.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UndiciStreamWrapper = void 0;
    var UndiciStreamWrapper = class _UndiciStreamWrapper {
      static {
        __name(this, "UndiciStreamWrapper");
      }
      constructor(readableStream) {
        this.readableStream = readableStream;
        this.reader = this.readableStream.getReader();
        this.events = {
          data: [],
          end: [],
          error: [],
          readable: [],
          close: [],
          pause: [],
          resume: []
        };
        this.paused = false;
        this.resumeCallback = null;
        this.encoding = null;
      }
      on(event, callback) {
        var _a;
        (_a = this.events[event]) === null || _a === void 0 ? void 0 : _a.push(callback);
      }
      off(event, callback) {
        var _a;
        this.events[event] = (_a = this.events[event]) === null || _a === void 0 ? void 0 : _a.filter((cb) => cb !== callback);
      }
      pipe(dest) {
        this.on("data", (chunk) => {
          if (dest instanceof _UndiciStreamWrapper) {
            dest._write(chunk);
          } else {
            const writer = dest.getWriter();
            writer.write(chunk).then(() => writer.releaseLock());
          }
        });
        this.on("end", () => {
          if (dest instanceof _UndiciStreamWrapper) {
            dest._end();
          } else {
            const writer = dest.getWriter();
            writer.close();
          }
        });
        this.on("error", (error) => {
          if (dest instanceof _UndiciStreamWrapper) {
            dest._error(error);
          } else {
            const writer = dest.getWriter();
            writer.abort(error);
          }
        });
        this._startReading();
        return dest;
      }
      pipeTo(dest) {
        return this.pipe(dest);
      }
      unpipe(dest) {
        this.off("data", (chunk) => {
          if (dest instanceof _UndiciStreamWrapper) {
            dest._write(chunk);
          } else {
            const writer = dest.getWriter();
            writer.write(chunk).then(() => writer.releaseLock());
          }
        });
        this.off("end", () => {
          if (dest instanceof _UndiciStreamWrapper) {
            dest._end();
          } else {
            const writer = dest.getWriter();
            writer.close();
          }
        });
        this.off("error", (error) => {
          if (dest instanceof _UndiciStreamWrapper) {
            dest._error(error);
          } else {
            const writer = dest.getWriter();
            writer.abort(error);
          }
        });
      }
      destroy(error) {
        this.reader.cancel(error).then(() => {
          this._emit("close");
        }).catch((err) => {
          this._emit("error", err);
        });
      }
      pause() {
        this.paused = true;
        this._emit("pause");
      }
      resume() {
        if (this.paused) {
          this.paused = false;
          this._emit("resume");
          if (this.resumeCallback) {
            this.resumeCallback();
            this.resumeCallback = null;
          }
        }
      }
      get isPaused() {
        return this.paused;
      }
      read() {
        return __awaiter11(this, void 0, void 0, function* () {
          if (this.paused) {
            yield new Promise((resolve) => {
              this.resumeCallback = resolve;
            });
          }
          const { done, value } = yield this.reader.read();
          if (done) {
            return void 0;
          }
          return value;
        });
      }
      setEncoding(encoding) {
        this.encoding = encoding;
      }
      text() {
        return __awaiter11(this, void 0, void 0, function* () {
          const chunks = [];
          while (true) {
            const { done, value } = yield this.reader.read();
            if (done) {
              break;
            }
            if (value) {
              chunks.push(value);
            }
          }
          const decoder = new TextDecoder(this.encoding || "utf-8");
          return decoder.decode(yield new Blob(chunks).arrayBuffer());
        });
      }
      json() {
        return __awaiter11(this, void 0, void 0, function* () {
          const text = yield this.text();
          return JSON.parse(text);
        });
      }
      _write(chunk) {
        this._emit("data", chunk);
      }
      _end() {
        this._emit("end");
      }
      _error(error) {
        this._emit("error", error);
      }
      _emit(event, data) {
        if (this.events[event]) {
          for (const callback of this.events[event] || []) {
            callback(data);
          }
        }
      }
      _startReading() {
        return __awaiter11(this, void 0, void 0, function* () {
          try {
            this._emit("readable");
            while (true) {
              if (this.paused) {
                yield new Promise((resolve) => {
                  this.resumeCallback = resolve;
                });
              }
              const { done, value } = yield this.reader.read();
              if (done) {
                this._emit("end");
                this._emit("close");
                break;
              }
              if (value) {
                this._emit("data", value);
              }
            }
          } catch (error) {
            this._emit("error", error);
          }
        });
      }
      [Symbol.asyncIterator]() {
        return {
          next: /* @__PURE__ */ __name(() => __awaiter11(this, void 0, void 0, function* () {
            if (this.paused) {
              yield new Promise((resolve) => {
                this.resumeCallback = resolve;
              });
            }
            const { done, value } = yield this.reader.read();
            if (done) {
              return { done: true, value: void 0 };
            }
            return { done: false, value };
          }), "next"),
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
    };
    exports.UndiciStreamWrapper = UndiciStreamWrapper;
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/stream-wrappers/NodePre18StreamWrapper.js
var require_NodePre18StreamWrapper = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/stream-wrappers/NodePre18StreamWrapper.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      __name(verb, "verb");
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
      __name(settle, "settle");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodePre18StreamWrapper = void 0;
    var NodePre18StreamWrapper = class {
      static {
        __name(this, "NodePre18StreamWrapper");
      }
      constructor(readableStream) {
        this.readableStream = readableStream;
      }
      on(event, callback) {
        this.readableStream.on(event, callback);
      }
      off(event, callback) {
        this.readableStream.off(event, callback);
      }
      pipe(dest) {
        this.readableStream.pipe(dest);
        return dest;
      }
      pipeTo(dest) {
        return this.pipe(dest);
      }
      unpipe(dest) {
        if (dest) {
          this.readableStream.unpipe(dest);
        } else {
          this.readableStream.unpipe();
        }
      }
      destroy(error) {
        this.readableStream.destroy(error);
      }
      pause() {
        this.readableStream.pause();
      }
      resume() {
        this.readableStream.resume();
      }
      get isPaused() {
        return this.readableStream.isPaused();
      }
      read() {
        return __awaiter11(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            const chunk = this.readableStream.read();
            if (chunk) {
              resolve(chunk);
            } else {
              this.readableStream.once("readable", () => {
                const chunk2 = this.readableStream.read();
                resolve(chunk2);
              });
              this.readableStream.once("error", reject);
            }
          });
        });
      }
      setEncoding(encoding) {
        this.readableStream.setEncoding(encoding);
        this.encoding = encoding;
      }
      text() {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, e_1, _b, _c;
          const chunks = [];
          const encoder = new TextEncoder();
          this.readableStream.setEncoding(this.encoding || "utf-8");
          try {
            for (var _d = true, _e = __asyncValues(this.readableStream), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
              _c = _f.value;
              _d = false;
              const chunk = _c;
              chunks.push(encoder.encode(chunk));
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          const decoder = new TextDecoder(this.encoding || "utf-8");
          return decoder.decode(Buffer.concat(chunks));
        });
      }
      json() {
        return __awaiter11(this, void 0, void 0, function* () {
          const text = yield this.text();
          return JSON.parse(text);
        });
      }
      [Symbol.asyncIterator]() {
        const readableStream = this.readableStream;
        const iterator = readableStream[Symbol.asyncIterator]();
        return {
          next() {
            return __awaiter11(this, void 0, void 0, function* () {
              const { value, done } = yield iterator.next();
              return { value, done };
            });
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
    };
    exports.NodePre18StreamWrapper = NodePre18StreamWrapper;
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/stream-wrappers/chooseStreamWrapper.js
var require_chooseStreamWrapper = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/stream-wrappers/chooseStreamWrapper.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chooseStreamWrapper = chooseStreamWrapper;
    var runtime_1 = require_runtime2();
    function chooseStreamWrapper(responseBody) {
      return __awaiter11(this, void 0, void 0, function* () {
        if (runtime_1.RUNTIME.type === "node" && runtime_1.RUNTIME.parsedVersion != null && runtime_1.RUNTIME.parsedVersion >= 18) {
          return new (yield Promise.resolve().then(() => __importStar(require_Node18UniversalStreamWrapper()))).Node18UniversalStreamWrapper(responseBody);
        } else if (runtime_1.RUNTIME.type !== "node" && typeof fetch === "function") {
          return new (yield Promise.resolve().then(() => __importStar(require_UndiciStreamWrapper()))).UndiciStreamWrapper(responseBody);
        } else {
          return new (yield Promise.resolve().then(() => __importStar(require_NodePre18StreamWrapper()))).NodePre18StreamWrapper(responseBody);
        }
      });
    }
    __name(chooseStreamWrapper, "chooseStreamWrapper");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/getResponseBody.js
var require_getResponseBody = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/getResponseBody.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getResponseBody = getResponseBody;
    var chooseStreamWrapper_1 = require_chooseStreamWrapper();
    function getResponseBody(response, responseType) {
      return __awaiter11(this, void 0, void 0, function* () {
        if (response.body != null && responseType === "blob") {
          return yield response.blob();
        } else if (response.body != null && responseType === "arrayBuffer") {
          return yield response.arrayBuffer();
        } else if (response.body != null && responseType === "sse") {
          return response.body;
        } else if (response.body != null && responseType === "streaming") {
          return (0, chooseStreamWrapper_1.chooseStreamWrapper)(response.body);
        } else if (response.body != null && responseType === "text") {
          return yield response.text();
        } else {
          const text = yield response.text();
          if (text.length > 0) {
            try {
              let responseBody = JSON.parse(text);
              return responseBody;
            } catch (err) {
              return {
                ok: false,
                error: {
                  reason: "non-json",
                  statusCode: response.status,
                  rawBody: text
                }
              };
            }
          } else {
            return void 0;
          }
        }
      });
    }
    __name(getResponseBody, "getResponseBody");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/signals.js
var require_signals = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/signals.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTimeoutSignal = getTimeoutSignal;
    exports.anySignal = anySignal;
    var TIMEOUT = "timeout";
    function getTimeoutSignal(timeoutMs) {
      const controller = new AbortController();
      const abortId = setTimeout(() => controller.abort(TIMEOUT), timeoutMs);
      return { signal: controller.signal, abortId };
    }
    __name(getTimeoutSignal, "getTimeoutSignal");
    function anySignal(...args) {
      const signals = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
      const controller = new AbortController();
      for (const signal of signals) {
        if (signal.aborted) {
          controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason);
          break;
        }
        signal.addEventListener("abort", () => controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason), {
          signal: controller.signal
        });
      }
      return controller.signal;
    }
    __name(anySignal, "anySignal");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/makeRequest.js
var require_makeRequest = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/makeRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeRequest = void 0;
    var signals_1 = require_signals();
    var makeRequest = /* @__PURE__ */ __name((fetchFn, url, method, headers, requestBody, timeoutMs, abortSignal, withCredentials, duplex) => __awaiter11(void 0, void 0, void 0, function* () {
      const signals = [];
      let timeoutAbortId = void 0;
      if (timeoutMs != null) {
        const { signal, abortId } = (0, signals_1.getTimeoutSignal)(timeoutMs);
        timeoutAbortId = abortId;
        signals.push(signal);
      }
      if (abortSignal != null) {
        signals.push(abortSignal);
      }
      let newSignals = (0, signals_1.anySignal)(signals);
      const response = yield fetchFn(url, {
        method,
        headers,
        body: requestBody,
        signal: newSignals,
        credentials: withCredentials ? "include" : void 0,
        // @ts-ignore
        duplex
      });
      if (timeoutAbortId != null) {
        clearTimeout(timeoutAbortId);
      }
      return response;
    }), "makeRequest");
    exports.makeRequest = makeRequest;
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/requestWithRetries.js
var require_requestWithRetries = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/requestWithRetries.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestWithRetries = requestWithRetries;
    var INITIAL_RETRY_DELAY = 1e3;
    var MAX_RETRY_DELAY = 6e4;
    var DEFAULT_MAX_RETRIES = 2;
    var JITTER_FACTOR = 0.2;
    function addJitter(delay) {
      const jitterMultiplier = 1 + (Math.random() * 2 - 1) * JITTER_FACTOR;
      return delay * jitterMultiplier;
    }
    __name(addJitter, "addJitter");
    function requestWithRetries(requestFn_1) {
      return __awaiter11(this, arguments, void 0, function* (requestFn, maxRetries = DEFAULT_MAX_RETRIES) {
        let response = yield requestFn();
        for (let i = 0; i < maxRetries; ++i) {
          if ([408, 429].includes(response.status) || response.status >= 500) {
            const baseDelay = Math.min(INITIAL_RETRY_DELAY * Math.pow(2, i), MAX_RETRY_DELAY);
            const delayWithJitter = addJitter(baseDelay);
            yield new Promise((resolve) => setTimeout(resolve, delayWithJitter));
            response = yield requestFn();
          } else {
            break;
          }
        }
        return response;
      });
    }
    __name(requestWithRetries, "requestWithRetries");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/Fetcher.js
var require_Fetcher = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/Fetcher.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fetcher = void 0;
    exports.fetcherImpl = fetcherImpl;
    var json_1 = require_json();
    var createRequestUrl_1 = require_createRequestUrl();
    var getFetchFn_1 = require_getFetchFn();
    var getRequestBody_1 = require_getRequestBody();
    var getResponseBody_1 = require_getResponseBody();
    var makeRequest_1 = require_makeRequest();
    var requestWithRetries_1 = require_requestWithRetries();
    function fetcherImpl(args) {
      return __awaiter11(this, void 0, void 0, function* () {
        const headers = {};
        if (args.body !== void 0 && args.contentType != null) {
          headers["Content-Type"] = args.contentType;
        }
        if (args.headers != null) {
          for (const [key, value] of Object.entries(args.headers)) {
            if (value != null) {
              headers[key] = value;
            }
          }
        }
        const url = (0, createRequestUrl_1.createRequestUrl)(args.url, args.queryParameters);
        const requestBody = yield (0, getRequestBody_1.getRequestBody)({
          body: args.body,
          type: args.requestType === "json" ? "json" : "other"
        });
        const fetchFn = yield (0, getFetchFn_1.getFetchFn)();
        try {
          const response = yield (0, requestWithRetries_1.requestWithRetries)(() => __awaiter11(this, void 0, void 0, function* () {
            return (0, makeRequest_1.makeRequest)(fetchFn, url, args.method, headers, requestBody, args.timeoutMs, args.abortSignal, args.withCredentials, args.duplex);
          }), args.maxRetries);
          const responseBody = yield (0, getResponseBody_1.getResponseBody)(response, args.responseType);
          if (response.status >= 200 && response.status < 400) {
            return {
              ok: true,
              body: responseBody,
              headers: response.headers
            };
          } else {
            return {
              ok: false,
              error: {
                reason: "status-code",
                statusCode: response.status,
                body: responseBody
              }
            };
          }
        } catch (error) {
          if (args.abortSignal != null && args.abortSignal.aborted) {
            return {
              ok: false,
              error: {
                reason: "unknown",
                errorMessage: "The user aborted a request"
              }
            };
          } else if (error instanceof Error && error.name === "AbortError") {
            return {
              ok: false,
              error: {
                reason: "timeout"
              }
            };
          } else if (error instanceof Error) {
            return {
              ok: false,
              error: {
                reason: "unknown",
                errorMessage: error.message
              }
            };
          }
          return {
            ok: false,
            error: {
              reason: "unknown",
              errorMessage: (0, json_1.toJson)(error)
            }
          };
        }
      });
    }
    __name(fetcherImpl, "fetcherImpl");
    exports.fetcher = fetcherImpl;
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/getHeader.js
var require_getHeader = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/getHeader.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHeader = getHeader;
    function getHeader(headers, header) {
      for (const [headerKey, headerValue] of Object.entries(headers)) {
        if (headerKey.toLowerCase() === header.toLowerCase()) {
          return headerValue;
        }
      }
      return void 0;
    }
    __name(getHeader, "getHeader");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/Supplier.js
var require_Supplier = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/Supplier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Supplier = void 0;
    exports.Supplier = {
      get: /* @__PURE__ */ __name((supplier) => __awaiter11(void 0, void 0, void 0, function* () {
        if (typeof supplier === "function") {
          return supplier();
        } else {
          return supplier;
        }
      }), "get")
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/fetcher/index.js
var require_fetcher = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/fetcher/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Supplier = exports.getHeader = exports.fetcher = void 0;
    var Fetcher_1 = require_Fetcher();
    Object.defineProperty(exports, "fetcher", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return Fetcher_1.fetcher;
    }, "get") });
    var getHeader_1 = require_getHeader();
    Object.defineProperty(exports, "getHeader", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return getHeader_1.getHeader;
    }, "get") });
    var Supplier_1 = require_Supplier();
    Object.defineProperty(exports, "Supplier", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return Supplier_1.Supplier;
    }, "get") });
  }
});

// ../../node_modules/formdata-node/lib/browser.cjs
var require_browser3 = __commonJS({
  "../../node_modules/formdata-node/lib/browser.cjs"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export = /* @__PURE__ */ __name((target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: /* @__PURE__ */ __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod), "__toCommonJS");
    var browser_exports = {};
    __export(browser_exports, {
      Blob: /* @__PURE__ */ __name(() => Blob2, "Blob"),
      File: /* @__PURE__ */ __name(() => File, "File"),
      FormData: /* @__PURE__ */ __name(() => FormData2, "FormData")
    });
    module.exports = __toCommonJS(browser_exports);
    var globalObject = function() {
      if (typeof globalThis !== "undefined") {
        return globalThis;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      return window;
    }();
    var { FormData: FormData2, Blob: Blob2, File } = globalObject;
  }
});

// ../../node_modules/form-data-encoder/lib/index.cjs
var require_lib2 = __commonJS({
  "../../node_modules/form-data-encoder/lib/index.cjs"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __typeError = /* @__PURE__ */ __name((msg) => {
      throw TypeError(msg);
    }, "__typeError");
    var __export = /* @__PURE__ */ __name((target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: /* @__PURE__ */ __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod), "__toCommonJS");
    var __accessCheck = /* @__PURE__ */ __name((obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg), "__accessCheck");
    var __privateGet = /* @__PURE__ */ __name((obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), "__privateGet");
    var __privateAdd = /* @__PURE__ */ __name((obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value), "__privateAdd");
    var __privateSet = /* @__PURE__ */ __name((obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value), "__privateSet");
    var __privateMethod = /* @__PURE__ */ __name((obj, member, method) => (__accessCheck(obj, member, "access private method"), method), "__privateMethod");
    var src_exports = {};
    __export(src_exports, {
      FormDataEncoder: /* @__PURE__ */ __name(() => FormDataEncoder, "FormDataEncoder"),
      isFile: /* @__PURE__ */ __name(() => isFile, "isFile"),
      isFormData: /* @__PURE__ */ __name(() => isFormData, "isFormData")
    });
    module.exports = __toCommonJS(src_exports);
    var MAX_CHUNK_SIZE = 65536;
    function* chunk(value) {
      if (value.byteLength <= MAX_CHUNK_SIZE) {
        yield value;
        return;
      }
      let offset = 0;
      while (offset < value.byteLength) {
        const size = Math.min(value.byteLength - offset, MAX_CHUNK_SIZE);
        const buffer = value.buffer.slice(offset, offset + size);
        offset += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
    __name(chunk, "chunk");
    var alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
    function createBoundary() {
      let size = 16;
      let res = "";
      while (size--) {
        res += alphabet[Math.random() * alphabet.length << 0];
      }
      return res;
    }
    __name(createBoundary, "createBoundary");
    var escapeName = /* @__PURE__ */ __name((name) => String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22"), "escapeName");
    var isFunction = /* @__PURE__ */ __name((value) => typeof value === "function", "isFunction");
    var isReadableStreamFallback = /* @__PURE__ */ __name((value) => !!value && typeof value === "object" && !Array.isArray(value) && isFunction(value.getReader), "isReadableStreamFallback");
    var isAsyncIterable = /* @__PURE__ */ __name((value) => isFunction(value[Symbol.asyncIterator]), "isAsyncIterable");
    async function* readStream(readable) {
      const reader = readable.getReader();
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        yield value;
      }
    }
    __name(readStream, "readStream");
    async function* chunkStream(stream) {
      for await (const value of stream) {
        yield* chunk(value);
      }
    }
    __name(chunkStream, "chunkStream");
    var getStreamIterator = /* @__PURE__ */ __name((source) => {
      if (isAsyncIterable(source)) {
        return chunkStream(source);
      }
      if (isReadableStreamFallback(source)) {
        return chunkStream(readStream(source));
      }
      throw new TypeError(
        "Unsupported data source: Expected either ReadableStream or async iterable."
      );
    }, "getStreamIterator");
    var isFile = /* @__PURE__ */ __name((value) => Boolean(
      value && typeof value === "object" && isFunction(value.constructor) && value[Symbol.toStringTag] === "File" && isFunction(value.stream) && value.name != null
    ), "isFile");
    var isFormData = /* @__PURE__ */ __name((value) => Boolean(
      value && isFunction(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction(value.append) && isFunction(value.getAll) && isFunction(value.entries) && isFunction(value[Symbol.iterator])
    ), "isFormData");
    var getType = /* @__PURE__ */ __name((value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase(), "getType");
    function isPlainObject(value) {
      if (getType(value) !== "object") {
        return false;
      }
      const pp = Object.getPrototypeOf(value);
      if (pp === null || pp === void 0) {
        return true;
      }
      return pp.constructor?.toString?.() === Object.toString();
    }
    __name(isPlainObject, "isPlainObject");
    var normalizeValue = /* @__PURE__ */ __name((value) => String(value).replace(/\r|\n/g, (match, i, str) => {
      if (match === "\r" && str[i + 1] !== "\n" || match === "\n" && str[i - 1] !== "\r") {
        return "\r\n";
      }
      return match;
    }), "normalizeValue");
    function getProperty(target, prop) {
      if (typeof prop === "string") {
        for (const [name, value] of Object.entries(target)) {
          if (prop.toLowerCase() === name.toLowerCase()) {
            return value;
          }
        }
      }
      return void 0;
    }
    __name(getProperty, "getProperty");
    var proxyHeaders = /* @__PURE__ */ __name((object) => new Proxy(
      object,
      {
        get: /* @__PURE__ */ __name((target, prop) => getProperty(target, prop), "get"),
        has: /* @__PURE__ */ __name((target, prop) => getProperty(target, prop) !== void 0, "has")
      }
    ), "proxyHeaders");
    var defaultOptions = {
      enableAdditionalHeaders: false
    };
    var readonlyProp = { writable: false, configurable: false };
    var _CRLF;
    var _CRLF_BYTES;
    var _CRLF_BYTES_LENGTH;
    var _DASHES;
    var _encoder;
    var _footer;
    var _form;
    var _options;
    var _FormDataEncoder_instances;
    var getFieldHeader_fn;
    var getContentLength_fn;
    var FormDataEncoder = class {
      static {
        __name(this, "FormDataEncoder");
      }
      constructor(form, boundaryOrOptions, options) {
        __privateAdd(this, _FormDataEncoder_instances);
        __privateAdd(this, _CRLF, "\r\n");
        __privateAdd(this, _CRLF_BYTES);
        __privateAdd(this, _CRLF_BYTES_LENGTH);
        __privateAdd(this, _DASHES, "-".repeat(2));
        __privateAdd(this, _encoder, new TextEncoder());
        __privateAdd(this, _footer);
        __privateAdd(this, _form);
        __privateAdd(this, _options);
        if (!isFormData(form)) {
          throw new TypeError("Expected first argument to be a FormData instance.");
        }
        let boundary;
        if (isPlainObject(boundaryOrOptions)) {
          options = boundaryOrOptions;
        } else {
          boundary = boundaryOrOptions;
        }
        if (!boundary) {
          boundary = `form-data-encoder-${createBoundary()}`;
        }
        if (typeof boundary !== "string") {
          throw new TypeError("Expected boundary argument to be a string.");
        }
        if (options && !isPlainObject(options)) {
          throw new TypeError("Expected options argument to be an object.");
        }
        __privateSet(this, _form, Array.from(form.entries()));
        __privateSet(this, _options, { ...defaultOptions, ...options });
        __privateSet(this, _CRLF_BYTES, __privateGet(this, _encoder).encode(__privateGet(this, _CRLF)));
        __privateSet(this, _CRLF_BYTES_LENGTH, __privateGet(this, _CRLF_BYTES).byteLength);
        this.boundary = boundary;
        this.contentType = `multipart/form-data; boundary=${this.boundary}`;
        __privateSet(this, _footer, __privateGet(this, _encoder).encode(
          `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _DASHES)}${__privateGet(this, _CRLF).repeat(2)}`
        ));
        const headers = {
          "Content-Type": this.contentType
        };
        const contentLength = __privateMethod(this, _FormDataEncoder_instances, getContentLength_fn).call(this);
        if (contentLength) {
          this.contentLength = contentLength;
          headers["Content-Length"] = contentLength;
        }
        this.headers = proxyHeaders(Object.freeze(headers));
        Object.defineProperties(this, {
          boundary: readonlyProp,
          contentType: readonlyProp,
          contentLength: readonlyProp,
          headers: readonlyProp
        });
      }
      /**
       * Creates an iterator allowing to go through form-data parts (with metadata).
       * This method **will not** read the files and **will not** split values big into smaller chunks.
       *
       * Using this method, you can convert form-data content into Blob:
       *
       * @example
       *
       * ```ts
       * import {Readable} from "stream"
       *
       * import {FormDataEncoder} from "form-data-encoder"
       *
       * import {FormData} from "formdata-polyfill/esm-min.js"
       * import {fileFrom} from "fetch-blob/form.js"
       * import {File} from "fetch-blob/file.js"
       * import {Blob} from "fetch-blob"
       *
       * import fetch from "node-fetch"
       *
       * const form = new FormData()
       *
       * form.set("field", "Just a random string")
       * form.set("file", new File(["Using files is class amazing"]))
       * form.set("fileFromPath", await fileFrom("path/to/a/file.txt"))
       *
       * const encoder = new FormDataEncoder(form)
       *
       * const options = {
       *   method: "post",
       *   body: new Blob(encoder, {type: encoder.contentType})
       * }
       *
       * const response = await fetch("https://httpbin.org/post", options)
       *
       * console.log(await response.json())
       * ```
       */
      *values() {
        for (const [name, raw] of __privateGet(this, _form)) {
          const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));
          yield __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value);
          yield value;
          yield __privateGet(this, _CRLF_BYTES);
        }
        yield __privateGet(this, _footer);
      }
      /**
       * Creates an async iterator allowing to perform the encoding by portions.
       * This method reads through files and splits big values into smaller pieces (65536 bytes per each).
       *
       * @example
       *
       * ```ts
       * import {Readable} from "stream"
       *
       * import {FormData, File, fileFromPath} from "formdata-node"
       * import {FormDataEncoder} from "form-data-encoder"
       *
       * import fetch from "node-fetch"
       *
       * const form = new FormData()
       *
       * form.set("field", "Just a random string")
       * form.set("file", new File(["Using files is class amazing"], "file.txt"))
       * form.set("fileFromPath", await fileFromPath("path/to/a/file.txt"))
       *
       * const encoder = new FormDataEncoder(form)
       *
       * const options = {
       *   method: "post",
       *   headers: encoder.headers,
       *   body: Readable.from(encoder.encode()) // or Readable.from(encoder)
       * }
       *
       * const response = await fetch("https://httpbin.org/post", options)
       *
       * console.log(await response.json())
       * ```
       */
      async *encode() {
        for (const part of this.values()) {
          if (isFile(part)) {
            yield* getStreamIterator(part.stream());
          } else {
            yield* chunk(part);
          }
        }
      }
      /**
       * Creates an iterator allowing to read through the encoder data using for...of loops
       */
      [Symbol.iterator]() {
        return this.values();
      }
      /**
       * Creates an **async** iterator allowing to read through the encoder data using for-await...of loops
       */
      [Symbol.asyncIterator]() {
        return this.encode();
      }
    };
    _CRLF = /* @__PURE__ */ new WeakMap();
    _CRLF_BYTES = /* @__PURE__ */ new WeakMap();
    _CRLF_BYTES_LENGTH = /* @__PURE__ */ new WeakMap();
    _DASHES = /* @__PURE__ */ new WeakMap();
    _encoder = /* @__PURE__ */ new WeakMap();
    _footer = /* @__PURE__ */ new WeakMap();
    _form = /* @__PURE__ */ new WeakMap();
    _options = /* @__PURE__ */ new WeakMap();
    _FormDataEncoder_instances = /* @__PURE__ */ new WeakSet();
    getFieldHeader_fn = /* @__PURE__ */ __name(function(name, value) {
      let header = "";
      header += `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _CRLF)}`;
      header += `Content-Disposition: form-data; name="${escapeName(name)}"`;
      if (isFile(value)) {
        header += `; filename="${escapeName(value.name)}"${__privateGet(this, _CRLF)}`;
        header += `Content-Type: ${value.type || "application/octet-stream"}`;
      }
      if (__privateGet(this, _options).enableAdditionalHeaders === true) {
        const size = isFile(value) ? value.size : value.byteLength;
        if (size != null && !isNaN(size)) {
          header += `${__privateGet(this, _CRLF)}Content-Length: ${size}`;
        }
      }
      return __privateGet(this, _encoder).encode(`${header}${__privateGet(this, _CRLF).repeat(2)}`);
    }, "getFieldHeader_fn");
    getContentLength_fn = /* @__PURE__ */ __name(function() {
      let length = 0;
      for (const [name, raw] of __privateGet(this, _form)) {
        const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));
        const size = isFile(value) ? value.size : value.byteLength;
        if (size == null || isNaN(size)) {
          return void 0;
        }
        length += __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value).byteLength;
        length += size;
        length += __privateGet(this, _CRLF_BYTES_LENGTH);
      }
      return String(length + __privateGet(this, _footer).byteLength);
    }, "getContentLength_fn");
  }
});

// ../../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/base64-js/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    __name(getLens, "getLens");
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(byteLength, "byteLength");
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(_byteLength, "_byteLength");
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    __name(toByteArray, "toByteArray");
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    __name(tripletToBase64, "tripletToBase64");
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    __name(encodeChunk, "encodeChunk");
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    __name(fromByteArray, "fromByteArray");
  }
});

// ../../node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../node_modules/ieee754/index.js"(exports) {
    init_modules_watch_stub();
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// ../../node_modules/buffer/index.js
var require_buffer = __commonJS({
  "../../node_modules/buffer/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: /* @__PURE__ */ __name(function() {
          return 42;
        }, "foo") };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    __name(typedArraySupport, "typedArraySupport");
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }, "get")
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }, "get")
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    __name(createBuffer, "createBuffer");
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    __name(Buffer2, "Buffer");
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    __name(from, "from");
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    __name(assertSize, "assertSize");
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    __name(alloc, "alloc");
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    __name(allocUnsafe, "allocUnsafe");
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    __name(fromString, "fromString");
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    __name(fromArrayLike, "fromArrayLike");
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    __name(fromArrayView, "fromArrayView");
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    __name(fromArrayBuffer, "fromArrayBuffer");
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    __name(fromObject, "fromObject");
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    __name(checked, "checked");
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    __name(SlowBuffer, "SlowBuffer");
    Buffer2.isBuffer = /* @__PURE__ */ __name(function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    }, "isBuffer");
    Buffer2.compare = /* @__PURE__ */ __name(function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    }, "compare");
    Buffer2.isEncoding = /* @__PURE__ */ __name(function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, "isEncoding");
    Buffer2.concat = /* @__PURE__ */ __name(function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    }, "concat");
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(byteLength, "byteLength");
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(slowToString, "slowToString");
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    __name(swap, "swap");
    Buffer2.prototype.swap16 = /* @__PURE__ */ __name(function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    }, "swap16");
    Buffer2.prototype.swap32 = /* @__PURE__ */ __name(function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    }, "swap32");
    Buffer2.prototype.swap64 = /* @__PURE__ */ __name(function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    }, "swap64");
    Buffer2.prototype.toString = /* @__PURE__ */ __name(function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    }, "toString");
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = /* @__PURE__ */ __name(function equals(b) {
      if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer2.compare(this, b) === 0;
    }, "equals");
    Buffer2.prototype.inspect = /* @__PURE__ */ __name(function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    }, "inspect");
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = /* @__PURE__ */ __name(function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    }, "compare");
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    __name(bidirectionalIndexOf, "bidirectionalIndexOf");
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      __name(read, "read");
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    __name(arrayIndexOf, "arrayIndexOf");
    Buffer2.prototype.includes = /* @__PURE__ */ __name(function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    }, "includes");
    Buffer2.prototype.indexOf = /* @__PURE__ */ __name(function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    }, "indexOf");
    Buffer2.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    }, "lastIndexOf");
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    __name(hexWrite, "hexWrite");
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    __name(utf8Write, "utf8Write");
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    __name(asciiWrite, "asciiWrite");
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    __name(base64Write, "base64Write");
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    __name(ucs2Write, "ucs2Write");
    Buffer2.prototype.write = /* @__PURE__ */ __name(function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }, "write");
    Buffer2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    }, "toJSON");
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    __name(base64Slice, "base64Slice");
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    __name(utf8Slice, "utf8Slice");
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    __name(decodeCodePointsArray, "decodeCodePointsArray");
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    __name(asciiSlice, "asciiSlice");
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    __name(latin1Slice, "latin1Slice");
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    __name(hexSlice, "hexSlice");
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    __name(utf16leSlice, "utf16leSlice");
    Buffer2.prototype.slice = /* @__PURE__ */ __name(function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    }, "slice");
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    __name(checkOffset, "checkOffset");
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    }, "readUIntLE");
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    }, "readUIntBE");
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    }, "readUInt8");
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    }, "readUInt16LE");
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    }, "readUInt16BE");
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    }, "readUInt32LE");
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    }, "readUInt32BE");
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    }, "readBigUInt64LE"));
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    }, "readBigUInt64BE"));
    Buffer2.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    }, "readIntLE");
    Buffer2.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    }, "readIntBE");
    Buffer2.prototype.readInt8 = /* @__PURE__ */ __name(function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    }, "readInt8");
    Buffer2.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    }, "readInt16LE");
    Buffer2.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    }, "readInt16BE");
    Buffer2.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    }, "readInt32LE");
    Buffer2.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    }, "readInt32BE");
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    }, "readBigInt64LE"));
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    }, "readBigInt64BE"));
    Buffer2.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    }, "readFloatLE");
    Buffer2.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    }, "readFloatBE");
    Buffer2.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    }, "readDoubleLE");
    Buffer2.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    }, "readDoubleBE");
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    __name(checkInt, "checkInt");
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    }, "writeUIntLE");
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    }, "writeUIntBE");
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    }, "writeUInt8");
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeUInt16LE");
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeUInt16BE");
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    }, "writeUInt32LE");
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeUInt32BE");
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    __name(wrtBigUInt64LE, "wrtBigUInt64LE");
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    __name(wrtBigUInt64BE, "wrtBigUInt64BE");
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64LE"));
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64BE"));
    Buffer2.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    }, "writeIntLE");
    Buffer2.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    }, "writeIntBE");
    Buffer2.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    }, "writeInt8");
    Buffer2.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeInt16LE");
    Buffer2.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeInt16BE");
    Buffer2.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    }, "writeInt32LE");
    Buffer2.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeInt32BE");
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64LE"));
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64BE"));
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    __name(checkIEEE754, "checkIEEE754");
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    __name(writeFloat, "writeFloat");
    Buffer2.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    }, "writeFloatLE");
    Buffer2.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    }, "writeFloatBE");
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    __name(writeDouble, "writeDouble");
    Buffer2.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    }, "writeDoubleLE");
    Buffer2.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }, "writeDoubleBE");
    Buffer2.prototype.copy = /* @__PURE__ */ __name(function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    }, "copy");
    Buffer2.prototype.fill = /* @__PURE__ */ __name(function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    }, "fill");
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        static {
          __name(this, "NodeError");
        }
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    __name(E, "E");
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    __name(addNumericalSeparator, "addNumericalSeparator");
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    __name(checkBounds, "checkBounds");
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    __name(checkIntBI, "checkIntBI");
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    __name(validateNumber, "validateNumber");
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    __name(boundsError, "boundsError");
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    __name(base64clean, "base64clean");
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    __name(utf8ToBytes, "utf8ToBytes");
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    __name(asciiToBytes, "asciiToBytes");
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    __name(utf16leToBytes, "utf16leToBytes");
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    __name(base64ToBytes, "base64ToBytes");
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    __name(blitBuffer, "blitBuffer");
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    __name(isInstance, "isInstance");
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    __name(numberIsNaN, "numberIsNaN");
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    __name(defineBigIntMethod, "defineBigIntMethod");
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    __name(BufferBigIntNotDefined, "BufferBigIntNotDefined");
  }
});

// ../../node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "../../node_modules/readable-stream/lib/ours/primordials.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var AggregateError2 = class extends Error {
      static {
        __name(this, "AggregateError");
      }
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i = 0; i < errors.length; i++) {
          message += `    ${errors[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module.exports = {
      AggregateError: AggregateError2,
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name, prop) {
        return Object.defineProperty(self2, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name) {
        return Object.getOwnPropertyDescriptor(self2, name);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
  }
});

// ../../node_modules/readable-stream/lib/ours/util/inspect.js
var require_inspect = __commonJS({
  "../../node_modules/readable-stream/lib/ours/util/inspect.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = {
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      }
    };
  }
});

// ../../node_modules/readable-stream/lib/ours/errors.js
var require_errors = __commonJS({
  "../../node_modules/readable-stream/lib/ours/errors.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var { format, inspect } = require_inspect();
    var { AggregateError: CustomAggregateError } = require_primordials();
    var AggregateError2 = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    __name(assert, "assert");
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    __name(addNumericalSeparator, "addNumericalSeparator");
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    __name(getMessage, "getMessage");
    function E(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        static {
          __name(this, "NodeError");
        }
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    __name(E, "E");
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    __name(hideStackFrames, "hideStackFrames");
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError2([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    __name(aggregateTwoErrors, "aggregateTwoErrors");
    var AbortError = class extends Error {
      static {
        __name(this, "AbortError");
      }
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name, expected, actual) => {
        assert(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(types, pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          switch (types.length) {
            case 1:
              msg += `of type ${types[0]}`;
              break;
            case 2:
              msg += `one of type ${types[0]} or ${types[1]}`;
              break;
            default: {
              const last = types.pop();
              msg += `one of type ${types.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type = name.includes(".") ? "property" : "argument";
        return `The ${type} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name, value) => {
        var _value$constructor;
        const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          const limit = BigInt(2) ** BigInt(32);
          if (input > limit || input < -limit) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// ../../node_modules/abort-controller/browser.js
var require_browser4 = __commonJS({
  "../../node_modules/abort-controller/browser.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var { AbortController: AbortController2, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    module.exports = AbortController2;
    module.exports.AbortSignal = AbortSignal;
    module.exports.default = AbortController2;
  }
});

// ../../node_modules/readable-stream/lib/ours/util.js
var require_util2 = __commonJS({
  "../../node_modules/readable-stream/lib/ours/util.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var bufferModule = require_buffer();
    var { format, inspect } = require_inspect();
    var {
      codes: { ERR_INVALID_ARG_TYPE }
    } = require_errors();
    var { kResistStopPropagation, AggregateError: AggregateError2, SymbolDispose } = require_primordials();
    var AbortSignal = globalThis.AbortSignal || require_browser4().AbortSignal;
    var AbortController2 = globalThis.AbortController || require_browser4().AbortController;
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? /* @__PURE__ */ __name(function isBlob2(b) {
      return b instanceof Blob2;
    }, "isBlob") : /* @__PURE__ */ __name(function isBlob2(b) {
      return false;
    }, "isBlob");
    var validateAbortSignal = /* @__PURE__ */ __name((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    }, "validateAbortSignal");
    var validateFunction = /* @__PURE__ */ __name((value, name) => {
      if (typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
      }
    }, "validateFunction");
    module.exports = {
      AggregateError: AggregateError2,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: /* @__PURE__ */ __name(function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      }, "createDeferredPromise"),
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format,
      inspect,
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: require_events().addAbortListener || /* @__PURE__ */ __name(function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = /* @__PURE__ */ __name(() => {
            signal.removeEventListener("abort", listener);
          }, "removeEventListener");
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      }, "addAbortListener"),
      AbortSignalAny: AbortSignal.any || /* @__PURE__ */ __name(function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController2();
        const abort = /* @__PURE__ */ __name(() => ac.abort(), "abort");
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener(
          "abort",
          () => {
            signals.forEach((signal) => signal.removeEventListener("abort", abort));
          },
          {
            once: true
          }
        );
        return ac.signal;
      }, "AbortSignalAny")
    };
    module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// ../../node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "../../node_modules/readable-stream/lib/internal/validators.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors();
    var { normalizeEncoding } = require_util2();
    var { isAsyncFunction, isArrayBufferView } = require_util2().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    __name(isInt32, "isInt32");
    function isUint32(value) {
      return value === value >>> 0;
    }
    __name(isUint32, "isUint32");
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name);
      return value;
    }
    __name(parseFileMode, "parseFileMode");
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string") throw new ERR_INVALID_ARG_TYPE(name, "string", value);
    }
    __name(validateString, "validateString");
    function validateNumber(value, name, min = void 0, max) {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    __name(validateNumber, "validateNumber");
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean") throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
    __name(validateBoolean, "validateBoolean");
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    __name(getOwnPropertyValueOrDefault, "getOwnPropertyValueOrDefault");
    var validateObject = hideStackFrames((value, name, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name}[${i}]`);
      }
    }
    __name(validateStringArray, "validateStringArray");
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name}[${i}]`);
      }
    }
    __name(validateBooleanArray, "validateBooleanArray");
    function validateAbortSignalArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        const signal = value[i];
        const indexedName = `${name}[${i}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    __name(validateAbortSignalArray, "validateAbortSignalArray");
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    __name(validateSignalName, "validateSignalName");
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    __name(validateEncoding, "validateEncoding");
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    __name(validatePort, "validatePort");
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0) throw new ERR_INVALID_ARG_TYPE(name, "undefined", value);
    });
    function validateUnion(value, name, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    __name(validateUnion, "validateUnion");
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    __name(validateLinkHeaderFormat, "validateLinkHeaderFormat");
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    __name(validateLinkHeaderValue, "validateLinkHeaderValue");
    module.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// ../../node_modules/process/browser.js
var require_browser5 = __commonJS({
  "../../node_modules/process/browser.js"(exports, module) {
    init_modules_watch_stub();
    var process2 = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    __name(defaultSetTimout, "defaultSetTimout");
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    __name(defaultClearTimeout, "defaultClearTimeout");
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    __name(runTimeout, "runTimeout");
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    __name(runClearTimeout, "runClearTimeout");
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    __name(cleanUpNextTick, "cleanUpNextTick");
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    __name(drainQueue, "drainQueue");
    process2.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    __name(Item, "Item");
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process2.title = "browser";
    process2.browser = true;
    process2.env = {};
    process2.argv = [];
    process2.version = "";
    process2.versions = {};
    function noop2() {
    }
    __name(noop2, "noop");
    process2.on = noop2;
    process2.addListener = noop2;
    process2.once = noop2;
    process2.off = noop2;
    process2.removeListener = noop2;
    process2.removeAllListeners = noop2;
    process2.emit = noop2;
    process2.prependListener = noop2;
    process2.prependOnceListener = noop2;
    process2.listeners = function(name) {
      return [];
    };
    process2.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process2.cwd = function() {
      return "/";
    };
    process2.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process2.umask = function() {
      return 0;
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    var kIsErrored = SymbolFor("nodejs.stream.errored");
    var kIsReadable = SymbolFor("nodejs.stream.readable");
    var kIsWritable = SymbolFor("nodejs.stream.writable");
    var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    __name(isReadableNodeStream, "isReadableNodeStream");
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    __name(isWritableNodeStream, "isWritableNodeStream");
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    __name(isDuplexNodeStream, "isDuplexNodeStream");
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    __name(isNodeStream, "isNodeStream");
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    __name(isReadableStream, "isReadableStream");
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    __name(isWritableStream, "isWritableStream");
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    __name(isTransformStream, "isTransformStream");
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    __name(isWebStream, "isWebStream");
    function isIterable(obj, isAsync) {
      if (obj == null) return false;
      if (isAsync === true) return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false) return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    __name(isIterable, "isIterable");
    function isDestroyed(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    __name(isDestroyed, "isDestroyed");
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableEnded === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean") return null;
      return wState.ended;
    }
    __name(isWritableEnded, "isWritableEnded");
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableFinished === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean") return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    __name(isWritableFinished, "isWritableFinished");
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream)) return null;
      if (stream.readableEnded === true) return true;
      const rState = stream._readableState;
      if (!rState || rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean") return null;
      return rState.ended;
    }
    __name(isReadableEnded, "isReadableEnded");
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream)) return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean") return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    __name(isReadableFinished, "isReadableFinished");
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null) return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    __name(isReadable, "isReadable");
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null) return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    __name(isWritable, "isWritable");
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    __name(isFinished, "isFinished");
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    __name(isWritableErrored, "isWritableErrored");
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    __name(isReadableErrored, "isReadableErrored");
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    __name(isClosed, "isClosed");
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    __name(isOutgoingMessage, "isOutgoingMessage");
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    __name(isServerResponse, "isServerResponse");
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    __name(isServerRequest, "isServerRequest");
    function willEmitClose(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    __name(willEmitClose, "willEmitClose");
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    __name(isDisturbed, "isDisturbed");
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    __name(isErrored, "isErrored");
    module.exports = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var process2 = require_browser5();
    var { AbortError, codes } = require_errors();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util2();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils2();
    var addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    __name(isRequest, "isRequest");
    var nop = /* @__PURE__ */ __name(() => {
    }, "nop");
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = /* @__PURE__ */ __name(() => {
        if (!stream.writable) {
          onfinish();
        }
      }, "onlegacyfinish");
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = /* @__PURE__ */ __name(() => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      }, "onfinish");
      let readableFinished = isReadableFinished(stream, false);
      const onend = /* @__PURE__ */ __name(() => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      }, "onend");
      const onerror = /* @__PURE__ */ __name((err) => {
        callback.call(stream, err);
      }, "onerror");
      let closed = isClosed(stream);
      const onclose = /* @__PURE__ */ __name(() => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      }, "onclose");
      const onclosed = /* @__PURE__ */ __name(() => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      }, "onclosed");
      const onrequest = /* @__PURE__ */ __name(() => {
        stream.req.on("finish", onfinish);
      }, "onrequest");
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process2.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process2.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process2.nextTick(onclosed);
      }
      const cleanup = /* @__PURE__ */ __name(() => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      }, "cleanup");
      if (options.signal && !closed) {
        const abort = /* @__PURE__ */ __name(() => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        }, "abort");
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util2().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    __name(eos, "eos");
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = /* @__PURE__ */ __name(() => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        }, "abort");
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util2().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = /* @__PURE__ */ __name((...args) => {
        if (!isAborted) {
          process2.nextTick(() => callback.apply(stream, args));
        }
      }, "resolverFn");
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    __name(eosWeb, "eosWeb");
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    __name(finished, "finished");
    module.exports = eos;
    module.exports.finished = finished;
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var process2 = require_browser5();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors();
    var { Symbol: Symbol2 } = require_primordials();
    var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils2();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    __name(checkError, "checkError");
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    __name(destroy, "destroy");
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process2.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process2.nextTick(emitCloseNT, self2);
        }
      }
      __name(onDestroy, "onDestroy");
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    __name(_destroy, "_destroy");
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    __name(emitErrorCloseNT, "emitErrorCloseNT");
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    __name(emitCloseNT, "emitCloseNT");
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    __name(emitErrorNT, "emitErrorNT");
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    __name(undestroy, "undestroy");
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process2.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    __name(errorOrDestroy, "errorOrDestroy");
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process2.nextTick(constructNT, stream);
    }
    __name(construct, "construct");
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process2.nextTick(emitConstructNT, stream);
        }
      }
      __name(onConstruct, "onConstruct");
      try {
        stream._construct((err) => {
          process2.nextTick(onConstruct, err);
        });
      } catch (err) {
        process2.nextTick(onConstruct, err);
      }
    }
    __name(constructNT, "constructNT");
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    __name(emitConstructNT, "emitConstructNT");
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    __name(isRequest, "isRequest");
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    __name(emitCloseLegacy, "emitCloseLegacy");
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process2.nextTick(emitCloseLegacy, stream);
    }
    __name(emitErrorCloseLegacy, "emitErrorCloseLegacy");
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process2.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    __name(destroyer, "destroyer");
    module.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require_events();
    function Stream(opts) {
      EE.call(this, opts);
    }
    __name(Stream, "Stream");
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      __name(ondata, "ondata");
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      __name(ondrain, "ondrain");
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      __name(onend, "onend");
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      __name(onclose, "onclose");
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      __name(onerror, "onerror");
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      __name(cleanup, "cleanup");
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    __name(prependListener, "prependListener");
    module.exports = {
      Stream,
      prependListener
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var { SymbolDispose } = require_primordials();
    var { AbortError, codes } = require_errors();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils2();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE } = codes;
    var addAbortListener;
    var validateAbortSignal = /* @__PURE__ */ __name((signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    }, "validateAbortSignal");
    module.exports.addAbortSignal = /* @__PURE__ */ __name(function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module.exports.addAbortSignalNoValidate(signal, stream);
    }, "addAbortSignal");
    module.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || require_util2().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer2 } = require_buffer();
    var { inspect } = require_util2();
    module.exports = class BufferList {
      static {
        __name(this, "BufferList");
      }
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0) return;
        const ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0) return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null) ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer2.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { validateInteger } = require_validators();
    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
    var defaultHighWaterMarkBytes = 16 * 1024;
    var defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    __name(highWaterMarkFrom, "highWaterMarkFrom");
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    __name(getDefaultHighWaterMark, "getDefaultHighWaterMark");
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    __name(setDefaultHighWaterMark, "setDefaultHighWaterMark");
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    __name(getHighWaterMark, "getHighWaterMark");
    module.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
  }
});

// ../../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/safe-buffer/index.js"(exports, module) {
    init_modules_watch_stub();
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    __name(copyProps, "copyProps");
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    __name(SafeBuffer, "SafeBuffer");
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../../node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    __name(_normalizeEncoding, "_normalizeEncoding");
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    __name(normalizeEncoding, "normalizeEncoding");
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    __name(StringDecoder, "StringDecoder");
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    __name(utf8CheckByte, "utf8CheckByte");
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    __name(utf8CheckIncomplete, "utf8CheckIncomplete");
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    __name(utf8CheckExtraBytes, "utf8CheckExtraBytes");
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    __name(utf8FillLast, "utf8FillLast");
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    __name(utf8Text, "utf8Text");
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    __name(utf8End, "utf8End");
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    __name(utf16Text, "utf16Text");
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    __name(utf16End, "utf16End");
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    __name(base64Text, "base64Text");
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    __name(base64End, "base64End");
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    __name(simpleWrite, "simpleWrite");
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
    __name(simpleEnd, "simpleEnd");
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/from.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var process2 = require_browser5();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer2 } = require_buffer();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;
    function from(Readable, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer2) {
        return new Readable({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process2.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process2.nextTick(cb, e || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      __name(close, "close");
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      __name(next, "next");
      return readable;
    }
    __name(from, "from");
    module.exports = from;
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var process2 = require_browser5();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module.exports = Readable;
    Readable.ReadableState = ReadableState;
    var { EventEmitter: EE } = require_events();
    var { Stream, prependListener } = require_legacy();
    var { Buffer: Buffer2 } = require_buffer();
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util2().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError
    } = require_errors();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require_string_decoder();
    var from = require_from();
    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable, Stream);
    var nop = /* @__PURE__ */ __name(() => {
    }, "nop");
    var { errorOrDestroy } = destroyImpl;
    var kObjectMode = 1 << 0;
    var kEnded = 1 << 1;
    var kEndEmitted = 1 << 2;
    var kReading = 1 << 3;
    var kConstructed = 1 << 4;
    var kSync = 1 << 5;
    var kNeedReadable = 1 << 6;
    var kEmittedReadable = 1 << 7;
    var kReadableListening = 1 << 8;
    var kResumeScheduled = 1 << 9;
    var kErrorEmitted = 1 << 10;
    var kEmitClose = 1 << 11;
    var kAutoDestroy = 1 << 12;
    var kDestroyed = 1 << 13;
    var kClosed = 1 << 14;
    var kCloseEmitted = 1 << 15;
    var kMultiAwaitDrain = 1 << 16;
    var kReadingMore = 1 << 17;
    var kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return (this.state & bit) !== 0;
        },
        set(value) {
          if (value) this.state |= bit;
          else this.state &= ~bit;
        }
      };
    }
    __name(makeBitMapDescriptor, "makeBitMapDescriptor");
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
      this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode) this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this[kPaused] = null;
      if (options && options.emitClose === false) this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;
      this.errored = null;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    __name(ReadableState, "ReadableState");
    function Readable(options) {
      if (!(this instanceof Readable)) return new Readable(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal && !isDuplex) addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    __name(Readable, "Readable");
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed) {
        error = this.readableEnded ? null : new AbortError();
        this.destroy(error);
      }
      return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
    };
    Readable.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.state &= ~kReading;
        onEofChunk(stream, state);
      } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored) return false;
          else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.state &= ~kReading;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
            else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.state &= ~kReading;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    __name(readableAddChunk, "readableAddChunk");
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    __name(addChunk, "addChunk");
    Readable.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "") buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    __name(computeNewHighWaterMark, "computeNewHighWaterMark");
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if ((state.state & kObjectMode) !== 0) return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length) return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length) return n;
      return state.ended ? state.length : 0;
    }
    __name(howMuchToRead, "howMuchToRead");
    Readable.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0) state.state &= ~kEmittedReadable;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.state |= kReading | kSync;
        if (state.length === 0) state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.state &= ~kSync;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    __name(onEofChunk, "onEofChunk");
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process2.nextTick(emitReadable_, stream);
      }
    }
    __name(emitReadable, "emitReadable");
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    __name(emitReadable_, "emitReadable_");
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process2.nextTick(maybeReadMore_, stream, state);
      }
    }
    __name(maybeReadMore, "maybeReadMore");
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    __name(maybeReadMore_, "maybeReadMore_");
    Readable.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process2.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      __name(onunpipe, "onunpipe");
      function onend() {
        debug("onend");
        dest.end();
      }
      __name(onend, "onend");
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      __name(cleanup, "cleanup");
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      __name(pause, "pause");
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      __name(ondata, "ondata");
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      __name(onerror, "onerror");
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      __name(onclose, "onclose");
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      __name(onfinish, "onfinish");
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      __name(unpipe, "unpipe");
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return /* @__PURE__ */ __name(function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      }, "pipeOnDrainFunctionResult");
    }
    __name(pipeOnDrain, "pipeOnDrain");
    Readable.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0) return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0) this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process2.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.off = Readable.prototype.removeListener;
    Readable.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    __name(updateReadableListening, "updateReadableListening");
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    __name(nReadingNextTick, "nReadingNextTick");
    Readable.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process2.nextTick(resume_, stream, state);
      }
    }
    __name(resume, "resume");
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    __name(resume_, "resume_");
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    __name(flow, "flow");
    Readable.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    __name(streamToAsyncIterator, "streamToAsyncIterator");
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      __name(next, "next");
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    __name(createAsyncIterator, "createAsyncIterator");
    ObjectDefineProperties(Readable.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: /* @__PURE__ */ __name(function() {
          return this._readableState.dataEmitted;
        }, "get")
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: /* @__PURE__ */ __name(function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }, "get")
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: /* @__PURE__ */ __name(function() {
          return this._readableState.highWaterMark;
        }, "get")
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: /* @__PURE__ */ __name(function() {
          return this._readableState && this._readableState.buffer;
        }, "get")
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: /* @__PURE__ */ __name(function() {
          return this._readableState.flowing;
        }, "get"),
        set: /* @__PURE__ */ __name(function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }, "set")
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      let ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    __name(fromList, "fromList");
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process2.nextTick(endReadableNT, state, stream);
      }
    }
    __name(endReadable, "endReadable");
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process2.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    __name(endReadableNT, "endReadableNT");
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    __name(endWritableNT, "endWritableNT");
    Readable.from = function(iterable, opts) {
      return from(Readable, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    __name(lazyWebStreams, "lazyWebStreams");
    Readable.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var process2 = require_browser5();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require_events();
    var Stream = require_legacy().Stream;
    var { Buffer: Buffer2 } = require_buffer();
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    __name(nop, "nop");
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    __name(WritableState, "WritableState");
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    __name(resetBuffer, "resetBuffer");
    WritableState.prototype.getBuffer = /* @__PURE__ */ __name(function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    }, "getBuffer");
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal) addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    __name(Writable, "Writable");
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: /* @__PURE__ */ __name(function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }, "value")
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding) encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function") cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process2.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    __name(_write, "_write");
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = /* @__PURE__ */ __name(function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer2.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    }, "setDefaultEncoding");
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    __name(writeOrBuffer, "writeOrBuffer");
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    __name(doWrite, "doWrite");
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    __name(onwriteError, "onwriteError");
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process2.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    __name(onwrite, "onwrite");
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    __name(afterWriteTick, "afterWriteTick");
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    __name(afterWrite, "afterWrite");
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    __name(errorBuffer, "errorBuffer");
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    __name(clearBuffer, "clearBuffer");
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process2.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    __name(needFinish, "needFinish");
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process2.nextTick(finish, stream, state);
        }
      }
      __name(onFinish, "onFinish");
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    __name(callFinal, "callFinal");
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    __name(prefinish, "prefinish");
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process2.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    __name(finishMaybe, "finishMaybe");
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    __name(finish, "finish");
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState) return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: /* @__PURE__ */ __name(function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }, "get")
      }
    });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process2.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    __name(lazyWebStreams, "lazyWebStreams");
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module) {
    init_modules_watch_stub();
    var process2 = require_browser5();
    var bufferModule = require_buffer();
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream,
      isWritableStream
    } = require_utils2();
    var eos = require_end_of_stream();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable = require_readable();
    var Writable = require_writable();
    var { createDeferredPromise } = require_util2();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? /* @__PURE__ */ __name(function isBlob2(b) {
      return b instanceof Blob2;
    }, "isBlob") : /* @__PURE__ */ __name(function isBlob2(b) {
      return false;
    }, "isBlob");
    var AbortController2 = globalThis.AbortController || require_browser4().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      static {
        __name(this, "Duplexify");
      }
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module.exports = /* @__PURE__ */ __name(function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream(body)) {
        return _duplexify({
          readable: Readable.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process2.nextTick(cb, null);
                } catch (err) {
                  process2.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    }, "duplexify");
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController2();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process2.nextTick(cb);
            if (done) return;
            if (signal.aborted)
              throw new AbortError(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    __name(fromAsyncGen, "fromAsyncGen");
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      __name(onfinished, "onfinished");
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
    __name(_duplexify, "_duplexify");
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module.exports = Duplex;
    var Readable = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
    ObjectSetPrototypeOf(Duplex, Readable);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    __name(Duplex, "Duplex");
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    __name(lazyWebStreams, "lazyWebStreams");
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    __name(Transform, "Transform");
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    __name(final, "final");
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    __name(prefinish, "prefinish");
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var { ObjectSetPrototypeOf } = require_primordials();
    module.exports = PassThrough;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    __name(PassThrough, "PassThrough");
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    init_modules_watch_stub();
    var process2 = require_browser5();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util2();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = require_errors();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableFinished
    } = require_utils2();
    var AbortController2 = globalThis.AbortController || require_browser4().AbortController;
    var PassThrough;
    var Readable;
    var addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: /* @__PURE__ */ __name((err) => {
          if (finished) return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        }, "destroy"),
        cleanup
      };
    }
    __name(destroyer, "destroyer");
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    __name(popCallback, "popCallback");
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    __name(makeAsyncIterable, "makeAsyncIterable");
    async function* fromReadable(val) {
      if (!Readable) {
        Readable = require_readable();
      }
      yield* Readable.prototype[SymbolAsyncIterator].call(val);
    }
    __name(fromReadable, "fromReadable");
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = /* @__PURE__ */ __name((err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      }, "resume");
      const wait = /* @__PURE__ */ __name(() => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = /* @__PURE__ */ __name(() => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          }, "onresolve");
        }
      }), "wait");
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    __name(pumpToNode, "pumpToNode");
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    __name(pumpToWeb, "pumpToWeb");
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    __name(pipeline, "pipeline");
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      __name(abort, "abort");
      addAbortListener = addAbortListener || require_util2().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort);
      }
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      __name(finish, "finish");
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        ;
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process2.nextTick(callback, error, value);
        }
      }
      __name(finishImpl, "finishImpl");
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          __name(onError2, "onError");
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process2.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process2.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process2.nextTick(abort);
      }
      return ret;
    }
    __name(pipelineImpl, "pipelineImpl");
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        __name(endFn2, "endFn");
        if (isReadableFinished(src)) {
          process2.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    __name(pipe, "pipe");
    module.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = require_utils2();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors();
    var eos = require_end_of_stream();
    module.exports = /* @__PURE__ */ __name(function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      __name(onfinished, "onfinished");
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    }, "compose");
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var AbortController2 = globalThis.AbortController || require_browser4().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils2();
    var { deprecate } = require_util2();
    var {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    __name(compose, "compose");
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return (/* @__PURE__ */ __name(async function* map2() {
        const signal = require_util2().AbortSignalAny(
          [options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)
        );
        const stream = this;
        const queue = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        __name(onCatch, "onCatch");
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        __name(afterItemProcessed, "afterItemProcessed");
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        __name(maybeResume, "maybeResume");
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        __name(pump, "pump");
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }, "map")).call(this);
    }
    __name(map, "map");
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return (/* @__PURE__ */ __name(async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }, "asIndexedPairs")).call(this);
    }
    __name(asIndexedPairs, "asIndexedPairs");
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    __name(some, "some");
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    __name(every, "every");
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    __name(find, "find");
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      __name(forEachFn, "forEachFn");
      for await (const unused of map.call(this, forEachFn, options)) ;
    }
    __name(forEach, "forEach");
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      __name(filterFn, "filterFn");
      return map.call(this, filterFn, options);
    }
    __name(filter, "filter");
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      static {
        __name(this, "ReduceAwareErrMissingArgs");
      }
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    __name(reduce, "reduce");
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    __name(toArray, "toArray");
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return (/* @__PURE__ */ __name(async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }, "flatMap")).call(this);
    }
    __name(flatMap, "flatMap");
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    __name(toIntegerOrInfinity, "toIntegerOrInfinity");
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (/* @__PURE__ */ __name(async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }, "drop")).call(this);
    }
    __name(drop, "drop");
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (/* @__PURE__ */ __name(async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError();
          }
          if (number-- > 0) {
            yield val;
          }
          if (number <= 0) {
            return;
          }
        }
      }, "take")).call(this);
    }
    __name(take, "take");
    module.exports.streamReturningOperators = {
      asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    module.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// ../../node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "../../node_modules/readable-stream/lib/stream/promises.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils2();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    require_stream();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    __name(pipeline, "pipeline");
    module.exports = {
      finished,
      pipeline
    };
  }
});

// ../../node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS({
  "../../node_modules/readable-stream/lib/stream.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var { Buffer: Buffer2 } = require_buffer();
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util2();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors();
    var compose = require_compose();
    var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils2();
    var Stream = module.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      __name(fn, "fn");
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      __name(fn, "fn");
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = /* @__PURE__ */ __name(function isUint8Array(value) {
      return value instanceof Uint8Array;
    }, "isUint8Array");
    Stream._uint8ArrayToBuffer = /* @__PURE__ */ __name(function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    }, "_uint8ArrayToBuffer");
  }
});

// ../../node_modules/readable-stream/lib/ours/browser.js
var require_browser6 = __commonJS({
  "../../node_modules/readable-stream/lib/ours/browser.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var CustomStream = require_stream();
    var promises = require_promises();
    var originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable;
    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module.exports._isUint8Array = CustomStream._isUint8Array;
    module.exports.isDisturbed = CustomStream.isDisturbed;
    module.exports.isErrored = CustomStream.isErrored;
    module.exports.isReadable = CustomStream.isReadable;
    module.exports.Readable = CustomStream.Readable;
    module.exports.Writable = CustomStream.Writable;
    module.exports.Duplex = CustomStream.Duplex;
    module.exports.Transform = CustomStream.Transform;
    module.exports.PassThrough = CustomStream.PassThrough;
    module.exports.addAbortSignal = CustomStream.addAbortSignal;
    module.exports.finished = CustomStream.finished;
    module.exports.destroy = CustomStream.destroy;
    module.exports.destroy = originalDestroy;
    module.exports.pipeline = CustomStream.pipeline;
    module.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module.exports.Stream = CustomStream.Stream;
    module.exports.default = module.exports;
  }
});

// ../../node_modules/form-data/lib/browser.js
var require_browser7 = __commonJS({
  "../../node_modules/form-data/lib/browser.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    module.exports = typeof self === "object" ? self.FormData : window.FormData;
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/form-data-utils/FormDataWrapper.js
var require_FormDataWrapper = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/form-data-utils/FormDataWrapper.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebFormData = exports.Node16FormData = exports.Node18FormData = void 0;
    exports.newFormData = newFormData;
    var runtime_1 = require_runtime2();
    function isNamedValue(value) {
      return typeof value === "object" && value != null && "name" in value;
    }
    __name(isNamedValue, "isNamedValue");
    function newFormData() {
      return __awaiter11(this, void 0, void 0, function* () {
        let formdata;
        if (runtime_1.RUNTIME.type === "node" && runtime_1.RUNTIME.parsedVersion != null && runtime_1.RUNTIME.parsedVersion >= 18) {
          formdata = new Node18FormData();
        } else if (runtime_1.RUNTIME.type === "node") {
          formdata = new Node16FormData();
        } else {
          formdata = new WebFormData();
        }
        yield formdata.setup();
        return formdata;
      });
    }
    __name(newFormData, "newFormData");
    var Node18FormData = class {
      static {
        __name(this, "Node18FormData");
      }
      setup() {
        return __awaiter11(this, void 0, void 0, function* () {
          this.fd = new (yield Promise.resolve().then(() => __importStar(require_browser3()))).FormData();
        });
      }
      append(key, value) {
        var _a;
        (_a = this.fd) === null || _a === void 0 ? void 0 : _a.append(key, value);
      }
      appendFile(key, value, fileName) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b;
          if (fileName == null && isNamedValue(value)) {
            fileName = value.name;
          }
          if (value instanceof Blob) {
            (_a = this.fd) === null || _a === void 0 ? void 0 : _a.append(key, value, fileName);
          } else {
            (_b = this.fd) === null || _b === void 0 ? void 0 : _b.append(key, {
              type: void 0,
              name: fileName,
              [Symbol.toStringTag]: "File",
              stream() {
                return value;
              }
            });
          }
        });
      }
      getRequest() {
        return __awaiter11(this, void 0, void 0, function* () {
          const encoder = new (yield Promise.resolve().then(() => __importStar(require_lib2()))).FormDataEncoder(this.fd);
          return {
            body: (yield Promise.resolve().then(() => __importStar(require_browser6()))).Readable.from(encoder),
            headers: encoder.headers,
            duplex: "half"
          };
        });
      }
    };
    exports.Node18FormData = Node18FormData;
    var Node16FormData = class {
      static {
        __name(this, "Node16FormData");
      }
      setup() {
        return __awaiter11(this, void 0, void 0, function* () {
          this.fd = new (yield Promise.resolve().then(() => __importStar(require_browser7()))).default();
        });
      }
      append(key, value) {
        var _a;
        (_a = this.fd) === null || _a === void 0 ? void 0 : _a.append(key, value);
      }
      appendFile(key, value, fileName) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b;
          if (fileName == null && isNamedValue(value)) {
            fileName = value.name;
          }
          let bufferedValue;
          if (value instanceof Blob) {
            bufferedValue = Buffer.from(yield value.arrayBuffer());
          } else {
            bufferedValue = value;
          }
          if (fileName == null) {
            (_a = this.fd) === null || _a === void 0 ? void 0 : _a.append(key, bufferedValue);
          } else {
            (_b = this.fd) === null || _b === void 0 ? void 0 : _b.append(key, bufferedValue, { filename: fileName });
          }
        });
      }
      getRequest() {
        return {
          body: this.fd,
          headers: this.fd ? this.fd.getHeaders() : {}
        };
      }
    };
    exports.Node16FormData = Node16FormData;
    var WebFormData = class {
      static {
        __name(this, "WebFormData");
      }
      setup() {
        return __awaiter11(this, void 0, void 0, function* () {
          this.fd = new FormData();
        });
      }
      append(key, value) {
        var _a;
        (_a = this.fd) === null || _a === void 0 ? void 0 : _a.append(key, value);
      }
      appendFile(key, value, fileName) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a;
          if (fileName == null && isNamedValue(value)) {
            fileName = value.name;
          }
          (_a = this.fd) === null || _a === void 0 ? void 0 : _a.append(key, new Blob([value]), fileName);
        });
      }
      getRequest() {
        return {
          body: this.fd,
          headers: {}
        };
      }
    };
    exports.WebFormData = WebFormData;
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/form-data-utils/index.js
var require_form_data_utils = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/form-data-utils/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_FormDataWrapper(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/streaming-fetcher/Stream.js
var require_Stream = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/streaming-fetcher/Stream.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      __name(verb, "verb");
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
      __name(settle, "settle");
    };
    var __await = exports && exports.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      __name(awaitReturn, "awaitReturn");
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f) i[n] = f(i[n]);
        }
      }
      __name(verb, "verb");
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      __name(resume, "resume");
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      __name(step, "step");
      function fulfill(value) {
        resume("next", value);
      }
      __name(fulfill, "fulfill");
      function reject(value) {
        resume("throw", value);
      }
      __name(reject, "reject");
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
      __name(settle, "settle");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Stream = void 0;
    exports.readableStreamAsyncIterable = readableStreamAsyncIterable;
    var runtime_1 = require_runtime2();
    var DATA_PREFIX = "data:";
    var Stream = class {
      static {
        __name(this, "Stream");
      }
      constructor({ stream, parse, eventShape, signal }) {
        this.controller = new AbortController();
        this.stream = stream;
        this.parse = parse;
        if (eventShape.type === "sse") {
          this.prefix = DATA_PREFIX;
          this.messageTerminator = "\n";
          this.streamTerminator = eventShape.streamTerminator;
        } else {
          this.messageTerminator = eventShape.messageTerminator;
        }
        signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", () => this.controller.abort());
      }
      iterMessages() {
        return __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function* iterMessages_1() {
          var _a, e_1, _b, _c;
          this.controller.signal;
          const stream = readableStreamAsyncIterable(this.stream);
          let buf = "";
          let prefixSeen = false;
          try {
            for (var _d = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield __await(stream_1.next()), _a = stream_1_1.done, !_a; _d = true) {
              _c = stream_1_1.value;
              _d = false;
              const chunk = _c;
              buf += this.decodeChunk(chunk);
              let terminatorIndex;
              while ((terminatorIndex = buf.indexOf(this.messageTerminator)) >= 0) {
                let line = buf.slice(0, terminatorIndex + 1);
                buf = buf.slice(terminatorIndex + this.messageTerminator.length);
                if (!line.trim()) {
                  continue;
                }
                if (!prefixSeen && this.prefix != null) {
                  const prefixIndex = line.indexOf(this.prefix);
                  if (prefixIndex === -1) {
                    continue;
                  }
                  prefixSeen = true;
                  line = line.slice(prefixIndex + this.prefix.length);
                }
                if (this.streamTerminator != null && line.includes(this.streamTerminator)) {
                  return yield __await(void 0);
                }
                const message = yield __await(this.parse(JSON.parse(line)));
                yield yield __await(message);
                prefixSeen = false;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a && (_b = stream_1.return)) yield __await(_b.call(stream_1));
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }, "iterMessages_1"));
      }
      [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function* _a() {
          var _b, e_2, _c, _d;
          try {
            for (var _e = true, _f = __asyncValues(this.iterMessages()), _g; _g = yield __await(_f.next()), _b = _g.done, !_b; _e = true) {
              _d = _g.value;
              _e = false;
              const message = _d;
              yield yield __await(message);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (!_e && !_b && (_c = _f.return)) yield __await(_c.call(_f));
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }, "_a"));
      }
      decodeChunk(chunk) {
        let decoded = "";
        if (typeof TextDecoder !== "undefined") {
          const decoder = new TextDecoder("utf8");
          decoded += decoder.decode(chunk);
        } else if (runtime_1.RUNTIME.type === "node" && typeof chunk !== "undefined") {
          decoded += Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
        }
        return decoded;
      }
    };
    exports.Stream = Stream;
    function readableStreamAsyncIterable(stream) {
      if (stream[Symbol.asyncIterator]) {
        return stream;
      }
      const reader = stream.getReader();
      return {
        next() {
          return __awaiter11(this, void 0, void 0, function* () {
            try {
              const result = yield reader.read();
              if (result === null || result === void 0 ? void 0 : result.done) {
                reader.releaseLock();
              }
              return result;
            } catch (e) {
              reader.releaseLock();
              throw e;
            }
          });
        },
        return() {
          return __awaiter11(this, void 0, void 0, function* () {
            const cancelPromise = reader.cancel();
            reader.releaseLock();
            yield cancelPromise;
            return { done: true, value: void 0 };
          });
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    __name(readableStreamAsyncIterable, "readableStreamAsyncIterable");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/streaming-fetcher/index.js
var require_streaming_fetcher = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/streaming-fetcher/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Stream = void 0;
    var Stream_1 = require_Stream();
    Object.defineProperty(exports, "Stream", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return Stream_1.Stream;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/Schema.js
var require_Schema = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/Schema.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SchemaType = void 0;
    exports.SchemaType = {
      BIGINT: "bigint",
      DATE: "date",
      ENUM: "enum",
      LIST: "list",
      STRING_LITERAL: "stringLiteral",
      BOOLEAN_LITERAL: "booleanLiteral",
      OBJECT: "object",
      ANY: "any",
      BOOLEAN: "boolean",
      NUMBER: "number",
      STRING: "string",
      UNKNOWN: "unknown",
      RECORD: "record",
      SET: "set",
      UNION: "union",
      UNDISCRIMINATED_UNION: "undiscriminatedUnion",
      NULLABLE: "nullable",
      OPTIONAL: "optional",
      OPTIONAL_NULLABLE: "optionalNullable"
    };
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/utils/getErrorMessageForIncorrectType.js
var require_getErrorMessageForIncorrectType = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/utils/getErrorMessageForIncorrectType.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getErrorMessageForIncorrectType = getErrorMessageForIncorrectType;
    function getErrorMessageForIncorrectType(value, expectedType) {
      return `Expected ${expectedType}. Received ${getTypeAsString(value)}.`;
    }
    __name(getErrorMessageForIncorrectType, "getErrorMessageForIncorrectType");
    function getTypeAsString(value) {
      if (Array.isArray(value)) {
        return "list";
      }
      if (value === null) {
        return "null";
      }
      if (value instanceof BigInt) {
        return "BigInt";
      }
      switch (typeof value) {
        case "string":
          return `"${value}"`;
        case "bigint":
        case "number":
        case "boolean":
        case "undefined":
          return `${value}`;
      }
      return typeof value;
    }
    __name(getTypeAsString, "getTypeAsString");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/utils/maybeSkipValidation.js
var require_maybeSkipValidation = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/utils/maybeSkipValidation.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.maybeSkipValidation = maybeSkipValidation;
    function maybeSkipValidation(schema) {
      return Object.assign(Object.assign({}, schema), { json: transformAndMaybeSkipValidation(schema.json), parse: transformAndMaybeSkipValidation(schema.parse) });
    }
    __name(maybeSkipValidation, "maybeSkipValidation");
    function transformAndMaybeSkipValidation(transform) {
      return (value, opts) => {
        const transformed = transform(value, opts);
        const { skipValidation = false } = opts !== null && opts !== void 0 ? opts : {};
        if (!transformed.ok && skipValidation) {
          console.warn([
            "Failed to validate.",
            ...transformed.errors.map((error) => "  - " + (error.path.length > 0 ? `${error.path.join(".")}: ${error.message}` : error.message))
          ].join("\n"));
          return {
            ok: true,
            value
          };
        } else {
          return transformed;
        }
      };
    }
    __name(transformAndMaybeSkipValidation, "transformAndMaybeSkipValidation");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/schema-utils/stringifyValidationErrors.js
var require_stringifyValidationErrors = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/schema-utils/stringifyValidationErrors.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringifyValidationError = stringifyValidationError;
    function stringifyValidationError(error) {
      if (error.path.length === 0) {
        return error.message;
      }
      return `${error.path.join(" -> ")}: ${error.message}`;
    }
    __name(stringifyValidationError, "stringifyValidationError");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/schema-utils/JsonError.js
var require_JsonError = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/schema-utils/JsonError.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonError = void 0;
    var stringifyValidationErrors_1 = require_stringifyValidationErrors();
    var JsonError = class _JsonError extends Error {
      static {
        __name(this, "JsonError");
      }
      constructor(errors) {
        super(errors.map(stringifyValidationErrors_1.stringifyValidationError).join("; "));
        this.errors = errors;
        Object.setPrototypeOf(this, _JsonError.prototype);
      }
    };
    exports.JsonError = JsonError;
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/schema-utils/ParseError.js
var require_ParseError = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/schema-utils/ParseError.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseError = void 0;
    var stringifyValidationErrors_1 = require_stringifyValidationErrors();
    var ParseError = class _ParseError extends Error {
      static {
        __name(this, "ParseError");
      }
      constructor(errors) {
        super(errors.map(stringifyValidationErrors_1.stringifyValidationError).join("; "));
        this.errors = errors;
        Object.setPrototypeOf(this, _ParseError.prototype);
      }
    };
    exports.ParseError = ParseError;
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/schema-utils/getSchemaUtils.js
var require_getSchemaUtils = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/schema-utils/getSchemaUtils.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaUtils = getSchemaUtils;
    exports.nullable = nullable;
    exports.optional = optional;
    exports.optionalNullable = optionalNullable;
    exports.transform = transform;
    var Schema_1 = require_Schema();
    var JsonError_1 = require_JsonError();
    var ParseError_1 = require_ParseError();
    function getSchemaUtils(schema) {
      return {
        nullable: /* @__PURE__ */ __name(() => nullable(schema), "nullable"),
        optional: /* @__PURE__ */ __name(() => optional(schema), "optional"),
        optionalNullable: /* @__PURE__ */ __name(() => optionalNullable(schema), "optionalNullable"),
        transform: /* @__PURE__ */ __name((transformer) => transform(schema, transformer), "transform"),
        parseOrThrow: /* @__PURE__ */ __name((raw, opts) => {
          const parsed = schema.parse(raw, opts);
          if (parsed.ok) {
            return parsed.value;
          }
          throw new ParseError_1.ParseError(parsed.errors);
        }, "parseOrThrow"),
        jsonOrThrow: /* @__PURE__ */ __name((parsed, opts) => {
          const raw = schema.json(parsed, opts);
          if (raw.ok) {
            return raw.value;
          }
          throw new JsonError_1.JsonError(raw.errors);
        }, "jsonOrThrow")
      };
    }
    __name(getSchemaUtils, "getSchemaUtils");
    function nullable(schema) {
      const baseSchema = {
        parse: /* @__PURE__ */ __name((raw, opts) => {
          if (raw == null) {
            return {
              ok: true,
              value: null
            };
          }
          return schema.parse(raw, opts);
        }, "parse"),
        json: /* @__PURE__ */ __name((parsed, opts) => {
          if (parsed == null) {
            return {
              ok: true,
              value: null
            };
          }
          return schema.json(parsed, opts);
        }, "json"),
        getType: /* @__PURE__ */ __name(() => Schema_1.SchemaType.NULLABLE, "getType")
      };
      return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
    }
    __name(nullable, "nullable");
    function optional(schema) {
      const baseSchema = {
        parse: /* @__PURE__ */ __name((raw, opts) => {
          if (raw == null) {
            return {
              ok: true,
              value: void 0
            };
          }
          return schema.parse(raw, opts);
        }, "parse"),
        json: /* @__PURE__ */ __name((parsed, opts) => {
          if ((opts === null || opts === void 0 ? void 0 : opts.omitUndefined) && parsed === void 0) {
            return {
              ok: true,
              value: void 0
            };
          }
          if (parsed == null) {
            return {
              ok: true,
              value: null
            };
          }
          return schema.json(parsed, opts);
        }, "json"),
        getType: /* @__PURE__ */ __name(() => Schema_1.SchemaType.OPTIONAL, "getType")
      };
      return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
    }
    __name(optional, "optional");
    function optionalNullable(schema) {
      const baseSchema = {
        parse: /* @__PURE__ */ __name((raw, opts) => {
          if (raw === void 0) {
            return {
              ok: true,
              value: void 0
            };
          }
          if (raw === null) {
            return {
              ok: true,
              value: null
            };
          }
          return schema.parse(raw, opts);
        }, "parse"),
        json: /* @__PURE__ */ __name((parsed, opts) => {
          if (parsed === void 0) {
            return {
              ok: true,
              value: void 0
            };
          }
          if (parsed === null) {
            return {
              ok: true,
              value: null
            };
          }
          return schema.json(parsed, opts);
        }, "json"),
        getType: /* @__PURE__ */ __name(() => Schema_1.SchemaType.OPTIONAL_NULLABLE, "getType")
      };
      return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
    }
    __name(optionalNullable, "optionalNullable");
    function transform(schema, transformer) {
      const baseSchema = {
        parse: /* @__PURE__ */ __name((raw, opts) => {
          const parsed = schema.parse(raw, opts);
          if (!parsed.ok) {
            return parsed;
          }
          return {
            ok: true,
            value: transformer.transform(parsed.value)
          };
        }, "parse"),
        json: /* @__PURE__ */ __name((transformed, opts) => {
          const parsed = transformer.untransform(transformed);
          return schema.json(parsed, opts);
        }, "json"),
        getType: /* @__PURE__ */ __name(() => schema.getType(), "getType")
      };
      return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
    }
    __name(transform, "transform");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/schema-utils/index.js
var require_schema_utils = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/schema-utils/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseError = exports.JsonError = exports.transform = exports.optional = exports.getSchemaUtils = void 0;
    var getSchemaUtils_1 = require_getSchemaUtils();
    Object.defineProperty(exports, "getSchemaUtils", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return getSchemaUtils_1.getSchemaUtils;
    }, "get") });
    Object.defineProperty(exports, "optional", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return getSchemaUtils_1.optional;
    }, "get") });
    Object.defineProperty(exports, "transform", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return getSchemaUtils_1.transform;
    }, "get") });
    var JsonError_1 = require_JsonError();
    Object.defineProperty(exports, "JsonError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return JsonError_1.JsonError;
    }, "get") });
    var ParseError_1 = require_ParseError();
    Object.defineProperty(exports, "ParseError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ParseError_1.ParseError;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/bigint/bigint.js
var require_bigint = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/bigint/bigint.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bigint = bigint;
    var Schema_1 = require_Schema();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    var maybeSkipValidation_1 = require_maybeSkipValidation();
    var schema_utils_1 = require_schema_utils();
    function bigint() {
      const baseSchema = {
        parse: /* @__PURE__ */ __name((raw, { breadcrumbsPrefix = [] } = {}) => {
          if (typeof raw === "bigint") {
            return {
              ok: true,
              value: raw
            };
          }
          if (typeof raw === "number") {
            return {
              ok: true,
              value: BigInt(raw)
            };
          }
          return {
            ok: false,
            errors: [
              {
                path: breadcrumbsPrefix,
                message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, "bigint | number")
              }
            ]
          };
        }, "parse"),
        json: /* @__PURE__ */ __name((bigint2, { breadcrumbsPrefix = [] } = {}) => {
          if (typeof bigint2 !== "bigint") {
            return {
              ok: false,
              errors: [
                {
                  path: breadcrumbsPrefix,
                  message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(bigint2, "bigint")
                }
              ]
            };
          }
          return {
            ok: true,
            value: bigint2
          };
        }, "json"),
        getType: /* @__PURE__ */ __name(() => Schema_1.SchemaType.BIGINT, "getType")
      };
      return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
    }
    __name(bigint, "bigint");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/bigint/index.js
var require_bigint2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/bigint/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bigint = void 0;
    var bigint_1 = require_bigint();
    Object.defineProperty(exports, "bigint", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return bigint_1.bigint;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/date/date.js
var require_date = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/date/date.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.date = date;
    var Schema_1 = require_Schema();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    var maybeSkipValidation_1 = require_maybeSkipValidation();
    var schema_utils_1 = require_schema_utils();
    var ISO_8601_REGEX = /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    function date() {
      const baseSchema = {
        parse: /* @__PURE__ */ __name((raw, { breadcrumbsPrefix = [] } = {}) => {
          if (typeof raw !== "string") {
            return {
              ok: false,
              errors: [
                {
                  path: breadcrumbsPrefix,
                  message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, "string")
                }
              ]
            };
          }
          if (!ISO_8601_REGEX.test(raw)) {
            return {
              ok: false,
              errors: [
                {
                  path: breadcrumbsPrefix,
                  message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, "ISO 8601 date string")
                }
              ]
            };
          }
          return {
            ok: true,
            value: new Date(raw)
          };
        }, "parse"),
        json: /* @__PURE__ */ __name((date2, { breadcrumbsPrefix = [] } = {}) => {
          if (date2 instanceof Date) {
            return {
              ok: true,
              value: date2.toISOString()
            };
          } else {
            return {
              ok: false,
              errors: [
                {
                  path: breadcrumbsPrefix,
                  message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(date2, "Date object")
                }
              ]
            };
          }
        }, "json"),
        getType: /* @__PURE__ */ __name(() => Schema_1.SchemaType.DATE, "getType")
      };
      return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
    }
    __name(date, "date");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/date/index.js
var require_date2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/date/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.date = void 0;
    var date_1 = require_date();
    Object.defineProperty(exports, "date", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return date_1.date;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/utils/createIdentitySchemaCreator.js
var require_createIdentitySchemaCreator = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/utils/createIdentitySchemaCreator.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createIdentitySchemaCreator = createIdentitySchemaCreator;
    var schema_utils_1 = require_schema_utils();
    var maybeSkipValidation_1 = require_maybeSkipValidation();
    function createIdentitySchemaCreator(schemaType, validate) {
      return () => {
        const baseSchema = {
          parse: validate,
          json: validate,
          getType: /* @__PURE__ */ __name(() => schemaType, "getType")
        };
        return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
      };
    }
    __name(createIdentitySchemaCreator, "createIdentitySchemaCreator");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/enum/enum.js
var require_enum = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/enum/enum.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.enum_ = enum_;
    var Schema_1 = require_Schema();
    var createIdentitySchemaCreator_1 = require_createIdentitySchemaCreator();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    function enum_(values) {
      const validValues = new Set(values);
      const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.ENUM, (value, { allowUnrecognizedEnumValues, breadcrumbsPrefix = [] } = {}) => {
        if (typeof value !== "string") {
          return {
            ok: false,
            errors: [
              {
                path: breadcrumbsPrefix,
                message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "string")
              }
            ]
          };
        }
        if (!validValues.has(value) && !allowUnrecognizedEnumValues) {
          return {
            ok: false,
            errors: [
              {
                path: breadcrumbsPrefix,
                message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "enum")
              }
            ]
          };
        }
        return {
          ok: true,
          value
        };
      });
      return schemaCreator();
    }
    __name(enum_, "enum_");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/enum/index.js
var require_enum2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/enum/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.enum_ = void 0;
    var enum_1 = require_enum();
    Object.defineProperty(exports, "enum_", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return enum_1.enum_;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/lazy/lazy.js
var require_lazy = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/lazy/lazy.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lazy = lazy;
    exports.constructLazyBaseSchema = constructLazyBaseSchema;
    exports.getMemoizedSchema = getMemoizedSchema;
    var schema_utils_1 = require_schema_utils();
    function lazy(getter) {
      const baseSchema = constructLazyBaseSchema(getter);
      return Object.assign(Object.assign({}, baseSchema), (0, schema_utils_1.getSchemaUtils)(baseSchema));
    }
    __name(lazy, "lazy");
    function constructLazyBaseSchema(getter) {
      return {
        parse: /* @__PURE__ */ __name((raw, opts) => getMemoizedSchema(getter).parse(raw, opts), "parse"),
        json: /* @__PURE__ */ __name((parsed, opts) => getMemoizedSchema(getter).json(parsed, opts), "json"),
        getType: /* @__PURE__ */ __name(() => getMemoizedSchema(getter).getType(), "getType")
      };
    }
    __name(constructLazyBaseSchema, "constructLazyBaseSchema");
    function getMemoizedSchema(getter) {
      const castedGetter = getter;
      if (castedGetter.__zurg_memoized == null) {
        castedGetter.__zurg_memoized = getter();
      }
      return castedGetter.__zurg_memoized;
    }
    __name(getMemoizedSchema, "getMemoizedSchema");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/utils/entries.js
var require_entries = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/utils/entries.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.entries = entries;
    function entries(object) {
      return Object.entries(object);
    }
    __name(entries, "entries");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/utils/filterObject.js
var require_filterObject = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/utils/filterObject.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterObject = filterObject;
    function filterObject(obj, keysToInclude) {
      const keysToIncludeSet = new Set(keysToInclude);
      return Object.entries(obj).reduce((acc, [key, value]) => {
        if (keysToIncludeSet.has(key)) {
          acc[key] = value;
        }
        return acc;
      }, {});
    }
    __name(filterObject, "filterObject");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/utils/isPlainObject.js
var require_isPlainObject = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/utils/isPlainObject.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPlainObject = isPlainObject;
    function isPlainObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      if (Object.getPrototypeOf(value) === null) {
        return true;
      }
      let proto = value;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(value) === proto;
    }
    __name(isPlainObject, "isPlainObject");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/utils/keys.js
var require_keys = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/utils/keys.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keys = keys;
    function keys(object) {
      return Object.keys(object);
    }
    __name(keys, "keys");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/utils/partition.js
var require_partition = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/utils/partition.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.partition = partition;
    function partition(items, predicate) {
      const trueItems = [], falseItems = [];
      for (const item of items) {
        if (predicate(item)) {
          trueItems.push(item);
        } else {
          falseItems.push(item);
        }
      }
      return [trueItems, falseItems];
    }
    __name(partition, "partition");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/object-like/getObjectLikeUtils.js
var require_getObjectLikeUtils = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/object-like/getObjectLikeUtils.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getObjectLikeUtils = getObjectLikeUtils;
    exports.withParsedProperties = withParsedProperties;
    var filterObject_1 = require_filterObject();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    var isPlainObject_1 = require_isPlainObject();
    var schema_utils_1 = require_schema_utils();
    function getObjectLikeUtils(schema) {
      return {
        withParsedProperties: /* @__PURE__ */ __name((properties) => withParsedProperties(schema, properties), "withParsedProperties")
      };
    }
    __name(getObjectLikeUtils, "getObjectLikeUtils");
    function withParsedProperties(objectLike, properties) {
      const objectSchema = {
        parse: /* @__PURE__ */ __name((raw, opts) => {
          const parsedObject = objectLike.parse(raw, opts);
          if (!parsedObject.ok) {
            return parsedObject;
          }
          const additionalProperties = Object.entries(properties).reduce((processed, [key, value]) => {
            return Object.assign(Object.assign({}, processed), { [key]: typeof value === "function" ? value(parsedObject.value) : value });
          }, {});
          return {
            ok: true,
            value: Object.assign(Object.assign({}, parsedObject.value), additionalProperties)
          };
        }, "parse"),
        json: /* @__PURE__ */ __name((parsed, opts) => {
          var _a;
          if (!(0, isPlainObject_1.isPlainObject)(parsed)) {
            return {
              ok: false,
              errors: [
                {
                  path: (_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                  message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(parsed, "object")
                }
              ]
            };
          }
          const addedPropertyKeys = new Set(Object.keys(properties));
          const parsedWithoutAddedProperties = (0, filterObject_1.filterObject)(parsed, Object.keys(parsed).filter((key) => !addedPropertyKeys.has(key)));
          return objectLike.json(parsedWithoutAddedProperties, opts);
        }, "json"),
        getType: /* @__PURE__ */ __name(() => objectLike.getType(), "getType")
      };
      return Object.assign(Object.assign(Object.assign({}, objectSchema), (0, schema_utils_1.getSchemaUtils)(objectSchema)), getObjectLikeUtils(objectSchema));
    }
    __name(withParsedProperties, "withParsedProperties");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/object-like/index.js
var require_object_like = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/object-like/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withParsedProperties = exports.getObjectLikeUtils = void 0;
    var getObjectLikeUtils_1 = require_getObjectLikeUtils();
    Object.defineProperty(exports, "getObjectLikeUtils", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return getObjectLikeUtils_1.getObjectLikeUtils;
    }, "get") });
    Object.defineProperty(exports, "withParsedProperties", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return getObjectLikeUtils_1.withParsedProperties;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/object/property.js
var require_property = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/object/property.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.property = property;
    exports.isProperty = isProperty;
    function property(rawKey, valueSchema) {
      return {
        rawKey,
        valueSchema,
        isProperty: true
      };
    }
    __name(property, "property");
    function isProperty(maybeProperty) {
      return maybeProperty.isProperty;
    }
    __name(isProperty, "isProperty");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/object/object.js
var require_object = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/object/object.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.object = object;
    exports.getObjectUtils = getObjectUtils;
    var Schema_1 = require_Schema();
    var entries_1 = require_entries();
    var filterObject_1 = require_filterObject();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    var isPlainObject_1 = require_isPlainObject();
    var keys_1 = require_keys();
    var maybeSkipValidation_1 = require_maybeSkipValidation();
    var partition_1 = require_partition();
    var object_like_1 = require_object_like();
    var schema_utils_1 = require_schema_utils();
    var property_1 = require_property();
    function object(schemas) {
      const baseSchema = {
        _getRawProperties: /* @__PURE__ */ __name(() => Object.entries(schemas).map(([parsedKey, propertySchema]) => (0, property_1.isProperty)(propertySchema) ? propertySchema.rawKey : parsedKey), "_getRawProperties"),
        _getParsedProperties: /* @__PURE__ */ __name(() => (0, keys_1.keys)(schemas), "_getParsedProperties"),
        parse: /* @__PURE__ */ __name((raw, opts) => {
          const rawKeyToProperty = {};
          const requiredKeys = [];
          for (const [parsedKey, schemaOrObjectProperty] of (0, entries_1.entries)(schemas)) {
            const rawKey = (0, property_1.isProperty)(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
            const valueSchema = (0, property_1.isProperty)(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty;
            const property = {
              rawKey,
              parsedKey,
              valueSchema
            };
            rawKeyToProperty[rawKey] = property;
            if (isSchemaRequired(valueSchema)) {
              requiredKeys.push(rawKey);
            }
          }
          return validateAndTransformObject({
            value: raw,
            requiredKeys,
            getProperty: /* @__PURE__ */ __name((rawKey) => {
              const property = rawKeyToProperty[rawKey];
              if (property == null) {
                return void 0;
              }
              return {
                transformedKey: property.parsedKey,
                transform: /* @__PURE__ */ __name((propertyValue) => {
                  var _a;
                  return property.valueSchema.parse(propertyValue, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [], rawKey] }));
                }, "transform")
              };
            }, "getProperty"),
            unrecognizedObjectKeys: opts === null || opts === void 0 ? void 0 : opts.unrecognizedObjectKeys,
            skipValidation: opts === null || opts === void 0 ? void 0 : opts.skipValidation,
            breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix,
            omitUndefined: opts === null || opts === void 0 ? void 0 : opts.omitUndefined
          });
        }, "parse"),
        json: /* @__PURE__ */ __name((parsed, opts) => {
          const requiredKeys = [];
          for (const [parsedKey, schemaOrObjectProperty] of (0, entries_1.entries)(schemas)) {
            const valueSchema = (0, property_1.isProperty)(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty;
            if (isSchemaRequired(valueSchema)) {
              requiredKeys.push(parsedKey);
            }
          }
          return validateAndTransformObject({
            value: parsed,
            requiredKeys,
            getProperty: /* @__PURE__ */ __name((parsedKey) => {
              const property = schemas[parsedKey];
              if (property == null) {
                return void 0;
              }
              if ((0, property_1.isProperty)(property)) {
                return {
                  transformedKey: property.rawKey,
                  transform: /* @__PURE__ */ __name((propertyValue) => {
                    var _a;
                    return property.valueSchema.json(propertyValue, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [], parsedKey] }));
                  }, "transform")
                };
              } else {
                return {
                  transformedKey: parsedKey,
                  transform: /* @__PURE__ */ __name((propertyValue) => {
                    var _a;
                    return property.json(propertyValue, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [], parsedKey] }));
                  }, "transform")
                };
              }
            }, "getProperty"),
            unrecognizedObjectKeys: opts === null || opts === void 0 ? void 0 : opts.unrecognizedObjectKeys,
            skipValidation: opts === null || opts === void 0 ? void 0 : opts.skipValidation,
            breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix,
            omitUndefined: opts === null || opts === void 0 ? void 0 : opts.omitUndefined
          });
        }, "json"),
        getType: /* @__PURE__ */ __name(() => Schema_1.SchemaType.OBJECT, "getType")
      };
      return Object.assign(Object.assign(Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema)), getObjectUtils(baseSchema));
    }
    __name(object, "object");
    function validateAndTransformObject({ value, requiredKeys, getProperty, unrecognizedObjectKeys = "fail", skipValidation = false, breadcrumbsPrefix = [] }) {
      if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
          ok: false,
          errors: [
            {
              path: breadcrumbsPrefix,
              message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "object")
            }
          ]
        };
      }
      const missingRequiredKeys = new Set(requiredKeys);
      const errors = [];
      const transformed = {};
      for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)) {
        const property = getProperty(preTransformedKey);
        if (property != null) {
          missingRequiredKeys.delete(preTransformedKey);
          const value2 = property.transform(preTransformedItemValue);
          if (value2.ok) {
            transformed[property.transformedKey] = value2.value;
          } else {
            transformed[preTransformedKey] = preTransformedItemValue;
            errors.push(...value2.errors);
          }
        } else {
          switch (unrecognizedObjectKeys) {
            case "fail":
              errors.push({
                path: [...breadcrumbsPrefix, preTransformedKey],
                message: `Unexpected key "${preTransformedKey}"`
              });
              break;
            case "strip":
              break;
            case "passthrough":
              transformed[preTransformedKey] = preTransformedItemValue;
              break;
          }
        }
      }
      errors.push(...requiredKeys.filter((key) => missingRequiredKeys.has(key)).map((key) => ({
        path: breadcrumbsPrefix,
        message: `Missing required key "${key}"`
      })));
      if (errors.length === 0 || skipValidation) {
        return {
          ok: true,
          value: transformed
        };
      } else {
        return {
          ok: false,
          errors
        };
      }
    }
    __name(validateAndTransformObject, "validateAndTransformObject");
    function getObjectUtils(schema) {
      return {
        extend: /* @__PURE__ */ __name((extension) => {
          const baseSchema = {
            _getParsedProperties: /* @__PURE__ */ __name(() => [...schema._getParsedProperties(), ...extension._getParsedProperties()], "_getParsedProperties"),
            _getRawProperties: /* @__PURE__ */ __name(() => [...schema._getRawProperties(), ...extension._getRawProperties()], "_getRawProperties"),
            parse: /* @__PURE__ */ __name((raw, opts) => {
              return validateAndTransformExtendedObject({
                extensionKeys: extension._getRawProperties(),
                value: raw,
                transformBase: /* @__PURE__ */ __name((rawBase) => schema.parse(rawBase, opts), "transformBase"),
                transformExtension: /* @__PURE__ */ __name((rawExtension) => extension.parse(rawExtension, opts), "transformExtension")
              });
            }, "parse"),
            json: /* @__PURE__ */ __name((parsed, opts) => {
              return validateAndTransformExtendedObject({
                extensionKeys: extension._getParsedProperties(),
                value: parsed,
                transformBase: /* @__PURE__ */ __name((parsedBase) => schema.json(parsedBase, opts), "transformBase"),
                transformExtension: /* @__PURE__ */ __name((parsedExtension) => extension.json(parsedExtension, opts), "transformExtension")
              });
            }, "json"),
            getType: /* @__PURE__ */ __name(() => Schema_1.SchemaType.OBJECT, "getType")
          };
          return Object.assign(Object.assign(Object.assign(Object.assign({}, baseSchema), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema)), getObjectUtils(baseSchema));
        }, "extend"),
        passthrough: /* @__PURE__ */ __name(() => {
          const baseSchema = {
            _getParsedProperties: /* @__PURE__ */ __name(() => schema._getParsedProperties(), "_getParsedProperties"),
            _getRawProperties: /* @__PURE__ */ __name(() => schema._getRawProperties(), "_getRawProperties"),
            parse: /* @__PURE__ */ __name((raw, opts) => {
              const transformed = schema.parse(raw, Object.assign(Object.assign({}, opts), { unrecognizedObjectKeys: "passthrough" }));
              if (!transformed.ok) {
                return transformed;
              }
              return {
                ok: true,
                value: Object.assign(Object.assign({}, raw), transformed.value)
              };
            }, "parse"),
            json: /* @__PURE__ */ __name((parsed, opts) => {
              const transformed = schema.json(parsed, Object.assign(Object.assign({}, opts), { unrecognizedObjectKeys: "passthrough" }));
              if (!transformed.ok) {
                return transformed;
              }
              return {
                ok: true,
                value: Object.assign(Object.assign({}, parsed), transformed.value)
              };
            }, "json"),
            getType: /* @__PURE__ */ __name(() => Schema_1.SchemaType.OBJECT, "getType")
          };
          return Object.assign(Object.assign(Object.assign(Object.assign({}, baseSchema), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema)), getObjectUtils(baseSchema));
        }, "passthrough")
      };
    }
    __name(getObjectUtils, "getObjectUtils");
    function validateAndTransformExtendedObject({ extensionKeys, value, transformBase, transformExtension }) {
      const extensionPropertiesSet = new Set(extensionKeys);
      const [extensionProperties, baseProperties] = (0, partition_1.partition)((0, keys_1.keys)(value), (key) => extensionPropertiesSet.has(key));
      const transformedBase = transformBase((0, filterObject_1.filterObject)(value, baseProperties));
      const transformedExtension = transformExtension((0, filterObject_1.filterObject)(value, extensionProperties));
      if (transformedBase.ok && transformedExtension.ok) {
        return {
          ok: true,
          value: Object.assign(Object.assign({}, transformedBase.value), transformedExtension.value)
        };
      } else {
        return {
          ok: false,
          errors: [
            ...transformedBase.ok ? [] : transformedBase.errors,
            ...transformedExtension.ok ? [] : transformedExtension.errors
          ]
        };
      }
    }
    __name(validateAndTransformExtendedObject, "validateAndTransformExtendedObject");
    function isSchemaRequired(schema) {
      return !isSchemaOptional(schema);
    }
    __name(isSchemaRequired, "isSchemaRequired");
    function isSchemaOptional(schema) {
      switch (schema.getType()) {
        case Schema_1.SchemaType.ANY:
        case Schema_1.SchemaType.UNKNOWN:
        case Schema_1.SchemaType.OPTIONAL:
        case Schema_1.SchemaType.OPTIONAL_NULLABLE:
          return true;
        default:
          return false;
      }
    }
    __name(isSchemaOptional, "isSchemaOptional");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/object/objectWithoutOptionalProperties.js
var require_objectWithoutOptionalProperties = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/object/objectWithoutOptionalProperties.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objectWithoutOptionalProperties = objectWithoutOptionalProperties;
    var object_1 = require_object();
    function objectWithoutOptionalProperties(schemas) {
      return (0, object_1.object)(schemas);
    }
    __name(objectWithoutOptionalProperties, "objectWithoutOptionalProperties");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/object/index.js
var require_object2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/object/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.property = exports.isProperty = exports.objectWithoutOptionalProperties = exports.object = exports.getObjectUtils = void 0;
    var object_1 = require_object();
    Object.defineProperty(exports, "getObjectUtils", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return object_1.getObjectUtils;
    }, "get") });
    Object.defineProperty(exports, "object", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return object_1.object;
    }, "get") });
    var objectWithoutOptionalProperties_1 = require_objectWithoutOptionalProperties();
    Object.defineProperty(exports, "objectWithoutOptionalProperties", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return objectWithoutOptionalProperties_1.objectWithoutOptionalProperties;
    }, "get") });
    var property_1 = require_property();
    Object.defineProperty(exports, "isProperty", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return property_1.isProperty;
    }, "get") });
    Object.defineProperty(exports, "property", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return property_1.property;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/lazy/lazyObject.js
var require_lazyObject = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/lazy/lazyObject.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lazyObject = lazyObject;
    var object_1 = require_object2();
    var object_like_1 = require_object_like();
    var schema_utils_1 = require_schema_utils();
    var lazy_1 = require_lazy();
    function lazyObject(getter) {
      const baseSchema = Object.assign(Object.assign({}, (0, lazy_1.constructLazyBaseSchema)(getter)), { _getRawProperties: /* @__PURE__ */ __name(() => (0, lazy_1.getMemoizedSchema)(getter)._getRawProperties(), "_getRawProperties"), _getParsedProperties: /* @__PURE__ */ __name(() => (0, lazy_1.getMemoizedSchema)(getter)._getParsedProperties(), "_getParsedProperties") });
      return Object.assign(Object.assign(Object.assign(Object.assign({}, baseSchema), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema)), (0, object_1.getObjectUtils)(baseSchema));
    }
    __name(lazyObject, "lazyObject");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/lazy/index.js
var require_lazy2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/lazy/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lazyObject = exports.lazy = void 0;
    var lazy_1 = require_lazy();
    Object.defineProperty(exports, "lazy", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return lazy_1.lazy;
    }, "get") });
    var lazyObject_1 = require_lazyObject();
    Object.defineProperty(exports, "lazyObject", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return lazyObject_1.lazyObject;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/list/list.js
var require_list = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/list/list.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.list = list;
    var Schema_1 = require_Schema();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    var maybeSkipValidation_1 = require_maybeSkipValidation();
    var schema_utils_1 = require_schema_utils();
    function list(schema) {
      const baseSchema = {
        parse: /* @__PURE__ */ __name((raw, opts) => validateAndTransformArray(raw, (item, index) => {
          var _a;
          return schema.parse(item, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [], `[${index}]`] }));
        }), "parse"),
        json: /* @__PURE__ */ __name((parsed, opts) => validateAndTransformArray(parsed, (item, index) => {
          var _a;
          return schema.json(item, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [], `[${index}]`] }));
        }), "json"),
        getType: /* @__PURE__ */ __name(() => Schema_1.SchemaType.LIST, "getType")
      };
      return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
    }
    __name(list, "list");
    function validateAndTransformArray(value, transformItem) {
      if (!Array.isArray(value)) {
        return {
          ok: false,
          errors: [
            {
              message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "list"),
              path: []
            }
          ]
        };
      }
      const maybeValidItems = value.map((item, index) => transformItem(item, index));
      return maybeValidItems.reduce((acc, item) => {
        if (acc.ok && item.ok) {
          return {
            ok: true,
            value: [...acc.value, item.value]
          };
        }
        const errors = [];
        if (!acc.ok) {
          errors.push(...acc.errors);
        }
        if (!item.ok) {
          errors.push(...item.errors);
        }
        return {
          ok: false,
          errors
        };
      }, { ok: true, value: [] });
    }
    __name(validateAndTransformArray, "validateAndTransformArray");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/list/index.js
var require_list2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/list/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.list = void 0;
    var list_1 = require_list();
    Object.defineProperty(exports, "list", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return list_1.list;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/literals/stringLiteral.js
var require_stringLiteral = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/literals/stringLiteral.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringLiteral = stringLiteral;
    var Schema_1 = require_Schema();
    var createIdentitySchemaCreator_1 = require_createIdentitySchemaCreator();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    function stringLiteral(literal) {
      const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.STRING_LITERAL, (value, { breadcrumbsPrefix = [] } = {}) => {
        if (value === literal) {
          return {
            ok: true,
            value: literal
          };
        } else {
          return {
            ok: false,
            errors: [
              {
                path: breadcrumbsPrefix,
                message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, `"${literal}"`)
              }
            ]
          };
        }
      });
      return schemaCreator();
    }
    __name(stringLiteral, "stringLiteral");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/literals/booleanLiteral.js
var require_booleanLiteral = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/literals/booleanLiteral.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.booleanLiteral = booleanLiteral;
    var Schema_1 = require_Schema();
    var createIdentitySchemaCreator_1 = require_createIdentitySchemaCreator();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    function booleanLiteral(literal) {
      const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.BOOLEAN_LITERAL, (value, { breadcrumbsPrefix = [] } = {}) => {
        if (value === literal) {
          return {
            ok: true,
            value: literal
          };
        } else {
          return {
            ok: false,
            errors: [
              {
                path: breadcrumbsPrefix,
                message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, `${literal.toString()}`)
              }
            ]
          };
        }
      });
      return schemaCreator();
    }
    __name(booleanLiteral, "booleanLiteral");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/literals/index.js
var require_literals = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/literals/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.booleanLiteral = exports.stringLiteral = void 0;
    var stringLiteral_1 = require_stringLiteral();
    Object.defineProperty(exports, "stringLiteral", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return stringLiteral_1.stringLiteral;
    }, "get") });
    var booleanLiteral_1 = require_booleanLiteral();
    Object.defineProperty(exports, "booleanLiteral", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return booleanLiteral_1.booleanLiteral;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/primitives/any.js
var require_any = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/primitives/any.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.any = void 0;
    var Schema_1 = require_Schema();
    var createIdentitySchemaCreator_1 = require_createIdentitySchemaCreator();
    exports.any = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.ANY, (value) => ({ ok: true, value }));
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/primitives/boolean.js
var require_boolean = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/primitives/boolean.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolean = void 0;
    var Schema_1 = require_Schema();
    var createIdentitySchemaCreator_1 = require_createIdentitySchemaCreator();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    exports.boolean = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.BOOLEAN, (value, { breadcrumbsPrefix = [] } = {}) => {
      if (typeof value === "boolean") {
        return {
          ok: true,
          value
        };
      } else {
        return {
          ok: false,
          errors: [
            {
              path: breadcrumbsPrefix,
              message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "boolean")
            }
          ]
        };
      }
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/primitives/number.js
var require_number = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/primitives/number.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.number = void 0;
    var Schema_1 = require_Schema();
    var createIdentitySchemaCreator_1 = require_createIdentitySchemaCreator();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    exports.number = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.NUMBER, (value, { breadcrumbsPrefix = [] } = {}) => {
      if (typeof value === "number") {
        return {
          ok: true,
          value
        };
      } else {
        return {
          ok: false,
          errors: [
            {
              path: breadcrumbsPrefix,
              message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "number")
            }
          ]
        };
      }
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/primitives/string.js
var require_string = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/primitives/string.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.string = void 0;
    var Schema_1 = require_Schema();
    var createIdentitySchemaCreator_1 = require_createIdentitySchemaCreator();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    exports.string = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.STRING, (value, { breadcrumbsPrefix = [] } = {}) => {
      if (typeof value === "string") {
        return {
          ok: true,
          value
        };
      } else {
        return {
          ok: false,
          errors: [
            {
              path: breadcrumbsPrefix,
              message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "string")
            }
          ]
        };
      }
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/primitives/unknown.js
var require_unknown = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/primitives/unknown.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unknown = void 0;
    var Schema_1 = require_Schema();
    var createIdentitySchemaCreator_1 = require_createIdentitySchemaCreator();
    exports.unknown = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.UNKNOWN, (value) => ({ ok: true, value }));
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/primitives/index.js
var require_primitives = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/primitives/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unknown = exports.string = exports.number = exports.boolean = exports.any = void 0;
    var any_1 = require_any();
    Object.defineProperty(exports, "any", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return any_1.any;
    }, "get") });
    var boolean_1 = require_boolean();
    Object.defineProperty(exports, "boolean", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return boolean_1.boolean;
    }, "get") });
    var number_1 = require_number();
    Object.defineProperty(exports, "number", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return number_1.number;
    }, "get") });
    var string_1 = require_string();
    Object.defineProperty(exports, "string", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return string_1.string;
    }, "get") });
    var unknown_1 = require_unknown();
    Object.defineProperty(exports, "unknown", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return unknown_1.unknown;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/record/record.js
var require_record = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/record/record.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.record = record;
    var Schema_1 = require_Schema();
    var entries_1 = require_entries();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    var isPlainObject_1 = require_isPlainObject();
    var maybeSkipValidation_1 = require_maybeSkipValidation();
    var schema_utils_1 = require_schema_utils();
    function record(keySchema, valueSchema) {
      const baseSchema = {
        parse: /* @__PURE__ */ __name((raw, opts) => {
          return validateAndTransformRecord({
            value: raw,
            isKeyNumeric: keySchema.getType() === Schema_1.SchemaType.NUMBER,
            transformKey: /* @__PURE__ */ __name((key) => {
              var _a;
              return keySchema.parse(key, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [], `${key} (key)`] }));
            }, "transformKey"),
            transformValue: /* @__PURE__ */ __name((value, key) => {
              var _a;
              return valueSchema.parse(value, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [], `${key}`] }));
            }, "transformValue"),
            breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix
          });
        }, "parse"),
        json: /* @__PURE__ */ __name((parsed, opts) => {
          return validateAndTransformRecord({
            value: parsed,
            isKeyNumeric: keySchema.getType() === Schema_1.SchemaType.NUMBER,
            transformKey: /* @__PURE__ */ __name((key) => {
              var _a;
              return keySchema.json(key, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [], `${key} (key)`] }));
            }, "transformKey"),
            transformValue: /* @__PURE__ */ __name((value, key) => {
              var _a;
              return valueSchema.json(value, Object.assign(Object.assign({}, opts), { breadcrumbsPrefix: [...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [], `${key}`] }));
            }, "transformValue"),
            breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix
          });
        }, "json"),
        getType: /* @__PURE__ */ __name(() => Schema_1.SchemaType.RECORD, "getType")
      };
      return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
    }
    __name(record, "record");
    function validateAndTransformRecord({ value, isKeyNumeric, transformKey, transformValue, breadcrumbsPrefix = [] }) {
      if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
          ok: false,
          errors: [
            {
              path: breadcrumbsPrefix,
              message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "object")
            }
          ]
        };
      }
      return (0, entries_1.entries)(value).reduce((accPromise, [stringKey, value2]) => {
        if (value2 === void 0) {
          return accPromise;
        }
        const acc = accPromise;
        let key = stringKey;
        if (isKeyNumeric) {
          const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
          if (!isNaN(numberKey)) {
            key = numberKey;
          }
        }
        const transformedKey = transformKey(key);
        const transformedValue = transformValue(value2, key);
        if (acc.ok && transformedKey.ok && transformedValue.ok) {
          return {
            ok: true,
            value: Object.assign(Object.assign({}, acc.value), { [transformedKey.value]: transformedValue.value })
          };
        }
        const errors = [];
        if (!acc.ok) {
          errors.push(...acc.errors);
        }
        if (!transformedKey.ok) {
          errors.push(...transformedKey.errors);
        }
        if (!transformedValue.ok) {
          errors.push(...transformedValue.errors);
        }
        return {
          ok: false,
          errors
        };
      }, { ok: true, value: {} });
    }
    __name(validateAndTransformRecord, "validateAndTransformRecord");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/record/index.js
var require_record2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/record/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.record = void 0;
    var record_1 = require_record();
    Object.defineProperty(exports, "record", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return record_1.record;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/set/set.js
var require_set = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/set/set.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.set = set;
    var Schema_1 = require_Schema();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    var maybeSkipValidation_1 = require_maybeSkipValidation();
    var list_1 = require_list2();
    var schema_utils_1 = require_schema_utils();
    function set(schema) {
      const listSchema = (0, list_1.list)(schema);
      const baseSchema = {
        parse: /* @__PURE__ */ __name((raw, opts) => {
          const parsedList = listSchema.parse(raw, opts);
          if (parsedList.ok) {
            return {
              ok: true,
              value: new Set(parsedList.value)
            };
          } else {
            return parsedList;
          }
        }, "parse"),
        json: /* @__PURE__ */ __name((parsed, opts) => {
          var _a;
          if (!(parsed instanceof Set)) {
            return {
              ok: false,
              errors: [
                {
                  path: (_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                  message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(parsed, "Set")
                }
              ]
            };
          }
          const jsonList = listSchema.json([...parsed], opts);
          return jsonList;
        }, "json"),
        getType: /* @__PURE__ */ __name(() => Schema_1.SchemaType.SET, "getType")
      };
      return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
    }
    __name(set, "set");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/set/index.js
var require_set2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/set/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.set = void 0;
    var set_1 = require_set();
    Object.defineProperty(exports, "set", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return set_1.set;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/undiscriminated-union/undiscriminatedUnion.js
var require_undiscriminatedUnion = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/undiscriminated-union/undiscriminatedUnion.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.undiscriminatedUnion = undiscriminatedUnion;
    var Schema_1 = require_Schema();
    var maybeSkipValidation_1 = require_maybeSkipValidation();
    var schema_utils_1 = require_schema_utils();
    function undiscriminatedUnion(schemas) {
      const baseSchema = {
        parse: /* @__PURE__ */ __name((raw, opts) => {
          return validateAndTransformUndiscriminatedUnion((schema, opts2) => schema.parse(raw, opts2), schemas, opts);
        }, "parse"),
        json: /* @__PURE__ */ __name((parsed, opts) => {
          return validateAndTransformUndiscriminatedUnion((schema, opts2) => schema.json(parsed, opts2), schemas, opts);
        }, "json"),
        getType: /* @__PURE__ */ __name(() => Schema_1.SchemaType.UNDISCRIMINATED_UNION, "getType")
      };
      return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
    }
    __name(undiscriminatedUnion, "undiscriminatedUnion");
    function validateAndTransformUndiscriminatedUnion(transform, schemas, opts) {
      const errors = [];
      for (const [index, schema] of schemas.entries()) {
        const transformed = transform(schema, Object.assign(Object.assign({}, opts), { skipValidation: false }));
        if (transformed.ok) {
          return transformed;
        } else {
          for (const error of transformed.errors) {
            errors.push({
              path: error.path,
              message: `[Variant ${index}] ${error.message}`
            });
          }
        }
      }
      return {
        ok: false,
        errors
      };
    }
    __name(validateAndTransformUndiscriminatedUnion, "validateAndTransformUndiscriminatedUnion");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/undiscriminated-union/index.js
var require_undiscriminated_union = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/undiscriminated-union/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.undiscriminatedUnion = void 0;
    var undiscriminatedUnion_1 = require_undiscriminatedUnion();
    Object.defineProperty(exports, "undiscriminatedUnion", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return undiscriminatedUnion_1.undiscriminatedUnion;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/union/discriminant.js
var require_discriminant = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/union/discriminant.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.discriminant = discriminant;
    function discriminant(parsedDiscriminant, rawDiscriminant) {
      return {
        parsedDiscriminant,
        rawDiscriminant
      };
    }
    __name(discriminant, "discriminant");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/union/union.js
var require_union = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/union/union.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.union = union;
    var Schema_1 = require_Schema();
    var getErrorMessageForIncorrectType_1 = require_getErrorMessageForIncorrectType();
    var isPlainObject_1 = require_isPlainObject();
    var keys_1 = require_keys();
    var maybeSkipValidation_1 = require_maybeSkipValidation();
    var enum_1 = require_enum2();
    var object_like_1 = require_object_like();
    var schema_utils_1 = require_schema_utils();
    function union(discriminant, union2) {
      const rawDiscriminant = typeof discriminant === "string" ? discriminant : discriminant.rawDiscriminant;
      const parsedDiscriminant = typeof discriminant === "string" ? discriminant : discriminant.parsedDiscriminant;
      const discriminantValueSchema = (0, enum_1.enum_)((0, keys_1.keys)(union2));
      const baseSchema = {
        parse: /* @__PURE__ */ __name((raw, opts) => {
          return transformAndValidateUnion({
            value: raw,
            discriminant: rawDiscriminant,
            transformedDiscriminant: parsedDiscriminant,
            transformDiscriminantValue: /* @__PURE__ */ __name((discriminantValue) => {
              var _a;
              return discriminantValueSchema.parse(discriminantValue, {
                allowUnrecognizedEnumValues: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                breadcrumbsPrefix: [...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [], rawDiscriminant]
              });
            }, "transformDiscriminantValue"),
            getAdditionalPropertiesSchema: /* @__PURE__ */ __name((discriminantValue) => union2[discriminantValue], "getAdditionalPropertiesSchema"),
            allowUnrecognizedUnionMembers: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
            transformAdditionalProperties: /* @__PURE__ */ __name((additionalProperties, additionalPropertiesSchema) => additionalPropertiesSchema.parse(additionalProperties, opts), "transformAdditionalProperties"),
            breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix
          });
        }, "parse"),
        json: /* @__PURE__ */ __name((parsed, opts) => {
          return transformAndValidateUnion({
            value: parsed,
            discriminant: parsedDiscriminant,
            transformedDiscriminant: rawDiscriminant,
            transformDiscriminantValue: /* @__PURE__ */ __name((discriminantValue) => {
              var _a;
              return discriminantValueSchema.json(discriminantValue, {
                allowUnrecognizedEnumValues: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                breadcrumbsPrefix: [...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [], parsedDiscriminant]
              });
            }, "transformDiscriminantValue"),
            getAdditionalPropertiesSchema: /* @__PURE__ */ __name((discriminantValue) => union2[discriminantValue], "getAdditionalPropertiesSchema"),
            allowUnrecognizedUnionMembers: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
            transformAdditionalProperties: /* @__PURE__ */ __name((additionalProperties, additionalPropertiesSchema) => additionalPropertiesSchema.json(additionalProperties, opts), "transformAdditionalProperties"),
            breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix
          });
        }, "json"),
        getType: /* @__PURE__ */ __name(() => Schema_1.SchemaType.UNION, "getType")
      };
      return Object.assign(Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema));
    }
    __name(union, "union");
    function transformAndValidateUnion({ value, discriminant, transformedDiscriminant, transformDiscriminantValue, getAdditionalPropertiesSchema, allowUnrecognizedUnionMembers = false, transformAdditionalProperties, breadcrumbsPrefix = [] }) {
      if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
          ok: false,
          errors: [
            {
              path: breadcrumbsPrefix,
              message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "object")
            }
          ]
        };
      }
      const _a = value, _b = discriminant, discriminantValue = _a[_b], additionalProperties = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
      if (discriminantValue == null) {
        return {
          ok: false,
          errors: [
            {
              path: breadcrumbsPrefix,
              message: `Missing discriminant ("${discriminant}")`
            }
          ]
        };
      }
      const transformedDiscriminantValue = transformDiscriminantValue(discriminantValue);
      if (!transformedDiscriminantValue.ok) {
        return {
          ok: false,
          errors: transformedDiscriminantValue.errors
        };
      }
      const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);
      if (additionalPropertiesSchema == null) {
        if (allowUnrecognizedUnionMembers) {
          return {
            ok: true,
            value: Object.assign({ [transformedDiscriminant]: transformedDiscriminantValue.value }, additionalProperties)
          };
        } else {
          return {
            ok: false,
            errors: [
              {
                path: [...breadcrumbsPrefix, discriminant],
                message: "Unexpected discriminant value"
              }
            ]
          };
        }
      }
      const transformedAdditionalProperties = transformAdditionalProperties(additionalProperties, additionalPropertiesSchema);
      if (!transformedAdditionalProperties.ok) {
        return transformedAdditionalProperties;
      }
      return {
        ok: true,
        value: Object.assign({ [transformedDiscriminant]: discriminantValue }, transformedAdditionalProperties.value)
      };
    }
    __name(transformAndValidateUnion, "transformAndValidateUnion");
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/union/index.js
var require_union2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/union/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.union = exports.discriminant = void 0;
    var discriminant_1 = require_discriminant();
    Object.defineProperty(exports, "discriminant", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return discriminant_1.discriminant;
    }, "get") });
    var union_1 = require_union();
    Object.defineProperty(exports, "union", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return union_1.union;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/builders/index.js
var require_builders = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/builders/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_bigint2(), exports);
    __exportStar(require_date2(), exports);
    __exportStar(require_enum2(), exports);
    __exportStar(require_lazy2(), exports);
    __exportStar(require_list2(), exports);
    __exportStar(require_literals(), exports);
    __exportStar(require_object2(), exports);
    __exportStar(require_object_like(), exports);
    __exportStar(require_primitives(), exports);
    __exportStar(require_record2(), exports);
    __exportStar(require_schema_utils(), exports);
    __exportStar(require_set2(), exports);
    __exportStar(require_undiscriminated_union(), exports);
    __exportStar(require_union2(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/schemas/index.js
var require_schemas = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/schemas/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_builders(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/index.js
var require_core = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serialization = void 0;
    __exportStar(require_fetcher(), exports);
    __exportStar(require_runtime2(), exports);
    __exportStar(require_form_data_utils(), exports);
    __exportStar(require_streaming_fetcher(), exports);
    exports.serialization = __importStar(require_schemas());
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/apiStatus/types/ApiInfo.js
var require_ApiInfo2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/apiStatus/types/ApiInfo.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ApiInfo = void 0;
    var core = __importStar(require_core());
    exports.ApiInfo = core.serialization.object({
      ok: core.serialization.boolean(),
      version: core.serialization.string()
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/apiStatus/types/index.js
var require_types8 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/apiStatus/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ApiInfo2(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/apiStatus/index.js
var require_apiStatus2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/apiStatus/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types8(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/auth/types/TokenGrant.js
var require_TokenGrant2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/auth/types/TokenGrant.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenGrant = void 0;
    var core = __importStar(require_core());
    exports.TokenGrant = core.serialization.object({
      tts: core.serialization.boolean().optional(),
      stt: core.serialization.boolean().optional()
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/auth/types/TokenRequest.js
var require_TokenRequest2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/auth/types/TokenRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenRequest = void 0;
    var core = __importStar(require_core());
    var TokenGrant_1 = require_TokenGrant2();
    exports.TokenRequest = core.serialization.object({
      grants: TokenGrant_1.TokenGrant.optional(),
      expiresIn: core.serialization.property("expires_in", core.serialization.number().optional())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/auth/types/TokenResponse.js
var require_TokenResponse2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/auth/types/TokenResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenResponse = void 0;
    var core = __importStar(require_core());
    exports.TokenResponse = core.serialization.object({
      token: core.serialization.string()
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/auth/types/index.js
var require_types9 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/auth/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_TokenGrant2(), exports);
    __exportStar(require_TokenRequest2(), exports);
    __exportStar(require_TokenResponse2(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/auth/index.js
var require_auth2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/auth/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types9(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/embedding/types/Embedding.js
var require_Embedding2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/embedding/types/Embedding.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Embedding = void 0;
    var core = __importStar(require_core());
    exports.Embedding = core.serialization.list(core.serialization.number());
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/embedding/types/index.js
var require_types10 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/embedding/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_Embedding2(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/embedding/index.js
var require_embedding2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/embedding/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types10(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/TimestampGranularity.js
var require_TimestampGranularity2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/TimestampGranularity.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimestampGranularity = void 0;
    var core = __importStar(require_core());
    exports.TimestampGranularity = core.serialization.enum_(["word"]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/TranscriptionWord.js
var require_TranscriptionWord2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/TranscriptionWord.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TranscriptionWord = void 0;
    var core = __importStar(require_core());
    exports.TranscriptionWord = core.serialization.object({
      word: core.serialization.string(),
      start: core.serialization.number(),
      end: core.serialization.number()
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/TranscriptionResponse.js
var require_TranscriptionResponse2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/TranscriptionResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TranscriptionResponse = void 0;
    var core = __importStar(require_core());
    var TranscriptionWord_1 = require_TranscriptionWord2();
    exports.TranscriptionResponse = core.serialization.object({
      text: core.serialization.string(),
      language: core.serialization.string().optional(),
      duration: core.serialization.number().optional(),
      words: core.serialization.list(TranscriptionWord_1.TranscriptionWord).optional()
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/TranscriptMessage.js
var require_TranscriptMessage2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/TranscriptMessage.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TranscriptMessage = void 0;
    var core = __importStar(require_core());
    var TranscriptionWord_1 = require_TranscriptionWord2();
    exports.TranscriptMessage = core.serialization.object({
      requestId: core.serialization.property("request_id", core.serialization.string()),
      text: core.serialization.string(),
      isFinal: core.serialization.property("is_final", core.serialization.boolean()),
      duration: core.serialization.number().optional(),
      language: core.serialization.string().optional(),
      words: core.serialization.list(TranscriptionWord_1.TranscriptionWord).optional()
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/FlushDoneMessage.js
var require_FlushDoneMessage2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/FlushDoneMessage.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FlushDoneMessage = void 0;
    var core = __importStar(require_core());
    exports.FlushDoneMessage = core.serialization.object({
      requestId: core.serialization.property("request_id", core.serialization.string())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/DoneMessage.js
var require_DoneMessage2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/DoneMessage.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DoneMessage = void 0;
    var core = __importStar(require_core());
    exports.DoneMessage = core.serialization.object({
      requestId: core.serialization.property("request_id", core.serialization.string())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/ErrorMessage.js
var require_ErrorMessage2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/ErrorMessage.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorMessage = void 0;
    var core = __importStar(require_core());
    exports.ErrorMessage = core.serialization.object({
      requestId: core.serialization.property("request_id", core.serialization.string().optional()),
      message: core.serialization.string()
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/StreamingTranscriptionResponse.js
var require_StreamingTranscriptionResponse2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/StreamingTranscriptionResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingTranscriptionResponse = void 0;
    var core = __importStar(require_core());
    var TranscriptMessage_1 = require_TranscriptMessage2();
    var FlushDoneMessage_1 = require_FlushDoneMessage2();
    var DoneMessage_1 = require_DoneMessage2();
    var ErrorMessage_1 = require_ErrorMessage2();
    exports.StreamingTranscriptionResponse = core.serialization.union("type", {
      transcript: TranscriptMessage_1.TranscriptMessage,
      flush_done: FlushDoneMessage_1.FlushDoneMessage,
      done: DoneMessage_1.DoneMessage,
      error: ErrorMessage_1.ErrorMessage
    }).transform({
      transform: /* @__PURE__ */ __name((value) => value, "transform"),
      untransform: /* @__PURE__ */ __name((value) => value, "untransform")
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/SttEncoding.js
var require_SttEncoding2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/SttEncoding.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SttEncoding = void 0;
    var core = __importStar(require_core());
    exports.SttEncoding = core.serialization.enum_(["pcm_s16le", "pcm_s32le", "pcm_f16le", "pcm_f32le", "pcm_mulaw", "pcm_alaw"]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/index.js
var require_types11 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_TimestampGranularity2(), exports);
    __exportStar(require_TranscriptionWord2(), exports);
    __exportStar(require_TranscriptionResponse2(), exports);
    __exportStar(require_StreamingTranscriptionResponse2(), exports);
    __exportStar(require_TranscriptMessage2(), exports);
    __exportStar(require_FlushDoneMessage2(), exports);
    __exportStar(require_DoneMessage2(), exports);
    __exportStar(require_ErrorMessage2(), exports);
    __exportStar(require_SttEncoding2(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/index.js
var require_stt2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/stt/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types11(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/ContextId.js
var require_ContextId2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/ContextId.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextId = void 0;
    var core = __importStar(require_core());
    exports.ContextId = core.serialization.string();
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/FlushId.js
var require_FlushId2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/FlushId.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FlushId = void 0;
    var core = __importStar(require_core());
    exports.FlushId = core.serialization.number();
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/ModelSpeed.js
var require_ModelSpeed2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/ModelSpeed.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModelSpeed = void 0;
    var core = __importStar(require_core());
    exports.ModelSpeed = core.serialization.enum_(["slow", "normal", "fast"]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketBaseResponse.js
var require_WebSocketBaseResponse2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketBaseResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketBaseResponse = void 0;
    var core = __importStar(require_core());
    var ContextId_1 = require_ContextId2();
    exports.WebSocketBaseResponse = core.serialization.object({
      contextId: core.serialization.property("context_id", ContextId_1.ContextId.optional()),
      statusCode: core.serialization.property("status_code", core.serialization.number()),
      done: core.serialization.boolean()
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketChunkResponse.js
var require_WebSocketChunkResponse2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketChunkResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketChunkResponse = void 0;
    var core = __importStar(require_core());
    var WebSocketBaseResponse_1 = require_WebSocketBaseResponse2();
    exports.WebSocketChunkResponse = core.serialization.object({
      data: core.serialization.string(),
      stepTime: core.serialization.property("step_time", core.serialization.number())
    }).extend(WebSocketBaseResponse_1.WebSocketBaseResponse);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketFlushDoneResponse.js
var require_WebSocketFlushDoneResponse2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketFlushDoneResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketFlushDoneResponse = void 0;
    var core = __importStar(require_core());
    var FlushId_1 = require_FlushId2();
    var WebSocketBaseResponse_1 = require_WebSocketBaseResponse2();
    exports.WebSocketFlushDoneResponse = core.serialization.object({
      flushId: core.serialization.property("flush_id", FlushId_1.FlushId),
      flushDone: core.serialization.property("flush_done", core.serialization.boolean())
    }).extend(WebSocketBaseResponse_1.WebSocketBaseResponse);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketDoneResponse.js
var require_WebSocketDoneResponse2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketDoneResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketDoneResponse = void 0;
    var core = __importStar(require_core());
    var WebSocketBaseResponse_1 = require_WebSocketBaseResponse2();
    exports.WebSocketDoneResponse = core.serialization.object({}).extend(WebSocketBaseResponse_1.WebSocketBaseResponse);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WordTimestamps.js
var require_WordTimestamps2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WordTimestamps.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WordTimestamps = void 0;
    var core = __importStar(require_core());
    exports.WordTimestamps = core.serialization.object({
      words: core.serialization.list(core.serialization.string()),
      start: core.serialization.list(core.serialization.number()),
      end: core.serialization.list(core.serialization.number())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketTimestampsResponse.js
var require_WebSocketTimestampsResponse2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketTimestampsResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketTimestampsResponse = void 0;
    var core = __importStar(require_core());
    var WordTimestamps_1 = require_WordTimestamps2();
    var WebSocketBaseResponse_1 = require_WebSocketBaseResponse2();
    exports.WebSocketTimestampsResponse = core.serialization.object({
      wordTimestamps: core.serialization.property("word_timestamps", WordTimestamps_1.WordTimestamps.optional())
    }).extend(WebSocketBaseResponse_1.WebSocketBaseResponse);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketErrorResponse.js
var require_WebSocketErrorResponse2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketErrorResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketErrorResponse = void 0;
    var core = __importStar(require_core());
    var WebSocketBaseResponse_1 = require_WebSocketBaseResponse2();
    exports.WebSocketErrorResponse = core.serialization.object({
      error: core.serialization.string()
    }).extend(WebSocketBaseResponse_1.WebSocketBaseResponse);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/PhonemeTimestamps.js
var require_PhonemeTimestamps2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/PhonemeTimestamps.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PhonemeTimestamps = void 0;
    var core = __importStar(require_core());
    exports.PhonemeTimestamps = core.serialization.object({
      phonemes: core.serialization.list(core.serialization.string()),
      start: core.serialization.list(core.serialization.number()),
      end: core.serialization.list(core.serialization.number())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketPhonemeTimestampsResponse.js
var require_WebSocketPhonemeTimestampsResponse2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketPhonemeTimestampsResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketPhonemeTimestampsResponse = void 0;
    var core = __importStar(require_core());
    var PhonemeTimestamps_1 = require_PhonemeTimestamps2();
    var WebSocketBaseResponse_1 = require_WebSocketBaseResponse2();
    exports.WebSocketPhonemeTimestampsResponse = core.serialization.object({
      phonemeTimestamps: core.serialization.property("phoneme_timestamps", PhonemeTimestamps_1.PhonemeTimestamps.optional())
    }).extend(WebSocketBaseResponse_1.WebSocketBaseResponse);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketResponse.js
var require_WebSocketResponse2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketResponse = void 0;
    var core = __importStar(require_core());
    var WebSocketChunkResponse_1 = require_WebSocketChunkResponse2();
    var WebSocketFlushDoneResponse_1 = require_WebSocketFlushDoneResponse2();
    var WebSocketDoneResponse_1 = require_WebSocketDoneResponse2();
    var WebSocketTimestampsResponse_1 = require_WebSocketTimestampsResponse2();
    var WebSocketErrorResponse_1 = require_WebSocketErrorResponse2();
    var WebSocketPhonemeTimestampsResponse_1 = require_WebSocketPhonemeTimestampsResponse2();
    exports.WebSocketResponse = core.serialization.union("type", {
      chunk: WebSocketChunkResponse_1.WebSocketChunkResponse,
      flush_done: WebSocketFlushDoneResponse_1.WebSocketFlushDoneResponse,
      done: WebSocketDoneResponse_1.WebSocketDoneResponse,
      timestamps: WebSocketTimestampsResponse_1.WebSocketTimestampsResponse,
      error: WebSocketErrorResponse_1.WebSocketErrorResponse,
      phoneme_timestamps: WebSocketPhonemeTimestampsResponse_1.WebSocketPhonemeTimestampsResponse
    }).transform({
      transform: /* @__PURE__ */ __name((value) => value, "transform"),
      untransform: /* @__PURE__ */ __name((value) => value, "untransform")
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketTtsOutput.js
var require_WebSocketTtsOutput2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketTtsOutput.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketTtsOutput = void 0;
    var core = __importStar(require_core());
    var WordTimestamps_1 = require_WordTimestamps2();
    var PhonemeTimestamps_1 = require_PhonemeTimestamps2();
    var ContextId_1 = require_ContextId2();
    var FlushId_1 = require_FlushId2();
    exports.WebSocketTtsOutput = core.serialization.object({
      wordTimestamps: core.serialization.property("word_timestamps", WordTimestamps_1.WordTimestamps.optional()),
      phonemeTimestamps: core.serialization.property("phoneme_timestamps", PhonemeTimestamps_1.PhonemeTimestamps.optional()),
      audio: core.serialization.unknown().optional(),
      contextId: core.serialization.property("context_id", ContextId_1.ContextId.optional()),
      flushId: core.serialization.property("flush_id", FlushId_1.FlushId.optional()),
      flushDone: core.serialization.property("flush_done", core.serialization.boolean().optional())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketStreamOptions.js
var require_WebSocketStreamOptions2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketStreamOptions.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketStreamOptions = void 0;
    var core = __importStar(require_core());
    exports.WebSocketStreamOptions = core.serialization.object({
      timeout: core.serialization.number().optional()
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/CancelContextRequest.js
var require_CancelContextRequest2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/CancelContextRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancelContextRequest = void 0;
    var core = __importStar(require_core());
    var ContextId_1 = require_ContextId2();
    exports.CancelContextRequest = core.serialization.object({
      contextId: core.serialization.property("context_id", ContextId_1.ContextId),
      cancel: core.serialization.booleanLiteral(true)
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/VoiceId.js
var require_VoiceId2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/VoiceId.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoiceId = void 0;
    var core = __importStar(require_core());
    exports.VoiceId = core.serialization.string();
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/NumericalSpecifier.js
var require_NumericalSpecifier2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/NumericalSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumericalSpecifier = void 0;
    var core = __importStar(require_core());
    exports.NumericalSpecifier = core.serialization.number();
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/NaturalSpecifier.js
var require_NaturalSpecifier2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/NaturalSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NaturalSpecifier = void 0;
    var core = __importStar(require_core());
    exports.NaturalSpecifier = core.serialization.enum_(["slowest", "slow", "normal", "fast", "fastest"]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/Speed.js
var require_Speed2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/Speed.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Speed = void 0;
    var core = __importStar(require_core());
    var NumericalSpecifier_1 = require_NumericalSpecifier2();
    var NaturalSpecifier_1 = require_NaturalSpecifier2();
    exports.Speed = core.serialization.undiscriminatedUnion([NumericalSpecifier_1.NumericalSpecifier, NaturalSpecifier_1.NaturalSpecifier]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/EmotionDeprecated.js
var require_EmotionDeprecated2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/EmotionDeprecated.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmotionDeprecated = void 0;
    var core = __importStar(require_core());
    exports.EmotionDeprecated = core.serialization.enum_([
      "anger:lowest",
      "anger:low",
      "anger",
      "anger:high",
      "anger:highest",
      "positivity:lowest",
      "positivity:low",
      "positivity",
      "positivity:high",
      "positivity:highest",
      "surprise:lowest",
      "surprise:low",
      "surprise",
      "surprise:high",
      "surprise:highest",
      "sadness:lowest",
      "sadness:low",
      "sadness",
      "sadness:high",
      "sadness:highest",
      "curiosity:lowest",
      "curiosity:low",
      "curiosity",
      "curiosity:high",
      "curiosity:highest"
    ]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/Controls.js
var require_Controls2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/Controls.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Controls = void 0;
    var core = __importStar(require_core());
    var Speed_1 = require_Speed2();
    var EmotionDeprecated_1 = require_EmotionDeprecated2();
    exports.Controls = core.serialization.object({
      speed: Speed_1.Speed,
      emotion: core.serialization.list(EmotionDeprecated_1.EmotionDeprecated)
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/TtsRequestIdSpecifier.js
var require_TtsRequestIdSpecifier2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/TtsRequestIdSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TtsRequestIdSpecifier = void 0;
    var core = __importStar(require_core());
    var VoiceId_1 = require_VoiceId2();
    var Controls_1 = require_Controls2();
    exports.TtsRequestIdSpecifier = core.serialization.object({
      mode: core.serialization.stringLiteral("id"),
      id: VoiceId_1.VoiceId,
      experimentalControls: core.serialization.property("__experimental_controls", Controls_1.Controls.optional())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/TtsRequestEmbeddingSpecifier.js
var require_TtsRequestEmbeddingSpecifier2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/TtsRequestEmbeddingSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TtsRequestEmbeddingSpecifier = void 0;
    var core = __importStar(require_core());
    var Embedding_1 = require_Embedding2();
    var Controls_1 = require_Controls2();
    exports.TtsRequestEmbeddingSpecifier = core.serialization.object({
      mode: core.serialization.stringLiteral("embedding"),
      embedding: Embedding_1.Embedding,
      experimentalControls: core.serialization.property("__experimental_controls", Controls_1.Controls.optional())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/TtsRequestVoiceSpecifier.js
var require_TtsRequestVoiceSpecifier2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/TtsRequestVoiceSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TtsRequestVoiceSpecifier = void 0;
    var core = __importStar(require_core());
    var TtsRequestIdSpecifier_1 = require_TtsRequestIdSpecifier2();
    var TtsRequestEmbeddingSpecifier_1 = require_TtsRequestEmbeddingSpecifier2();
    exports.TtsRequestVoiceSpecifier = core.serialization.undiscriminatedUnion([TtsRequestIdSpecifier_1.TtsRequestIdSpecifier, TtsRequestEmbeddingSpecifier_1.TtsRequestEmbeddingSpecifier]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/SupportedLanguage.js
var require_SupportedLanguage2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/SupportedLanguage.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupportedLanguage = void 0;
    var core = __importStar(require_core());
    exports.SupportedLanguage = core.serialization.enum_([
      "en",
      "fr",
      "de",
      "es",
      "pt",
      "zh",
      "ja",
      "hi",
      "it",
      "ko",
      "nl",
      "pl",
      "ru",
      "sv",
      "tr"
    ]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/RawEncoding.js
var require_RawEncoding2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/RawEncoding.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RawEncoding = void 0;
    var core = __importStar(require_core());
    exports.RawEncoding = core.serialization.enum_(["pcm_f32le", "pcm_s16le", "pcm_mulaw", "pcm_alaw"]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketRawOutputFormat.js
var require_WebSocketRawOutputFormat2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketRawOutputFormat.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketRawOutputFormat = void 0;
    var core = __importStar(require_core());
    var RawEncoding_1 = require_RawEncoding2();
    exports.WebSocketRawOutputFormat = core.serialization.object({
      container: core.serialization.stringLiteral("raw"),
      encoding: RawEncoding_1.RawEncoding,
      sampleRate: core.serialization.property("sample_rate", core.serialization.number())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/Emotion.js
var require_Emotion2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/Emotion.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Emotion = void 0;
    var core = __importStar(require_core());
    exports.Emotion = core.serialization.string();
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/GenerationConfig.js
var require_GenerationConfig2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/GenerationConfig.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GenerationConfig = void 0;
    var core = __importStar(require_core());
    var Emotion_1 = require_Emotion2();
    exports.GenerationConfig = core.serialization.object({
      volume: core.serialization.number().optional(),
      speed: core.serialization.number().optional(),
      emotion: Emotion_1.Emotion.optional()
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/GenerationRequest.js
var require_GenerationRequest2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/GenerationRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GenerationRequest = void 0;
    var core = __importStar(require_core());
    var TtsRequestVoiceSpecifier_1 = require_TtsRequestVoiceSpecifier2();
    var SupportedLanguage_1 = require_SupportedLanguage2();
    var WebSocketRawOutputFormat_1 = require_WebSocketRawOutputFormat2();
    var GenerationConfig_1 = require_GenerationConfig2();
    var ModelSpeed_1 = require_ModelSpeed2();
    var ContextId_1 = require_ContextId2();
    exports.GenerationRequest = core.serialization.object({
      modelId: core.serialization.property("model_id", core.serialization.string()),
      transcript: core.serialization.unknown(),
      voice: TtsRequestVoiceSpecifier_1.TtsRequestVoiceSpecifier,
      language: SupportedLanguage_1.SupportedLanguage.optional(),
      outputFormat: core.serialization.property("output_format", WebSocketRawOutputFormat_1.WebSocketRawOutputFormat),
      generationConfig: core.serialization.property("generation_config", GenerationConfig_1.GenerationConfig.optional()),
      duration: core.serialization.number().optional(),
      speed: ModelSpeed_1.ModelSpeed.optional(),
      contextId: core.serialization.property("context_id", ContextId_1.ContextId.optional()),
      continue: core.serialization.boolean().optional(),
      maxBufferDelayMs: core.serialization.property("max_buffer_delay_ms", core.serialization.number().optional()),
      flush: core.serialization.boolean().optional(),
      addTimestamps: core.serialization.property("add_timestamps", core.serialization.boolean().optional()),
      addPhonemeTimestamps: core.serialization.property("add_phoneme_timestamps", core.serialization.boolean().optional()),
      useNormalizedTimestamps: core.serialization.property("use_normalized_timestamps", core.serialization.boolean().optional()),
      pronunciationDictId: core.serialization.property("pronunciation_dict_id", core.serialization.string().optional())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketRequest.js
var require_WebSocketRequest2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketRequest = void 0;
    var core = __importStar(require_core());
    var GenerationRequest_1 = require_GenerationRequest2();
    var CancelContextRequest_1 = require_CancelContextRequest2();
    exports.WebSocketRequest = core.serialization.undiscriminatedUnion([GenerationRequest_1.GenerationRequest, CancelContextRequest_1.CancelContextRequest]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/RawOutputFormat.js
var require_RawOutputFormat2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/RawOutputFormat.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RawOutputFormat = void 0;
    var core = __importStar(require_core());
    var RawEncoding_1 = require_RawEncoding2();
    exports.RawOutputFormat = core.serialization.object({
      encoding: RawEncoding_1.RawEncoding,
      sampleRate: core.serialization.property("sample_rate", core.serialization.number()),
      bitRate: core.serialization.property("bit_rate", core.serialization.number().optional())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WavOutputFormat.js
var require_WavOutputFormat2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WavOutputFormat.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WavOutputFormat = void 0;
    var core = __importStar(require_core());
    var RawOutputFormat_1 = require_RawOutputFormat2();
    exports.WavOutputFormat = core.serialization.object({}).extend(RawOutputFormat_1.RawOutputFormat);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/Mp3OutputFormat.js
var require_Mp3OutputFormat2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/Mp3OutputFormat.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Mp3OutputFormat = void 0;
    var core = __importStar(require_core());
    exports.Mp3OutputFormat = core.serialization.object({
      sampleRate: core.serialization.property("sample_rate", core.serialization.number()),
      bitRate: core.serialization.property("bit_rate", core.serialization.number())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/OutputFormat.js
var require_OutputFormat2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/OutputFormat.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutputFormat = void 0;
    var core = __importStar(require_core());
    var RawOutputFormat_1 = require_RawOutputFormat2();
    var WavOutputFormat_1 = require_WavOutputFormat2();
    var Mp3OutputFormat_1 = require_Mp3OutputFormat2();
    exports.OutputFormat = core.serialization.union("container", {
      raw: RawOutputFormat_1.RawOutputFormat,
      wav: WavOutputFormat_1.WavOutputFormat,
      mp3: Mp3OutputFormat_1.Mp3OutputFormat
    }).transform({
      transform: /* @__PURE__ */ __name((value) => value, "transform"),
      untransform: /* @__PURE__ */ __name((value) => value, "untransform")
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketTtsRequest.js
var require_WebSocketTtsRequest2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/WebSocketTtsRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketTtsRequest = void 0;
    var core = __importStar(require_core());
    var OutputFormat_1 = require_OutputFormat2();
    var GenerationConfig_1 = require_GenerationConfig2();
    var TtsRequestVoiceSpecifier_1 = require_TtsRequestVoiceSpecifier2();
    var ModelSpeed_1 = require_ModelSpeed2();
    exports.WebSocketTtsRequest = core.serialization.object({
      modelId: core.serialization.property("model_id", core.serialization.string()),
      outputFormat: core.serialization.property("output_format", OutputFormat_1.OutputFormat.optional()),
      generationConfig: core.serialization.property("generation_config", GenerationConfig_1.GenerationConfig.optional()),
      transcript: core.serialization.string().optional(),
      voice: TtsRequestVoiceSpecifier_1.TtsRequestVoiceSpecifier,
      duration: core.serialization.number().optional(),
      language: core.serialization.string().optional(),
      addTimestamps: core.serialization.property("add_timestamps", core.serialization.boolean().optional()),
      addPhonemeTimestamps: core.serialization.property("add_phoneme_timestamps", core.serialization.boolean().optional()),
      useNormalizedTimestamps: core.serialization.property("use_normalized_timestamps", core.serialization.boolean().optional()),
      continue: core.serialization.boolean().optional(),
      contextId: core.serialization.property("context_id", core.serialization.string().optional()),
      maxBufferDelayMs: core.serialization.property("max_buffer_delay_ms", core.serialization.number().optional()),
      speed: ModelSpeed_1.ModelSpeed.optional(),
      pronunciationDictId: core.serialization.property("pronunciation_dict_id", core.serialization.string().optional())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/TtsRequest.js
var require_TtsRequest2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/TtsRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TtsRequest = void 0;
    var core = __importStar(require_core());
    var TtsRequestVoiceSpecifier_1 = require_TtsRequestVoiceSpecifier2();
    var SupportedLanguage_1 = require_SupportedLanguage2();
    var OutputFormat_1 = require_OutputFormat2();
    var GenerationConfig_1 = require_GenerationConfig2();
    var ModelSpeed_1 = require_ModelSpeed2();
    exports.TtsRequest = core.serialization.object({
      modelId: core.serialization.property("model_id", core.serialization.string()),
      transcript: core.serialization.string(),
      voice: TtsRequestVoiceSpecifier_1.TtsRequestVoiceSpecifier,
      language: SupportedLanguage_1.SupportedLanguage.optional(),
      outputFormat: core.serialization.property("output_format", OutputFormat_1.OutputFormat),
      generationConfig: core.serialization.property("generation_config", GenerationConfig_1.GenerationConfig.optional()),
      duration: core.serialization.number().optional(),
      speed: ModelSpeed_1.ModelSpeed.optional(),
      pronunciationDictId: core.serialization.property("pronunciation_dict_id", core.serialization.string().optional())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/SseOutputFormat.js
var require_SseOutputFormat2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/SseOutputFormat.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SseOutputFormat = void 0;
    var core = __importStar(require_core());
    var RawEncoding_1 = require_RawEncoding2();
    exports.SseOutputFormat = core.serialization.object({
      container: core.serialization.stringLiteral("raw"),
      encoding: RawEncoding_1.RawEncoding,
      sampleRate: core.serialization.property("sample_rate", core.serialization.number())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/TtssseRequest.js
var require_TtssseRequest2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/TtssseRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TtssseRequest = void 0;
    var core = __importStar(require_core());
    var TtsRequestVoiceSpecifier_1 = require_TtsRequestVoiceSpecifier2();
    var SupportedLanguage_1 = require_SupportedLanguage2();
    var SseOutputFormat_1 = require_SseOutputFormat2();
    var GenerationConfig_1 = require_GenerationConfig2();
    var ModelSpeed_1 = require_ModelSpeed2();
    var ContextId_1 = require_ContextId2();
    exports.TtssseRequest = core.serialization.object({
      modelId: core.serialization.property("model_id", core.serialization.string()),
      transcript: core.serialization.string(),
      voice: TtsRequestVoiceSpecifier_1.TtsRequestVoiceSpecifier,
      language: SupportedLanguage_1.SupportedLanguage.optional(),
      outputFormat: core.serialization.property("output_format", SseOutputFormat_1.SseOutputFormat),
      generationConfig: core.serialization.property("generation_config", GenerationConfig_1.GenerationConfig.optional()),
      duration: core.serialization.number().optional(),
      speed: ModelSpeed_1.ModelSpeed.optional(),
      addTimestamps: core.serialization.property("add_timestamps", core.serialization.boolean().optional()),
      addPhonemeTimestamps: core.serialization.property("add_phoneme_timestamps", core.serialization.boolean().optional()),
      useNormalizedTimestamps: core.serialization.property("use_normalized_timestamps", core.serialization.boolean().optional()),
      contextId: core.serialization.property("context_id", ContextId_1.ContextId.optional()),
      pronunciationDictId: core.serialization.property("pronunciation_dict_id", core.serialization.string().optional())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/index.js
var require_types12 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ContextId2(), exports);
    __exportStar(require_FlushId2(), exports);
    __exportStar(require_ModelSpeed2(), exports);
    __exportStar(require_WebSocketBaseResponse2(), exports);
    __exportStar(require_WebSocketResponse2(), exports);
    __exportStar(require_WebSocketErrorResponse2(), exports);
    __exportStar(require_WebSocketChunkResponse2(), exports);
    __exportStar(require_WebSocketTimestampsResponse2(), exports);
    __exportStar(require_WebSocketPhonemeTimestampsResponse2(), exports);
    __exportStar(require_WebSocketTtsOutput2(), exports);
    __exportStar(require_WebSocketStreamOptions2(), exports);
    __exportStar(require_WordTimestamps2(), exports);
    __exportStar(require_PhonemeTimestamps2(), exports);
    __exportStar(require_WebSocketDoneResponse2(), exports);
    __exportStar(require_WebSocketFlushDoneResponse2(), exports);
    __exportStar(require_CancelContextRequest2(), exports);
    __exportStar(require_GenerationRequest2(), exports);
    __exportStar(require_WebSocketRawOutputFormat2(), exports);
    __exportStar(require_WebSocketRequest2(), exports);
    __exportStar(require_WebSocketTtsRequest2(), exports);
    __exportStar(require_TtsRequest2(), exports);
    __exportStar(require_TtssseRequest2(), exports);
    __exportStar(require_SupportedLanguage2(), exports);
    __exportStar(require_GenerationConfig2(), exports);
    __exportStar(require_Emotion2(), exports);
    __exportStar(require_OutputFormat2(), exports);
    __exportStar(require_RawOutputFormat2(), exports);
    __exportStar(require_SseOutputFormat2(), exports);
    __exportStar(require_RawEncoding2(), exports);
    __exportStar(require_WavOutputFormat2(), exports);
    __exportStar(require_Mp3OutputFormat2(), exports);
    __exportStar(require_TtsRequestVoiceSpecifier2(), exports);
    __exportStar(require_TtsRequestIdSpecifier2(), exports);
    __exportStar(require_TtsRequestEmbeddingSpecifier2(), exports);
    __exportStar(require_Controls2(), exports);
    __exportStar(require_Speed2(), exports);
    __exportStar(require_NumericalSpecifier2(), exports);
    __exportStar(require_NaturalSpecifier2(), exports);
    __exportStar(require_EmotionDeprecated2(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/index.js
var require_tts2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/tts/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types12(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voiceChanger/types/OutputFormatContainer.js
var require_OutputFormatContainer2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voiceChanger/types/OutputFormatContainer.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OutputFormatContainer = void 0;
    var core = __importStar(require_core());
    exports.OutputFormatContainer = core.serialization.enum_(["raw", "wav", "mp3"]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voiceChanger/types/StreamingResponse.js
var require_StreamingResponse2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voiceChanger/types/StreamingResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingResponse = void 0;
    var core = __importStar(require_core());
    var WebSocketChunkResponse_1 = require_WebSocketChunkResponse2();
    var WebSocketDoneResponse_1 = require_WebSocketDoneResponse2();
    var WebSocketErrorResponse_1 = require_WebSocketErrorResponse2();
    exports.StreamingResponse = core.serialization.union("type", {
      chunk: WebSocketChunkResponse_1.WebSocketChunkResponse,
      done: WebSocketDoneResponse_1.WebSocketDoneResponse,
      error: WebSocketErrorResponse_1.WebSocketErrorResponse
    }).transform({
      transform: /* @__PURE__ */ __name((value) => value, "transform"),
      untransform: /* @__PURE__ */ __name((value) => value, "untransform")
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voiceChanger/types/index.js
var require_types13 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voiceChanger/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_OutputFormatContainer2(), exports);
    __exportStar(require_StreamingResponse2(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voiceChanger/index.js
var require_voiceChanger2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voiceChanger/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types13(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/BaseVoiceId.js
var require_BaseVoiceId2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/BaseVoiceId.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseVoiceId = void 0;
    var VoiceId_1 = require_VoiceId2();
    exports.BaseVoiceId = VoiceId_1.VoiceId;
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/Voice.js
var require_Voice2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/Voice.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Voice = void 0;
    var core = __importStar(require_core());
    var VoiceId_1 = require_VoiceId2();
    var Embedding_1 = require_Embedding2();
    var SupportedLanguage_1 = require_SupportedLanguage2();
    exports.Voice = core.serialization.object({
      id: VoiceId_1.VoiceId,
      userId: core.serialization.property("user_id", core.serialization.string().optional()),
      isPublic: core.serialization.property("is_public", core.serialization.boolean()),
      name: core.serialization.string(),
      description: core.serialization.string(),
      createdAt: core.serialization.property("created_at", core.serialization.date()),
      embedding: Embedding_1.Embedding,
      language: SupportedLanguage_1.SupportedLanguage
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/VoiceMetadata.js
var require_VoiceMetadata2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/VoiceMetadata.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoiceMetadata = void 0;
    var core = __importStar(require_core());
    var VoiceId_1 = require_VoiceId2();
    var SupportedLanguage_1 = require_SupportedLanguage2();
    exports.VoiceMetadata = core.serialization.object({
      id: VoiceId_1.VoiceId,
      userId: core.serialization.property("user_id", core.serialization.string()),
      isPublic: core.serialization.property("is_public", core.serialization.boolean()),
      name: core.serialization.string(),
      description: core.serialization.string(),
      createdAt: core.serialization.property("created_at", core.serialization.date()),
      language: SupportedLanguage_1.SupportedLanguage
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/CreateVoiceRequest.js
var require_CreateVoiceRequest2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/CreateVoiceRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateVoiceRequest = void 0;
    var core = __importStar(require_core());
    var Embedding_1 = require_Embedding2();
    var SupportedLanguage_1 = require_SupportedLanguage2();
    var BaseVoiceId_1 = require_BaseVoiceId2();
    exports.CreateVoiceRequest = core.serialization.object({
      name: core.serialization.string(),
      description: core.serialization.string(),
      embedding: Embedding_1.Embedding,
      language: SupportedLanguage_1.SupportedLanguage.optional(),
      baseVoiceId: core.serialization.property("base_voice_id", BaseVoiceId_1.BaseVoiceId.optional())
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/UpdateVoiceRequest.js
var require_UpdateVoiceRequest2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/UpdateVoiceRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateVoiceRequest = void 0;
    var core = __importStar(require_core());
    exports.UpdateVoiceRequest = core.serialization.object({
      name: core.serialization.string(),
      description: core.serialization.string()
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizeTargetLanguage.js
var require_LocalizeTargetLanguage2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizeTargetLanguage.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizeTargetLanguage = void 0;
    var core = __importStar(require_core());
    exports.LocalizeTargetLanguage = core.serialization.enum_([
      "en",
      "de",
      "es",
      "fr",
      "ja",
      "pt",
      "zh",
      "hi",
      "it",
      "ko",
      "nl",
      "pl",
      "ru",
      "sv",
      "tr"
    ]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizeEnglishDialect.js
var require_LocalizeEnglishDialect2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizeEnglishDialect.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizeEnglishDialect = void 0;
    var core = __importStar(require_core());
    exports.LocalizeEnglishDialect = core.serialization.enum_(["au", "in", "so", "uk", "us"]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizeFrenchDialect.js
var require_LocalizeFrenchDialect2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizeFrenchDialect.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizeFrenchDialect = void 0;
    var core = __importStar(require_core());
    exports.LocalizeFrenchDialect = core.serialization.enum_(["eu", "ca"]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizeSpanishDialect.js
var require_LocalizeSpanishDialect2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizeSpanishDialect.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizeSpanishDialect = void 0;
    var core = __importStar(require_core());
    exports.LocalizeSpanishDialect = core.serialization.enum_(["mx", "pe"]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizePortugueseDialect.js
var require_LocalizePortugueseDialect2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizePortugueseDialect.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizePortugueseDialect = void 0;
    var core = __importStar(require_core());
    exports.LocalizePortugueseDialect = core.serialization.enum_(["br", "eu"]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizeDialect.js
var require_LocalizeDialect2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizeDialect.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizeDialect = void 0;
    var core = __importStar(require_core());
    var LocalizeEnglishDialect_1 = require_LocalizeEnglishDialect2();
    var LocalizeSpanishDialect_1 = require_LocalizeSpanishDialect2();
    var LocalizePortugueseDialect_1 = require_LocalizePortugueseDialect2();
    var LocalizeFrenchDialect_1 = require_LocalizeFrenchDialect2();
    exports.LocalizeDialect = core.serialization.undiscriminatedUnion([
      LocalizeEnglishDialect_1.LocalizeEnglishDialect,
      LocalizeSpanishDialect_1.LocalizeSpanishDialect,
      LocalizePortugueseDialect_1.LocalizePortugueseDialect,
      LocalizeFrenchDialect_1.LocalizeFrenchDialect
    ]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/Gender.js
var require_Gender2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/Gender.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gender = void 0;
    var core = __importStar(require_core());
    exports.Gender = core.serialization.enum_([
      "male",
      "female"
    ]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizeVoiceRequest.js
var require_LocalizeVoiceRequest2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/LocalizeVoiceRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalizeVoiceRequest = void 0;
    var core = __importStar(require_core());
    var LocalizeTargetLanguage_1 = require_LocalizeTargetLanguage2();
    var Gender_1 = require_Gender2();
    var LocalizeDialect_1 = require_LocalizeDialect2();
    exports.LocalizeVoiceRequest = core.serialization.object({
      voiceId: core.serialization.property("voice_id", core.serialization.string()),
      name: core.serialization.string(),
      description: core.serialization.string(),
      language: LocalizeTargetLanguage_1.LocalizeTargetLanguage,
      originalSpeakerGender: core.serialization.property("original_speaker_gender", Gender_1.Gender),
      dialect: LocalizeDialect_1.LocalizeDialect.optional()
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/EmbeddingResponse.js
var require_EmbeddingResponse2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/EmbeddingResponse.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmbeddingResponse = void 0;
    var core = __importStar(require_core());
    var Embedding_1 = require_Embedding2();
    exports.EmbeddingResponse = core.serialization.object({
      embedding: Embedding_1.Embedding
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/Weight.js
var require_Weight2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/Weight.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Weight = void 0;
    var core = __importStar(require_core());
    exports.Weight = core.serialization.number();
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/IdSpecifier.js
var require_IdSpecifier2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/IdSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IdSpecifier = void 0;
    var core = __importStar(require_core());
    var VoiceId_1 = require_VoiceId2();
    var Weight_1 = require_Weight2();
    exports.IdSpecifier = core.serialization.object({
      id: VoiceId_1.VoiceId,
      weight: Weight_1.Weight
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/EmbeddingSpecifier.js
var require_EmbeddingSpecifier2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/EmbeddingSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmbeddingSpecifier = void 0;
    var core = __importStar(require_core());
    var Embedding_1 = require_Embedding2();
    var Weight_1 = require_Weight2();
    exports.EmbeddingSpecifier = core.serialization.object({
      embedding: Embedding_1.Embedding,
      weight: Weight_1.Weight
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/MixVoiceSpecifier.js
var require_MixVoiceSpecifier2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/MixVoiceSpecifier.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MixVoiceSpecifier = void 0;
    var core = __importStar(require_core());
    var IdSpecifier_1 = require_IdSpecifier2();
    var EmbeddingSpecifier_1 = require_EmbeddingSpecifier2();
    exports.MixVoiceSpecifier = core.serialization.undiscriminatedUnion([IdSpecifier_1.IdSpecifier, EmbeddingSpecifier_1.EmbeddingSpecifier]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/MixVoicesRequest.js
var require_MixVoicesRequest2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/MixVoicesRequest.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MixVoicesRequest = void 0;
    var core = __importStar(require_core());
    var MixVoiceSpecifier_1 = require_MixVoiceSpecifier2();
    exports.MixVoicesRequest = core.serialization.object({
      voices: core.serialization.list(MixVoiceSpecifier_1.MixVoiceSpecifier)
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/CloneMode.js
var require_CloneMode2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/CloneMode.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CloneMode = void 0;
    var core = __importStar(require_core());
    exports.CloneMode = core.serialization.enum_(["similarity", "stability"]);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/index.js
var require_types14 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/types/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_VoiceId2(), exports);
    __exportStar(require_BaseVoiceId2(), exports);
    __exportStar(require_Voice2(), exports);
    __exportStar(require_VoiceMetadata2(), exports);
    __exportStar(require_CreateVoiceRequest2(), exports);
    __exportStar(require_UpdateVoiceRequest2(), exports);
    __exportStar(require_LocalizeTargetLanguage2(), exports);
    __exportStar(require_LocalizeEnglishDialect2(), exports);
    __exportStar(require_LocalizeFrenchDialect2(), exports);
    __exportStar(require_LocalizeSpanishDialect2(), exports);
    __exportStar(require_LocalizePortugueseDialect2(), exports);
    __exportStar(require_LocalizeDialect2(), exports);
    __exportStar(require_Gender2(), exports);
    __exportStar(require_LocalizeVoiceRequest2(), exports);
    __exportStar(require_EmbeddingResponse2(), exports);
    __exportStar(require_MixVoicesRequest2(), exports);
    __exportStar(require_Weight2(), exports);
    __exportStar(require_IdSpecifier2(), exports);
    __exportStar(require_EmbeddingSpecifier2(), exports);
    __exportStar(require_MixVoiceSpecifier2(), exports);
    __exportStar(require_CloneMode2(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/client/list.js
var require_list3 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/client/list.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Response = void 0;
    var core = __importStar(require_core());
    var Voice_1 = require_Voice2();
    exports.Response = core.serialization.list(Voice_1.Voice);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/client/index.js
var require_client8 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/client/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.list = void 0;
    exports.list = __importStar(require_list3());
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/index.js
var require_voices2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/voices/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types14(), exports);
    __exportStar(require_client8(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/resources/index.js
var require_resources2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/resources/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.voices = exports.voiceChanger = exports.tts = exports.stt = exports.embedding = exports.auth = exports.apiStatus = void 0;
    exports.apiStatus = __importStar(require_apiStatus2());
    __exportStar(require_types8(), exports);
    exports.auth = __importStar(require_auth2());
    __exportStar(require_types9(), exports);
    exports.embedding = __importStar(require_embedding2());
    __exportStar(require_types10(), exports);
    exports.stt = __importStar(require_stt2());
    __exportStar(require_types11(), exports);
    exports.tts = __importStar(require_tts2());
    __exportStar(require_types12(), exports);
    exports.voiceChanger = __importStar(require_voiceChanger2());
    __exportStar(require_types13(), exports);
    exports.voices = __importStar(require_voices2());
    __exportStar(require_types14(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/serialization/index.js
var require_serialization = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/serialization/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_resources2(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/errors/CartesiaError.js
var require_CartesiaError = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/errors/CartesiaError.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CartesiaError = void 0;
    var json_1 = require_json();
    var CartesiaError = class _CartesiaError extends Error {
      static {
        __name(this, "CartesiaError");
      }
      constructor({ message, statusCode, body }) {
        super(buildMessage({ message, statusCode, body }));
        Object.setPrototypeOf(this, _CartesiaError.prototype);
        if (statusCode != null) {
          this.statusCode = statusCode;
        }
        if (body !== void 0) {
          this.body = body;
        }
      }
    };
    exports.CartesiaError = CartesiaError;
    function buildMessage({ message, statusCode, body }) {
      let lines = [];
      if (message != null) {
        lines.push(message);
      }
      if (statusCode != null) {
        lines.push(`Status code: ${statusCode.toString()}`);
      }
      if (body != null) {
        lines.push(`Body: ${(0, json_1.toJson)(body, void 0, 2)}`);
      }
      return lines.join("\n");
    }
    __name(buildMessage, "buildMessage");
  }
});

// ../../node_modules/@cartesia/cartesia-js/errors/CartesiaTimeoutError.js
var require_CartesiaTimeoutError = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/errors/CartesiaTimeoutError.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CartesiaTimeoutError = void 0;
    var CartesiaTimeoutError = class _CartesiaTimeoutError extends Error {
      static {
        __name(this, "CartesiaTimeoutError");
      }
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _CartesiaTimeoutError.prototype);
      }
    };
    exports.CartesiaTimeoutError = CartesiaTimeoutError;
  }
});

// ../../node_modules/@cartesia/cartesia-js/errors/index.js
var require_errors2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/errors/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CartesiaTimeoutError = exports.CartesiaError = void 0;
    var CartesiaError_1 = require_CartesiaError();
    Object.defineProperty(exports, "CartesiaError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return CartesiaError_1.CartesiaError;
    }, "get") });
    var CartesiaTimeoutError_1 = require_CartesiaTimeoutError();
    Object.defineProperty(exports, "CartesiaTimeoutError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return CartesiaTimeoutError_1.CartesiaTimeoutError;
    }, "get") });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/apiStatus/client/Client.js
var require_Client = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/apiStatus/client/Client.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ApiStatus = void 0;
    var environments = __importStar(require_environments());
    var core = __importStar(require_core());
    var serializers = __importStar(require_serialization());
    var errors = __importStar(require_errors2());
    var ApiStatus = class {
      static {
        __name(this, "ApiStatus");
      }
      constructor(_options = {}) {
        this._options = _options;
      }
      /**
       * @param {ApiStatus.RequestOptions} requestOptions - Request-specific configuration.
       *
       * @example
       *     await client.apiStatus.get()
       */
      get(requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production,
            method: "GET",
            headers: Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            contentType: "application/json",
            requestType: "json",
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return serializers.ApiInfo.parseOrThrow(_response.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true,
              skipValidation: true,
              breadcrumbsPrefix: ["response"]
            });
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling GET /.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      _getCustomAuthorizationHeaders() {
        return __awaiter11(this, void 0, void 0, function* () {
          const apiKeyValue = yield core.Supplier.get(this._options.apiKey);
          return { "X-API-Key": apiKeyValue };
        });
      }
    };
    exports.ApiStatus = ApiStatus;
  }
});

// ../../node_modules/url-join/lib/url-join.js
var require_url_join = __commonJS({
  "../../node_modules/url-join/lib/url-join.js"(exports, module) {
    init_modules_watch_stub();
    (function(name, context, definition) {
      if (typeof module !== "undefined" && module.exports) module.exports = definition();
      else if (typeof define === "function" && define.amd) define(definition);
      else context[name] = definition();
    })("urljoin", exports, function() {
      function normalize(strArray) {
        var resultArray = [];
        if (strArray.length === 0) {
          return "";
        }
        if (typeof strArray[0] !== "string") {
          throw new TypeError("Url must be a string. Received " + strArray[0]);
        }
        if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
          var first = strArray.shift();
          strArray[0] = first + strArray[0];
        }
        if (strArray[0].match(/^file:\/\/\//)) {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1:///");
        } else {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1://");
        }
        for (var i = 0; i < strArray.length; i++) {
          var component = strArray[i];
          if (typeof component !== "string") {
            throw new TypeError("Url must be a string. Received " + component);
          }
          if (component === "") {
            continue;
          }
          if (i > 0) {
            component = component.replace(/^[\/]+/, "");
          }
          if (i < strArray.length - 1) {
            component = component.replace(/[\/]+$/, "");
          } else {
            component = component.replace(/[\/]+$/, "/");
          }
          resultArray.push(component);
        }
        var str = resultArray.join("/");
        str = str.replace(/\/(\?|&|#[^!])/g, "$1");
        var parts = str.split("?");
        str = parts.shift() + (parts.length > 0 ? "?" : "") + parts.join("&");
        return str;
      }
      __name(normalize, "normalize");
      return function() {
        var input;
        if (typeof arguments[0] === "object") {
          input = arguments[0];
        } else {
          input = [].slice.call(arguments);
        }
        return normalize(input);
      };
    });
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/auth/client/Client.js
var require_Client2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/auth/client/Client.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Auth = void 0;
    var environments = __importStar(require_environments());
    var core = __importStar(require_core());
    var serializers = __importStar(require_serialization());
    var url_join_1 = __importDefault(require_url_join());
    var errors = __importStar(require_errors2());
    var Auth = class {
      static {
        __name(this, "Auth");
      }
      constructor(_options = {}) {
        this._options = _options;
      }
      /**
       * Generates a new Access Token for the client. These tokens are short-lived and should be used to make requests to the API from authenticated clients.
       *
       * @param {Cartesia.TokenRequest} request
       * @param {Auth.RequestOptions} requestOptions - Request-specific configuration.
       *
       * @example
       *     await client.auth.accessToken({
       *         grants: {
       *             tts: true,
       *             stt: true
       *         },
       *         expiresIn: 60
       *     })
       *
       * @example
       *     await client.auth.accessToken({
       *         grants: {
       *             tts: true
       *         },
       *         expiresIn: 60
       *     })
       *
       * @example
       *     await client.auth.accessToken({
       *         grants: {
       *             stt: true
       *         },
       *         expiresIn: 60
       *     })
       */
      accessToken(request, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, "access-token"),
            method: "POST",
            headers: Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            contentType: "application/json",
            requestType: "json",
            body: serializers.TokenRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return serializers.TokenResponse.parseOrThrow(_response.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true,
              skipValidation: true,
              breadcrumbsPrefix: ["response"]
            });
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling POST /access-token.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      _getCustomAuthorizationHeaders() {
        return __awaiter11(this, void 0, void 0, function* () {
          const apiKeyValue = yield core.Supplier.get(this._options.apiKey);
          return { "X-API-Key": apiKeyValue };
        });
      }
    };
    exports.Auth = Auth;
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/infill/client/Client.js
var require_Client3 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/infill/client/Client.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Infill = void 0;
    var environments = __importStar(require_environments());
    var core = __importStar(require_core());
    var serializers = __importStar(require_serialization());
    var json_1 = require_json();
    var url_join_1 = __importDefault(require_url_join());
    var errors = __importStar(require_errors2());
    var Infill = class {
      static {
        __name(this, "Infill");
      }
      constructor(_options = {}) {
        this._options = _options;
      }
      /**
       * Generate audio that smoothly connects two existing audio segments. This is useful for inserting new speech between existing speech segments while maintaining natural transitions.
       *
       * **The cost is 1 credit per character of the infill text plus a fixed cost of 300 credits.**
       *
       * Infilling is only available on `sonic-2` at this time.
       *
       * At least one of `left_audio` or `right_audio` must be provided.
       *
       * As with all generative models, there's some inherent variability, but here's some tips we recommend to get the best results from infill:
       * - Use longer infill transcripts
       *   - This gives the model more flexibility to adapt to the rest of the audio
       * - Target natural pauses in the audio when deciding where to clip
       *   - This means you don't need word-level timestamps to be as precise
       * - Clip right up to the start and end of the audio segment you want infilled, keeping as much silence in the left/right audio segments as possible
       *   - This helps the model generate more natural transitions
       */
      bytes(leftAudio, rightAudio, request, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _request = yield core.newFormData();
          yield _request.appendFile("left_audio", leftAudio);
          yield _request.appendFile("right_audio", rightAudio);
          _request.append("model_id", request.modelId);
          _request.append("language", request.language);
          _request.append("transcript", request.transcript);
          _request.append("voice_id", request.voiceId);
          _request.append("output_format[container]", serializers.OutputFormatContainer.jsonOrThrow(request.outputFormatContainer, {
            unrecognizedObjectKeys: "strip"
          }));
          _request.append("output_format[sample_rate]", request.outputFormatSampleRate.toString());
          if (request.outputFormatEncoding != null) {
            _request.append("output_format[encoding]", serializers.RawEncoding.jsonOrThrow(request.outputFormatEncoding, { unrecognizedObjectKeys: "strip" }));
          }
          if (request.outputFormatBitRate != null) {
            _request.append("output_format[bit_rate]", request.outputFormatBitRate.toString());
          }
          if (request.voiceExperimentalControlsSpeed != null) {
            _request.append("voice[__experimental_controls][speed]", (() => {
              const mapped = serializers.Speed.jsonOrThrow(request.voiceExperimentalControlsSpeed, {
                unrecognizedObjectKeys: "strip"
              });
              return typeof mapped === "string" ? mapped : (0, json_1.toJson)(mapped);
            })());
          }
          if (request.voiceExperimentalControlsEmotion != null) {
            for (const _item of request.voiceExperimentalControlsEmotion) {
              _request.append("voice[__experimental_controls][emotion][]", serializers.Emotion.jsonOrThrow(_item, { unrecognizedObjectKeys: "strip" }));
            }
          }
          const _maybeEncodedRequest = yield _request.getRequest();
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, "/infill/bytes"),
            method: "POST",
            headers: Object.assign(Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), _maybeEncodedRequest.headers), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            responseType: "streaming",
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return _response.body;
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling POST /infill/bytes.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      _getCustomAuthorizationHeaders() {
        return __awaiter11(this, void 0, void 0, function* () {
          const apiKeyValue = yield core.Supplier.get(this._options.apiKey);
          return { "X-API-Key": apiKeyValue };
        });
      }
    };
    exports.Infill = Infill;
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/stt/client/Client.js
var require_Client4 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/stt/client/Client.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Stt = void 0;
    var environments = __importStar(require_environments());
    var core = __importStar(require_core());
    var serializers = __importStar(require_serialization());
    var url_join_1 = __importDefault(require_url_join());
    var errors = __importStar(require_errors2());
    var Stt = class {
      static {
        __name(this, "Stt");
      }
      constructor(_options = {}) {
        this._options = _options;
      }
      /**
       * Transcribes audio files into text using Cartesia's Speech-to-Text API.
       *
       * Upload an audio file and receive a complete transcription response. Supports arbitrarily long audio files with automatic intelligent chunking for longer audio.
       *
       * **Supported audio formats:** flac, m4a, mp3, mp4, mpeg, mpga, oga, ogg, wav, webm
       *
       * **Response format:** Returns JSON with transcribed text, duration, and language. Include `timestamp_granularities: ["word"]` to get word-level timestamps.
       *
       * **Pricing:** Batch transcription is priced at **1 credit per 2 seconds** of audio processed.
       *
       * <Note>
       * For migrating from the OpenAI SDK, see our [OpenAI Whisper to Cartesia Ink Migration Guide](/api-reference/stt/migrate-from-open-ai).
       * </Note>
       *
       * @param {File | fs.ReadStream | Blob} file
       * @param {Cartesia.TranscriptionRequest} request
       * @param {Stt.RequestOptions} requestOptions - Request-specific configuration.
       *
       * @example
       *     await client.stt.transcribe(fs.createReadStream("/path/to/your/file"), {
       *         model: "ink-whisper",
       *         language: "en"
       *     })
       *
       * @example
       *     await client.stt.transcribe(fs.createReadStream("/path/to/your/file"), {
       *         model: "ink-whisper",
       *         language: "en",
       *         timestampGranularities: ["word"]
       *     })
       */
      transcribe(file, request, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _queryParams = {};
          if (request.encoding != null) {
            _queryParams["encoding"] = serializers.SttEncoding.jsonOrThrow(request.encoding, {
              unrecognizedObjectKeys: "strip"
            });
          }
          if (request.sampleRate != null) {
            _queryParams["sample_rate"] = request.sampleRate.toString();
          }
          const _request = yield core.newFormData();
          yield _request.appendFile("file", file);
          _request.append("model", request.model);
          if (request.language != null) {
            _request.append("language", request.language);
          }
          if (request.timestampGranularities != null) {
            for (const _item of request.timestampGranularities) {
              _request.append("timestamp_granularities[]", serializers.TimestampGranularity.jsonOrThrow(_item, { unrecognizedObjectKeys: "strip" }));
            }
          }
          const _maybeEncodedRequest = yield _request.getRequest();
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, "/stt"),
            method: "POST",
            headers: Object.assign(Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), _maybeEncodedRequest.headers), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            queryParameters: _queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return serializers.TranscriptionResponse.parseOrThrow(_response.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true,
              skipValidation: true,
              breadcrumbsPrefix: ["response"]
            });
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling POST /stt.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      _getCustomAuthorizationHeaders() {
        return __awaiter11(this, void 0, void 0, function* () {
          const apiKeyValue = yield core.Supplier.get(this._options.apiKey);
          return { "X-API-Key": apiKeyValue };
        });
      }
    };
    exports.Stt = Stt;
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/tts/client/Client.js
var require_Client5 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/tts/client/Client.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tts = void 0;
    var environments = __importStar(require_environments());
    var core = __importStar(require_core());
    var serializers = __importStar(require_serialization());
    var url_join_1 = __importDefault(require_url_join());
    var errors = __importStar(require_errors2());
    var Tts = class {
      static {
        __name(this, "Tts");
      }
      constructor(_options = {}) {
        this._options = _options;
      }
      bytes(request, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, "/tts/bytes"),
            method: "POST",
            headers: Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            contentType: "application/json",
            requestType: "json",
            body: serializers.TtsRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            responseType: "streaming",
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return _response.body;
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling POST /tts/bytes.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      sse(request, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, "/tts/sse"),
            method: "POST",
            headers: Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            contentType: "application/json",
            requestType: "json",
            body: serializers.TtssseRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            responseType: "sse",
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return new core.Stream({
              stream: _response.body,
              parse: /* @__PURE__ */ __name((data) => __awaiter11(this, void 0, void 0, function* () {
                return serializers.WebSocketResponse.parseOrThrow(data, {
                  unrecognizedObjectKeys: "passthrough",
                  allowUnrecognizedUnionMembers: true,
                  allowUnrecognizedEnumValues: true,
                  skipValidation: true,
                  breadcrumbsPrefix: ["response"]
                });
              }), "parse"),
              signal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
              eventShape: {
                type: "sse",
                streamTerminator: "[DONE]"
              }
            });
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling POST /tts/sse.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      _getCustomAuthorizationHeaders() {
        return __awaiter11(this, void 0, void 0, function* () {
          const apiKeyValue = yield core.Supplier.get(this._options.apiKey);
          return { "X-API-Key": apiKeyValue };
        });
      }
    };
    exports.Tts = Tts;
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/client/Client.js
var require_Client6 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voiceChanger/client/Client.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoiceChanger = void 0;
    var environments = __importStar(require_environments());
    var core = __importStar(require_core());
    var serializers = __importStar(require_serialization());
    var url_join_1 = __importDefault(require_url_join());
    var errors = __importStar(require_errors2());
    var VoiceChanger = class {
      static {
        __name(this, "VoiceChanger");
      }
      constructor(_options = {}) {
        this._options = _options;
      }
      /**
       * Takes an audio file of speech, and returns an audio file of speech spoken with the same intonation, but with a different voice.
       *
       * This endpoint is priced at 15 characters per second of input audio.
       */
      bytes(clip, request, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _request = yield core.newFormData();
          yield _request.appendFile("clip", clip);
          _request.append("voice[id]", request.voiceId);
          _request.append("output_format[container]", serializers.OutputFormatContainer.jsonOrThrow(request.outputFormatContainer, {
            unrecognizedObjectKeys: "strip"
          }));
          _request.append("output_format[sample_rate]", request.outputFormatSampleRate.toString());
          if (request.outputFormatEncoding != null) {
            _request.append("output_format[encoding]", serializers.RawEncoding.jsonOrThrow(request.outputFormatEncoding, { unrecognizedObjectKeys: "strip" }));
          }
          if (request.outputFormatBitRate != null) {
            _request.append("output_format[bit_rate]", request.outputFormatBitRate.toString());
          }
          const _maybeEncodedRequest = yield _request.getRequest();
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, "/voice-changer/bytes"),
            method: "POST",
            headers: Object.assign(Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), _maybeEncodedRequest.headers), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            responseType: "streaming",
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return _response.body;
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling POST /voice-changer/bytes.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      sse(clip, request, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _request = yield core.newFormData();
          yield _request.appendFile("clip", clip);
          _request.append("voice[id]", request.voiceId);
          _request.append("output_format[container]", serializers.OutputFormatContainer.jsonOrThrow(request.outputFormatContainer, {
            unrecognizedObjectKeys: "strip"
          }));
          _request.append("output_format[sample_rate]", request.outputFormatSampleRate.toString());
          if (request.outputFormatEncoding != null) {
            _request.append("output_format[encoding]", serializers.RawEncoding.jsonOrThrow(request.outputFormatEncoding, { unrecognizedObjectKeys: "strip" }));
          }
          if (request.outputFormatBitRate != null) {
            _request.append("output_format[bit_rate]", request.outputFormatBitRate.toString());
          }
          const _maybeEncodedRequest = yield _request.getRequest();
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, "/voice-changer/sse"),
            method: "POST",
            headers: Object.assign(Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), _maybeEncodedRequest.headers), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            responseType: "sse",
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return new core.Stream({
              stream: _response.body,
              parse: /* @__PURE__ */ __name((data) => __awaiter11(this, void 0, void 0, function* () {
                return serializers.StreamingResponse.parseOrThrow(data, {
                  unrecognizedObjectKeys: "passthrough",
                  allowUnrecognizedUnionMembers: true,
                  allowUnrecognizedEnumValues: true,
                  skipValidation: true,
                  breadcrumbsPrefix: ["response"]
                });
              }), "parse"),
              signal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
              eventShape: {
                type: "json",
                messageTerminator: "\n"
              }
            });
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling POST /voice-changer/sse.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      _getCustomAuthorizationHeaders() {
        return __awaiter11(this, void 0, void 0, function* () {
          const apiKeyValue = yield core.Supplier.get(this._options.apiKey);
          return { "X-API-Key": apiKeyValue };
        });
      }
    };
    exports.VoiceChanger = VoiceChanger;
  }
});

// ../../node_modules/@cartesia/cartesia-js/api/resources/voices/client/Client.js
var require_Client7 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/api/resources/voices/client/Client.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Voices = void 0;
    var environments = __importStar(require_environments());
    var core = __importStar(require_core());
    var url_join_1 = __importDefault(require_url_join());
    var serializers = __importStar(require_serialization());
    var errors = __importStar(require_errors2());
    var Voices = class {
      static {
        __name(this, "Voices");
      }
      constructor(_options = {}) {
        this._options = _options;
      }
      /**
       * @param {Voices.RequestOptions} requestOptions - Request-specific configuration.
       *
       * @example
       *     await client.voices.list()
       */
      list(requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, "/voices/"),
            method: "GET",
            headers: Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            contentType: "application/json",
            requestType: "json",
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return serializers.voices.list.Response.parseOrThrow(_response.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true,
              skipValidation: true,
              breadcrumbsPrefix: ["response"]
            });
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling GET /voices/.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      /**
       * Clone a voice from an audio clip. This endpoint has two modes, stability and similarity.
       *
       * Similarity mode clones are more similar to the source clip, but may reproduce background noise. For these, use an audio clip about 5 seconds long.
       *
       * Stability mode clones are more stable, but may not sound as similar to the source clip. For these, use an audio clip 10-20 seconds long.
       *
       * @param {File | fs.ReadStream | Blob} clip
       * @param {Cartesia.CloneVoiceRequest} request
       * @param {Voices.RequestOptions} requestOptions - Request-specific configuration.
       *
       * @example
       *     await client.voices.clone(fs.createReadStream("/path/to/your/file"), {
       *         name: "A high-stability cloned voice",
       *         description: "Copied from Cartesia docs",
       *         mode: "stability",
       *         language: "en"
       *     })
       *
       * @example
       *     await client.voices.clone(fs.createReadStream("/path/to/your/file"), {
       *         name: "A high-similarity cloned voice",
       *         description: "Copied from Cartesia docs",
       *         mode: "similarity",
       *         language: "en"
       *     })
       */
      clone(clip, request, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _request = yield core.newFormData();
          yield _request.appendFile("clip", clip);
          _request.append("name", request.name);
          if (request.description != null) {
            _request.append("description", request.description);
          }
          _request.append("language", serializers.SupportedLanguage.jsonOrThrow(request.language, { unrecognizedObjectKeys: "strip" }));
          _request.append("mode", serializers.CloneMode.jsonOrThrow(request.mode, { unrecognizedObjectKeys: "strip" }));
          if (request.enhance != null) {
            _request.append("enhance", request.enhance.toString());
          }
          if (request.baseVoiceId != null) {
            _request.append("base_voice_id", serializers.VoiceId.jsonOrThrow(request.baseVoiceId, { unrecognizedObjectKeys: "strip" }));
          }
          const _maybeEncodedRequest = yield _request.getRequest();
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, "/voices/clone"),
            method: "POST",
            headers: Object.assign(Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), _maybeEncodedRequest.headers), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return serializers.VoiceMetadata.parseOrThrow(_response.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true,
              skipValidation: true,
              breadcrumbsPrefix: ["response"]
            });
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling POST /voices/clone.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      /**
       * @param {Cartesia.VoiceId} id
       * @param {Voices.RequestOptions} requestOptions - Request-specific configuration.
       *
       * @example
       *     await client.voices.delete("id")
       */
      delete(id, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, `/voices/${encodeURIComponent(serializers.VoiceId.jsonOrThrow(id))}`),
            method: "DELETE",
            headers: Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            contentType: "application/json",
            requestType: "json",
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return;
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling DELETE /voices/{id}.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      /**
       * @param {Cartesia.VoiceId} id
       * @param {Cartesia.UpdateVoiceRequest} request
       * @param {Voices.RequestOptions} requestOptions - Request-specific configuration.
       *
       * @example
       *     await client.voices.update("id", {
       *         name: "name",
       *         description: "description"
       *     })
       */
      update(id, request, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, `/voices/${encodeURIComponent(serializers.VoiceId.jsonOrThrow(id))}`),
            method: "PATCH",
            headers: Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            contentType: "application/json",
            requestType: "json",
            body: serializers.UpdateVoiceRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return serializers.Voice.parseOrThrow(_response.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true,
              skipValidation: true,
              breadcrumbsPrefix: ["response"]
            });
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling PATCH /voices/{id}.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      /**
       * @param {Cartesia.VoiceId} id
       * @param {Voices.RequestOptions} requestOptions - Request-specific configuration.
       *
       * @example
       *     await client.voices.get("id")
       */
      get(id, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, `/voices/${encodeURIComponent(serializers.VoiceId.jsonOrThrow(id))}`),
            method: "GET",
            headers: Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            contentType: "application/json",
            requestType: "json",
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return serializers.Voice.parseOrThrow(_response.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true,
              skipValidation: true,
              breadcrumbsPrefix: ["response"]
            });
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling GET /voices/{id}.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      /**
       * Create a new voice from an existing voice localized to a new language and dialect.
       *
       * @param {Cartesia.LocalizeVoiceRequest} request
       * @param {Voices.RequestOptions} requestOptions - Request-specific configuration.
       *
       * @example
       *     await client.voices.localize({
       *         voiceId: "694f9389-aac1-45b6-b726-9d9369183238",
       *         name: "Sarah Peninsular Spanish",
       *         description: "Sarah Voice in Peninsular Spanish",
       *         language: "es",
       *         originalSpeakerGender: "female",
       *         dialect: "pe"
       *     })
       */
      localize(request, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, "/voices/localize"),
            method: "POST",
            headers: Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            contentType: "application/json",
            requestType: "json",
            body: serializers.LocalizeVoiceRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return serializers.VoiceMetadata.parseOrThrow(_response.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true,
              skipValidation: true,
              breadcrumbsPrefix: ["response"]
            });
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling POST /voices/localize.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      /**
       * @param {Cartesia.MixVoicesRequest} request
       * @param {Voices.RequestOptions} requestOptions - Request-specific configuration.
       *
       * @example
       *     await client.voices.mix({
       *         voices: [{
       *                 id: "id",
       *                 weight: 1.1
       *             }, {
       *                 id: "id",
       *                 weight: 1.1
       *             }]
       *     })
       */
      mix(request, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, "/voices/mix"),
            method: "POST",
            headers: Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            contentType: "application/json",
            requestType: "json",
            body: serializers.MixVoicesRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return serializers.EmbeddingResponse.parseOrThrow(_response.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true,
              skipValidation: true,
              breadcrumbsPrefix: ["response"]
            });
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling POST /voices/mix.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      /**
       * Create voice from raw features. If you'd like to clone a voice from an audio file, please use Clone Voice instead.
       *
       * @param {Cartesia.CreateVoiceRequest} request
       * @param {Voices.RequestOptions} requestOptions - Request-specific configuration.
       *
       * @example
       *     await client.voices.create({
       *         name: "My Custom Voice",
       *         description: "A custom voice created through the API",
       *         embedding: [],
       *         language: "en",
       *         baseVoiceId: "123e4567-e89b-12d3-a456-426614174000"
       *     })
       */
      create(request, requestOptions) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const _response = yield ((_a = this._options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher)({
            url: (0, url_join_1.default)((_c = (_b = yield core.Supplier.get(this._options.baseUrl)) !== null && _b !== void 0 ? _b : yield core.Supplier.get(this._options.environment)) !== null && _c !== void 0 ? _c : environments.CartesiaEnvironment.Production, "/voices/"),
            method: "POST",
            headers: Object.assign(Object.assign({ "Cartesia-Version": (_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.cartesiaVersion) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.cartesiaVersion) !== null && _f !== void 0 ? _f : "2024-06-10", "X-Fern-Language": "JavaScript", "X-Fern-SDK-Name": "@cartesia/cartesia-js", "X-Fern-SDK-Version": "2.2.9", "User-Agent": "@cartesia/cartesia-js/2.2.9", "X-Fern-Runtime": core.RUNTIME.type, "X-Fern-Runtime-Version": core.RUNTIME.version }, yield this._getCustomAuthorizationHeaders()), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers),
            contentType: "application/json",
            requestType: "json",
            body: serializers.CreateVoiceRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1e3 : 6e4,
            maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
            abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal
          });
          if (_response.ok) {
            return serializers.VoiceMetadata.parseOrThrow(_response.body, {
              unrecognizedObjectKeys: "passthrough",
              allowUnrecognizedUnionMembers: true,
              allowUnrecognizedEnumValues: true,
              skipValidation: true,
              breadcrumbsPrefix: ["response"]
            });
          }
          if (_response.error.reason === "status-code") {
            throw new errors.CartesiaError({
              statusCode: _response.error.statusCode,
              body: _response.error.body
            });
          }
          switch (_response.error.reason) {
            case "non-json":
              throw new errors.CartesiaError({
                statusCode: _response.error.statusCode,
                body: _response.error.rawBody
              });
            case "timeout":
              throw new errors.CartesiaTimeoutError("Timeout exceeded when calling POST /voices/.");
            case "unknown":
              throw new errors.CartesiaError({
                message: _response.error.errorMessage
              });
          }
        });
      }
      _getCustomAuthorizationHeaders() {
        return __awaiter11(this, void 0, void 0, function* () {
          const apiKeyValue = yield core.Supplier.get(this._options.apiKey);
          return { "X-API-Key": apiKeyValue };
        });
      }
    };
    exports.Voices = Voices;
  }
});

// ../../node_modules/@cartesia/cartesia-js/Client.js
var require_Client8 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/Client.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CartesiaClient = void 0;
    var Client_1 = require_Client();
    var Client_2 = require_Client2();
    var Client_3 = require_Client3();
    var Client_4 = require_Client4();
    var Client_5 = require_Client5();
    var Client_6 = require_Client6();
    var Client_7 = require_Client7();
    var CartesiaClient2 = class {
      static {
        __name(this, "CartesiaClient");
      }
      constructor(_options = {}) {
        this._options = _options;
      }
      get apiStatus() {
        var _a;
        return (_a = this._apiStatus) !== null && _a !== void 0 ? _a : this._apiStatus = new Client_1.ApiStatus(this._options);
      }
      get auth() {
        var _a;
        return (_a = this._auth) !== null && _a !== void 0 ? _a : this._auth = new Client_2.Auth(this._options);
      }
      get infill() {
        var _a;
        return (_a = this._infill) !== null && _a !== void 0 ? _a : this._infill = new Client_3.Infill(this._options);
      }
      get stt() {
        var _a;
        return (_a = this._stt) !== null && _a !== void 0 ? _a : this._stt = new Client_4.Stt(this._options);
      }
      get tts() {
        var _a;
        return (_a = this._tts) !== null && _a !== void 0 ? _a : this._tts = new Client_5.Tts(this._options);
      }
      get voiceChanger() {
        var _a;
        return (_a = this._voiceChanger) !== null && _a !== void 0 ? _a : this._voiceChanger = new Client_6.VoiceChanger(this._options);
      }
      get voices() {
        var _a;
        return (_a = this._voices) !== null && _a !== void 0 ? _a : this._voices = new Client_7.Voices(this._options);
      }
    };
    exports.CartesiaClient = CartesiaClient2;
  }
});

// ../../node_modules/emittery/maps.js
var require_maps = __commonJS({
  "../../node_modules/emittery/maps.js"(exports, module) {
    init_modules_watch_stub();
    var anyMap = /* @__PURE__ */ new WeakMap();
    var eventsMap = /* @__PURE__ */ new WeakMap();
    var producersMap = /* @__PURE__ */ new WeakMap();
    module.exports = {
      anyMap,
      eventsMap,
      producersMap
    };
  }
});

// ../../node_modules/emittery/index.js
var require_emittery = __commonJS({
  "../../node_modules/emittery/index.js"(exports, module) {
    "use strict";
    init_modules_watch_stub();
    var { anyMap, producersMap, eventsMap } = require_maps();
    var anyProducer = Symbol("anyProducer");
    var resolvedPromise = Promise.resolve();
    var listenerAdded = Symbol("listenerAdded");
    var listenerRemoved = Symbol("listenerRemoved");
    var canEmitMetaEvents = false;
    var isGlobalDebugEnabled = false;
    function assertEventName(eventName) {
      if (typeof eventName !== "string" && typeof eventName !== "symbol" && typeof eventName !== "number") {
        throw new TypeError("`eventName` must be a string, symbol, or number");
      }
    }
    __name(assertEventName, "assertEventName");
    function assertListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError("listener must be a function");
      }
    }
    __name(assertListener, "assertListener");
    function getListeners(instance, eventName) {
      const events = eventsMap.get(instance);
      if (!events.has(eventName)) {
        return;
      }
      return events.get(eventName);
    }
    __name(getListeners, "getListeners");
    function getEventProducers(instance, eventName) {
      const key = typeof eventName === "string" || typeof eventName === "symbol" || typeof eventName === "number" ? eventName : anyProducer;
      const producers = producersMap.get(instance);
      if (!producers.has(key)) {
        return;
      }
      return producers.get(key);
    }
    __name(getEventProducers, "getEventProducers");
    function enqueueProducers(instance, eventName, eventData) {
      const producers = producersMap.get(instance);
      if (producers.has(eventName)) {
        for (const producer of producers.get(eventName)) {
          producer.enqueue(eventData);
        }
      }
      if (producers.has(anyProducer)) {
        const item = Promise.all([eventName, eventData]);
        for (const producer of producers.get(anyProducer)) {
          producer.enqueue(item);
        }
      }
    }
    __name(enqueueProducers, "enqueueProducers");
    function iterator(instance, eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      let isFinished = false;
      let flush = /* @__PURE__ */ __name(() => {
      }, "flush");
      let queue = [];
      const producer = {
        enqueue(item) {
          queue.push(item);
          flush();
        },
        finish() {
          isFinished = true;
          flush();
        }
      };
      for (const eventName of eventNames) {
        let set = getEventProducers(instance, eventName);
        if (!set) {
          set = /* @__PURE__ */ new Set();
          const producers = producersMap.get(instance);
          producers.set(eventName, set);
        }
        set.add(producer);
      }
      return {
        async next() {
          if (!queue) {
            return { done: true };
          }
          if (queue.length === 0) {
            if (isFinished) {
              queue = void 0;
              return this.next();
            }
            await new Promise((resolve) => {
              flush = resolve;
            });
            return this.next();
          }
          return {
            done: false,
            value: await queue.shift()
          };
        },
        async return(value) {
          queue = void 0;
          for (const eventName of eventNames) {
            const set = getEventProducers(instance, eventName);
            if (set) {
              set.delete(producer);
              if (set.size === 0) {
                const producers = producersMap.get(instance);
                producers.delete(eventName);
              }
            }
          }
          flush();
          return arguments.length > 0 ? { done: true, value: await value } : { done: true };
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    __name(iterator, "iterator");
    function defaultMethodNamesOrAssert(methodNames) {
      if (methodNames === void 0) {
        return allEmitteryMethods;
      }
      if (!Array.isArray(methodNames)) {
        throw new TypeError("`methodNames` must be an array of strings");
      }
      for (const methodName of methodNames) {
        if (!allEmitteryMethods.includes(methodName)) {
          if (typeof methodName !== "string") {
            throw new TypeError("`methodNames` element must be a string");
          }
          throw new Error(`${methodName} is not Emittery method`);
        }
      }
      return methodNames;
    }
    __name(defaultMethodNamesOrAssert, "defaultMethodNamesOrAssert");
    var isMetaEvent = /* @__PURE__ */ __name((eventName) => eventName === listenerAdded || eventName === listenerRemoved, "isMetaEvent");
    function emitMetaEvent(emitter, eventName, eventData) {
      if (isMetaEvent(eventName)) {
        try {
          canEmitMetaEvents = true;
          emitter.emit(eventName, eventData);
        } finally {
          canEmitMetaEvents = false;
        }
      }
    }
    __name(emitMetaEvent, "emitMetaEvent");
    var Emittery = class _Emittery {
      static {
        __name(this, "Emittery");
      }
      static mixin(emitteryPropertyName, methodNames) {
        methodNames = defaultMethodNamesOrAssert(methodNames);
        return (target) => {
          if (typeof target !== "function") {
            throw new TypeError("`target` must be function");
          }
          for (const methodName of methodNames) {
            if (target.prototype[methodName] !== void 0) {
              throw new Error(`The property \`${methodName}\` already exists on \`target\``);
            }
          }
          function getEmitteryProperty() {
            Object.defineProperty(this, emitteryPropertyName, {
              enumerable: false,
              value: new _Emittery()
            });
            return this[emitteryPropertyName];
          }
          __name(getEmitteryProperty, "getEmitteryProperty");
          Object.defineProperty(target.prototype, emitteryPropertyName, {
            enumerable: false,
            get: getEmitteryProperty
          });
          const emitteryMethodCaller = /* @__PURE__ */ __name((methodName) => function(...args) {
            return this[emitteryPropertyName][methodName](...args);
          }, "emitteryMethodCaller");
          for (const methodName of methodNames) {
            Object.defineProperty(target.prototype, methodName, {
              enumerable: false,
              value: emitteryMethodCaller(methodName)
            });
          }
          return target;
        };
      }
      static get isDebugEnabled() {
        if (typeof process !== "object") {
          return isGlobalDebugEnabled;
        }
        const { env } = process || { env: {} };
        return env.DEBUG === "emittery" || env.DEBUG === "*" || isGlobalDebugEnabled;
      }
      static set isDebugEnabled(newValue) {
        isGlobalDebugEnabled = newValue;
      }
      constructor(options = {}) {
        anyMap.set(this, /* @__PURE__ */ new Set());
        eventsMap.set(this, /* @__PURE__ */ new Map());
        producersMap.set(this, /* @__PURE__ */ new Map());
        producersMap.get(this).set(anyProducer, /* @__PURE__ */ new Set());
        this.debug = options.debug || {};
        if (this.debug.enabled === void 0) {
          this.debug.enabled = false;
        }
        if (!this.debug.logger) {
          this.debug.logger = (type, debugName, eventName, eventData) => {
            try {
              eventData = JSON.stringify(eventData);
            } catch {
              eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(",")}`;
            }
            if (typeof eventName === "symbol" || typeof eventName === "number") {
              eventName = eventName.toString();
            }
            const currentTime = /* @__PURE__ */ new Date();
            const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;
            console.log(`[${logTime}][emittery:${type}][${debugName}] Event Name: ${eventName}
	data: ${eventData}`);
          };
        }
      }
      logIfDebugEnabled(type, eventName, eventData) {
        if (_Emittery.isDebugEnabled || this.debug.enabled) {
          this.debug.logger(type, this.debug.name, eventName, eventData);
        }
      }
      on(eventNames, listener) {
        assertListener(listener);
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        for (const eventName of eventNames) {
          assertEventName(eventName);
          let set = getListeners(this, eventName);
          if (!set) {
            set = /* @__PURE__ */ new Set();
            const events = eventsMap.get(this);
            events.set(eventName, set);
          }
          set.add(listener);
          this.logIfDebugEnabled("subscribe", eventName, void 0);
          if (!isMetaEvent(eventName)) {
            emitMetaEvent(this, listenerAdded, { eventName, listener });
          }
        }
        return this.off.bind(this, eventNames, listener);
      }
      off(eventNames, listener) {
        assertListener(listener);
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        for (const eventName of eventNames) {
          assertEventName(eventName);
          const set = getListeners(this, eventName);
          if (set) {
            set.delete(listener);
            if (set.size === 0) {
              const events = eventsMap.get(this);
              events.delete(eventName);
            }
          }
          this.logIfDebugEnabled("unsubscribe", eventName, void 0);
          if (!isMetaEvent(eventName)) {
            emitMetaEvent(this, listenerRemoved, { eventName, listener });
          }
        }
      }
      once(eventNames) {
        let off_;
        const promise = new Promise((resolve) => {
          off_ = this.on(eventNames, (data) => {
            off_();
            resolve(data);
          });
        });
        promise.off = off_;
        return promise;
      }
      events(eventNames) {
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        for (const eventName of eventNames) {
          assertEventName(eventName);
        }
        return iterator(this, eventNames);
      }
      async emit(eventName, eventData) {
        assertEventName(eventName);
        if (isMetaEvent(eventName) && !canEmitMetaEvents) {
          throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
        }
        this.logIfDebugEnabled("emit", eventName, eventData);
        enqueueProducers(this, eventName, eventData);
        const listeners = getListeners(this, eventName) || /* @__PURE__ */ new Set();
        const anyListeners = anyMap.get(this);
        const staticListeners = [...listeners];
        const staticAnyListeners = isMetaEvent(eventName) ? [] : [...anyListeners];
        await resolvedPromise;
        await Promise.all([
          ...staticListeners.map(async (listener) => {
            if (listeners.has(listener)) {
              return listener(eventData);
            }
          }),
          ...staticAnyListeners.map(async (listener) => {
            if (anyListeners.has(listener)) {
              return listener(eventName, eventData);
            }
          })
        ]);
      }
      async emitSerial(eventName, eventData) {
        assertEventName(eventName);
        if (isMetaEvent(eventName) && !canEmitMetaEvents) {
          throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
        }
        this.logIfDebugEnabled("emitSerial", eventName, eventData);
        const listeners = getListeners(this, eventName) || /* @__PURE__ */ new Set();
        const anyListeners = anyMap.get(this);
        const staticListeners = [...listeners];
        const staticAnyListeners = [...anyListeners];
        await resolvedPromise;
        for (const listener of staticListeners) {
          if (listeners.has(listener)) {
            await listener(eventData);
          }
        }
        for (const listener of staticAnyListeners) {
          if (anyListeners.has(listener)) {
            await listener(eventName, eventData);
          }
        }
      }
      onAny(listener) {
        assertListener(listener);
        this.logIfDebugEnabled("subscribeAny", void 0, void 0);
        anyMap.get(this).add(listener);
        emitMetaEvent(this, listenerAdded, { listener });
        return this.offAny.bind(this, listener);
      }
      anyEvent() {
        return iterator(this);
      }
      offAny(listener) {
        assertListener(listener);
        this.logIfDebugEnabled("unsubscribeAny", void 0, void 0);
        emitMetaEvent(this, listenerRemoved, { listener });
        anyMap.get(this).delete(listener);
      }
      clearListeners(eventNames) {
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        for (const eventName of eventNames) {
          this.logIfDebugEnabled("clear", eventName, void 0);
          if (typeof eventName === "string" || typeof eventName === "symbol" || typeof eventName === "number") {
            const set = getListeners(this, eventName);
            if (set) {
              set.clear();
            }
            const producers = getEventProducers(this, eventName);
            if (producers) {
              for (const producer of producers) {
                producer.finish();
              }
              producers.clear();
            }
          } else {
            anyMap.get(this).clear();
            for (const [eventName2, listeners] of eventsMap.get(this).entries()) {
              listeners.clear();
              eventsMap.get(this).delete(eventName2);
            }
            for (const [eventName2, producers] of producersMap.get(this).entries()) {
              for (const producer of producers) {
                producer.finish();
              }
              producers.clear();
              producersMap.get(this).delete(eventName2);
            }
          }
        }
      }
      listenerCount(eventNames) {
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        let count = 0;
        for (const eventName of eventNames) {
          if (typeof eventName === "string") {
            count += anyMap.get(this).size + (getListeners(this, eventName) || /* @__PURE__ */ new Set()).size + (getEventProducers(this, eventName) || /* @__PURE__ */ new Set()).size + (getEventProducers(this) || /* @__PURE__ */ new Set()).size;
            continue;
          }
          if (typeof eventName !== "undefined") {
            assertEventName(eventName);
          }
          count += anyMap.get(this).size;
          for (const value of eventsMap.get(this).values()) {
            count += value.size;
          }
          for (const value of producersMap.get(this).values()) {
            count += value.size;
          }
        }
        return count;
      }
      bindMethods(target, methodNames) {
        if (typeof target !== "object" || target === null) {
          throw new TypeError("`target` must be an object");
        }
        methodNames = defaultMethodNamesOrAssert(methodNames);
        for (const methodName of methodNames) {
          if (target[methodName] !== void 0) {
            throw new Error(`The property \`${methodName}\` already exists on \`target\``);
          }
          Object.defineProperty(target, methodName, {
            enumerable: false,
            value: this[methodName].bind(this)
          });
        }
      }
    };
    var allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter((v) => v !== "constructor");
    Object.defineProperty(Emittery, "listenerAdded", {
      value: listenerAdded,
      writable: false,
      enumerable: true,
      configurable: false
    });
    Object.defineProperty(Emittery, "listenerRemoved", {
      value: listenerRemoved,
      writable: false,
      enumerable: true,
      configurable: false
    });
    module.exports = Emittery;
  }
});

// ../../node_modules/human-id/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/human-id/dist/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.adverbs = exports.verbs = exports.nouns = exports.adjectives = void 0;
    exports.humanId = humanId;
    exports.poolSize = poolSize;
    exports.maxLength = maxLength;
    exports.minLength = minLength;
    exports.adjectives = ["afraid", "all", "beige", "better", "big", "blue", "bold", "brave", "breezy", "bright", "brown", "bumpy", "busy", "calm", "chatty", "chilly", "chubby", "clean", "clear", "clever", "cold", "common", "cool", "cozy", "crisp", "cuddly", "curly", "curvy", "cute", "cyan", "dark", "deep", "dirty", "dry", "dull", "eager", "early", "easy", "eight", "eighty", "eleven", "empty", "every", "fair", "famous", "fancy", "fast", "few", "fiery", "fifty", "fine", "five", "flat", "floppy", "fluffy", "forty", "four", "frank", "free", "fresh", "fruity", "full", "funky", "funny", "fuzzy", "gentle", "giant", "gold", "good", "goofy", "great", "green", "grumpy", "happy", "heavy", "hip", "honest", "hot", "huge", "humble", "hungry", "icy", "itchy", "jolly", "khaki", "kind", "large", "late", "lazy", "legal", "lemon", "light", "little", "long", "loose", "loud", "lovely", "lucky", "major", "many", "metal", "mighty", "modern", "moody", "neat", "new", "nice", "nine", "ninety", "odd", "old", "olive", "open", "orange", "perky", "petite", "pink", "plain", "plenty", "polite", "pretty", "proud", "public", "puny", "purple", "quick", "quiet", "rare", "ready", "real", "red", "rich", "ripe", "salty", "seven", "shaggy", "shaky", "sharp", "shiny", "short", "shy", "silent", "silly", "silver", "six", "sixty", "slick", "slimy", "slow", "small", "smart", "smooth", "social", "soft", "solid", "some", "sour", "sparkly", "spicy", "spotty", "stale", "strict", "strong", "sunny", "sweet", "swift", "tall", "tame", "tangy", "tasty", "ten", "tender", "thick", "thin", "thirty", "three", "tidy", "tiny", "tired", "tough", "tricky", "true", "twelve", "twenty", "two", "upset", "vast", "violet", "wacky", "warm", "wet", "whole", "wicked", "wide", "wild", "wise", "witty", "yellow", "young", "yummy"];
    exports.nouns = ["apes", "animals", "areas", "bars", "banks", "baths", "breads", "bushes", "cloths", "clowns", "clubs", "hoops", "loops", "memes", "papers", "parks", "paths", "showers", "sides", "signs", "sites", "streets", "teeth", "tires", "webs", "actors", "ads", "adults", "aliens", "ants", "apples", "baboons", "badgers", "bags", "bananas", "bats", "beans", "bears", "beds", "beers", "bees", "berries", "bikes", "birds", "boats", "bobcats", "books", "bottles", "boxes", "brooms", "buckets", "bugs", "buses", "buttons", "camels", "cases", "cameras", "candies", "candles", "carpets", "carrots", "carrots", "cars", "cats", "chairs", "chefs", "chicken", "clocks", "clouds", "coats", "cobras", "coins", "corners", "colts", "comics", "cooks", "cougars", "regions", "results", "cows", "crabs", "crabs", "crews", "cups", "cities", "cycles", "dancers", "days", "deer", "dingos", "dodos", "dogs", "dolls", "donkeys", "donuts", "doodles", "doors", "dots", "dragons", "drinks", "dryers", "ducks", "ducks", "eagles", "ears", "eels", "eggs", "ends", "mammals", "emus", "experts", "eyes", "facts", "falcons", "fans", "feet", "files", "flies", "flowers", "forks", "foxes", "friends", "frogs", "games", "garlics", "geckos", "geese", "ghosts", "ghosts", "gifts", "glasses", "goats", "grapes", "groups", "guests", "hairs", "hands", "hats", "heads", "hornets", "horses", "hotels", "hounds", "houses", "humans", "icons", "ideas", "impalas", "insects", "islands", "items", "jars", "jeans", "jobs", "jokes", "keys", "kids", "kings", "kiwis", "knives", "lamps", "lands", "laws", "lemons", "lies", "lights", "lines", "lions", "lizards", "llamas", "mails", "mangos", "maps", "masks", "meals", "melons", "mice", "mirrors", "moments", "moles", "monkeys", "months", "moons", "moose", "mugs", "nails", "needles", "news", "nights", "numbers", "olives", "onions", "oranges", "otters", "owls", "pandas", "pans", "pants", "papayas", "parents", "parts", "parrots", "paws", "peaches", "pears", "peas", "pens", "pets", "phones", "pianos", "pigs", "pillows", "places", "planes", "planets", "plants", "plums", "poems", "poets", "points", "pots", "pugs", "pumas", "queens", "rabbits", "radios", "rats", "ravens", "readers", "rice", "rings", "rivers", "rockets", "rocks", "rooms", "roses", "rules", "schools", "bats", "seals", "seas", "sheep", "shirts", "shoes", "shrimps", "singers", "sloths", "snails", "snakes", "socks", "spiders", "spies", "spoons", "squids", "stamps", "stars", "states", "steaks", "suits", "suns", "swans", "symbols", "tables", "taxes", "taxis", "teams", "terms", "things", "ties", "tigers", "times", "tips", "toes", "towns", "tools", "toys", "trains", "trams", "trees", "turkeys", "turtles", "vans", "views", "walls", "walls", "wasps", "waves", "ways", "weeks", "windows", "wings", "wolves", "wombats", "words", "worlds", "worms", "yaks", "years", "zebras", "zoos"];
    exports.verbs = ["accept", "act", "add", "admire", "agree", "allow", "appear", "argue", "arrive", "ask", "attack", "attend", "bake", "bathe", "battle", "beam", "beg", "begin", "behave", "bet", "boil", "bow", "brake", "brush", "build", "burn", "buy", "call", "camp", "care", "carry", "change", "cheat", "check", "cheer", "chew", "clap", "clean", "cough", "count", "cover", "crash", "create", "cross", "cry", "cut", "dance", "decide", "deny", "design", "dig", "divide", "do", "double", "doubt", "draw", "dream", "dress", "drive", "drop", "drum", "eat", "end", "enter", "enjoy", "exist", "fail", "fall", "feel", "fetch", "film", "find", "fix", "flash", "float", "flow", "fly", "fold", "follow", "fry", "give", "glow", "go", "grab", "greet", "grin", "grow", "guess", "hammer", "hang", "happen", "heal", "hear", "help", "hide", "hope", "hug", "hunt", "invent", "invite", "itch", "jam", "jog", "join", "joke", "judge", "juggle", "jump", "kick", "kiss", "kneel", "knock", "know", "laugh", "lay", "lead", "learn", "leave", "lick", "like", "lie", "listen", "live", "look", "lose", "love", "make", "march", "marry", "mate", "matter", "melt", "mix", "move", "nail", "notice", "obey", "occur", "open", "own", "pay", "peel", "play", "poke", "post", "press", "prove", "pull", "pump", "pick", "punch", "push", "raise", "read", "refuse", "relate", "relax", "remain", "repair", "repeat", "reply", "report", "rescue", "rest", "retire", "return", "rhyme", "ring", "roll", "rule", "run", "rush", "say", "scream", "see", "search", "sell", "send", "serve", "shake", "share", "shave", "shine", "show", "shop", "shout", "sin", "sink", "sing", "sip", "sit", "sleep", "slide", "smash", "smell", "smile", "smoke", "sneeze", "sniff", "sort", "speak", "spend", "stand", "start", "stay", "stick", "stop", "stare", "study", "strive", "swim", "switch", "take", "talk", "tan", "tap", "taste", "teach", "tease", "tell", "thank", "think", "throw", "tickle", "tie", "trade", "train", "travel", "try", "turn", "type", "unite", "vanish", "visit", "wait", "walk", "warn", "wash", "watch", "wave", "wear", "win", "wink", "wish", "wonder", "work", "worry", "write", "yawn", "yell"];
    exports.adverbs = ["bravely", "brightly", "busily", "daily", "freely", "hungrily", "joyously", "knowlingly", "lazily", "oddly", "mysteriously", "noisily", "politely", "quickly", "quietly", "rapidly", "safely", "sleepily", "slowly", "truly", "yearly"];
    function random(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    __name(random, "random");
    function longest(arr) {
      return arr.reduce(function(a, b) {
        return a.length > b.length ? a : b;
      });
    }
    __name(longest, "longest");
    function shortest(arr) {
      return arr.reduce(function(a, b) {
        return a.length < b.length ? a : b;
      });
    }
    __name(shortest, "shortest");
    function humanId(options) {
      if (options === void 0) {
        options = {};
      }
      if (typeof options === "string")
        options = { separator: options };
      if (typeof options === "boolean")
        options = { capitalize: options };
      var _a = options.separator, separator = _a === void 0 ? "" : _a, _b = options.capitalize, capitalize = _b === void 0 ? true : _b, _c = options.adjectiveCount, adjectiveCount = _c === void 0 ? 1 : _c, _d = options.addAdverb, addAdverb = _d === void 0 ? false : _d;
      var res = __spreadArray(__spreadArray(__spreadArray([], __spreadArray([], Array(adjectiveCount), true).map(function(_) {
        return random(exports.adjectives);
      }), true), [
        random(exports.nouns),
        random(exports.verbs)
      ], false), addAdverb ? [random(exports.adverbs)] : [], true);
      if (capitalize)
        res = res.map(function(r) {
          return r.charAt(0).toUpperCase() + r.substr(1);
        });
      return res.join(separator);
    }
    __name(humanId, "humanId");
    function poolSize(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.adjectiveCount, adjectiveCount = _a === void 0 ? 1 : _a, _b = options.addAdverb, addAdverb = _b === void 0 ? false : _b;
      return exports.adjectives.length * adjectiveCount * exports.nouns.length * exports.verbs.length * (addAdverb ? exports.adverbs.length : 1);
    }
    __name(poolSize, "poolSize");
    function maxLength(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.adjectiveCount, adjectiveCount = _a === void 0 ? 1 : _a, _b = options.addAdverb, addAdverb = _b === void 0 ? false : _b, _c = options.separator, separator = _c === void 0 ? "" : _c;
      return longest(exports.adjectives).length * adjectiveCount + adjectiveCount * separator.length + longest(exports.nouns).length + separator.length + longest(exports.verbs).length + (addAdverb ? longest(exports.adverbs).length + separator.length : 0);
    }
    __name(maxLength, "maxLength");
    function minLength(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.adjectiveCount, adjectiveCount = _a === void 0 ? 1 : _a, _b = options.addAdverb, addAdverb = _b === void 0 ? false : _b, _c = options.separator, separator = _c === void 0 ? "" : _c;
      return shortest(exports.adjectives).length * adjectiveCount + adjectiveCount * separator.length + shortest(exports.nouns).length + separator.length + shortest(exports.verbs).length + (addAdverb ? shortest(exports.adverbs).length + separator.length : 0);
    }
    __name(minLength, "minLength");
    exports.default = humanId;
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/websocket/events.js
var require_events2 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/websocket/events.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CloseEvent = exports.ErrorEvent = exports.Event = void 0;
    var Event = class {
      static {
        __name(this, "Event");
      }
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    exports.Event = Event;
    var ErrorEvent = class extends Event {
      static {
        __name(this, "ErrorEvent");
      }
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    exports.ErrorEvent = ErrorEvent;
    var CloseEvent = class extends Event {
      static {
        __name(this, "CloseEvent");
      }
      constructor(code = 1e3, reason = "", target) {
        super("close", target);
        this.wasClean = true;
        this.code = code;
        this.reason = reason;
      }
    };
    exports.CloseEvent = CloseEvent;
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/websocket/ws.js
var require_ws = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/websocket/ws.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReconnectingWebSocket = void 0;
    var runtime_1 = require_runtime2();
    var Events = __importStar(require_events2());
    var ws_1 = require_browser();
    var getGlobalWebSocket = /* @__PURE__ */ __name(() => {
      if (typeof WebSocket !== "undefined") {
        return WebSocket;
      }
      if (runtime_1.RUNTIME.type === "node") {
        return ws_1.WebSocket;
      }
      return void 0;
    }, "getGlobalWebSocket");
    var isWebSocket = /* @__PURE__ */ __name((w) => typeof w !== "undefined" && !!w && w.CLOSING === 2, "isWebSocket");
    var DEFAULT = {
      maxReconnectionDelay: 1e4,
      minReconnectionDelay: 1e3 + Math.random() * 4e3,
      minUptime: 5e3,
      reconnectionDelayGrowFactor: 1.3,
      connectionTimeout: 4e3,
      maxRetries: Infinity,
      maxEnqueuedMessages: Infinity,
      startClosed: false,
      debug: false
    };
    var ReconnectingWebSocket = class _ReconnectingWebSocket {
      static {
        __name(this, "ReconnectingWebSocket");
      }
      constructor(url, protocols, options = {}) {
        this._listeners = {
          error: [],
          message: [],
          open: [],
          close: []
        };
        this._retryCount = -1;
        this._shouldReconnect = true;
        this._connectLock = false;
        this._binaryType = "blob";
        this._closeCalled = false;
        this._messageQueue = [];
        this.onclose = null;
        this.onerror = null;
        this.onmessage = null;
        this.onopen = null;
        this._handleOpen = (event) => {
          this._debug("open event");
          const { minUptime = DEFAULT.minUptime } = this._options;
          clearTimeout(this._connectTimeout);
          this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);
          this._ws.binaryType = this._binaryType;
          this._messageQueue.forEach((message) => {
            var _a;
            return (_a = this._ws) === null || _a === void 0 ? void 0 : _a.send(message);
          });
          this._messageQueue = [];
          if (this.onopen) {
            this.onopen(event);
          }
          this._listeners.open.forEach((listener) => this._callEventListener(event, listener));
        };
        this._handleMessage = (event) => {
          this._debug("message event");
          if (this.onmessage) {
            this.onmessage(event);
          }
          this._listeners.message.forEach((listener) => this._callEventListener(event, listener));
        };
        this._handleError = (event) => {
          this._debug("error event", event.message);
          this._disconnect(void 0, event.message === "TIMEOUT" ? "timeout" : void 0);
          if (this.onerror) {
            this.onerror(event);
          }
          this._debug("exec error listeners");
          this._listeners.error.forEach((listener) => this._callEventListener(event, listener));
          this._connect();
        };
        this._handleClose = (event) => {
          this._debug("close event");
          this._clearTimeouts();
          if (event.code === 1e3) {
            this._shouldReconnect = false;
          }
          if (this._shouldReconnect) {
            this._connect();
          }
          if (this.onclose) {
            this.onclose(event);
          }
          this._listeners.close.forEach((listener) => this._callEventListener(event, listener));
        };
        this._url = url;
        this._protocols = protocols;
        this._options = options;
        if (this._options.startClosed) {
          this._shouldReconnect = false;
        }
        this._connect();
      }
      static get CONNECTING() {
        return 0;
      }
      static get OPEN() {
        return 1;
      }
      static get CLOSING() {
        return 2;
      }
      static get CLOSED() {
        return 3;
      }
      get CONNECTING() {
        return _ReconnectingWebSocket.CONNECTING;
      }
      get OPEN() {
        return _ReconnectingWebSocket.OPEN;
      }
      get CLOSING() {
        return _ReconnectingWebSocket.CLOSING;
      }
      get CLOSED() {
        return _ReconnectingWebSocket.CLOSED;
      }
      get binaryType() {
        return this._ws ? this._ws.binaryType : this._binaryType;
      }
      set binaryType(value) {
        this._binaryType = value;
        if (this._ws) {
          this._ws.binaryType = value;
        }
      }
      /**
       * Returns the number or connection retries
       */
      get retryCount() {
        return Math.max(this._retryCount, 0);
      }
      /**
       * The number of bytes of data that have been queued using calls to send() but not yet
       * transmitted to the network. This value resets to zero once all queued data has been sent.
       * This value does not reset to zero when the connection is closed; if you keep calling send(),
       * this will continue to climb. Read only
       */
      get bufferedAmount() {
        const bytes = this._messageQueue.reduce((acc, message) => {
          if (typeof message === "string") {
            acc += message.length;
          } else if (message instanceof Blob) {
            acc += message.size;
          } else {
            acc += message.byteLength;
          }
          return acc;
        }, 0);
        return bytes + (this._ws ? this._ws.bufferedAmount : 0);
      }
      /**
       * The extensions selected by the server. This is currently only the empty string or a list of
       * extensions as negotiated by the connection
       */
      get extensions() {
        return this._ws ? this._ws.extensions : "";
      }
      /**
       * A string indicating the name of the sub-protocol the server selected;
       * this will be one of the strings specified in the protocols parameter when creating the
       * WebSocket object
       */
      get protocol() {
        return this._ws ? this._ws.protocol : "";
      }
      /**
       * The current state of the connection; this is one of the Ready state constants
       */
      get readyState() {
        if (this._ws) {
          return this._ws.readyState;
        }
        return this._options.startClosed ? _ReconnectingWebSocket.CLOSED : _ReconnectingWebSocket.CONNECTING;
      }
      /**
       * The URL as resolved by the constructor
       */
      get url() {
        return this._ws ? this._ws.url : "";
      }
      /**
       * Closes the WebSocket connection or connection attempt, if any. If the connection is already
       * CLOSED, this method does nothing
       */
      close(code = 1e3, reason) {
        this._closeCalled = true;
        this._shouldReconnect = false;
        this._clearTimeouts();
        if (!this._ws) {
          this._debug("close enqueued: no ws instance");
          return;
        }
        if (this._ws.readyState === this.CLOSED) {
          this._debug("close: already closed");
          return;
        }
        this._ws.close(code, reason);
      }
      /**
       * Closes the WebSocket connection or connection attempt and connects again.
       * Resets retry counter;
       */
      reconnect(code, reason) {
        this._shouldReconnect = true;
        this._closeCalled = false;
        this._retryCount = -1;
        if (!this._ws || this._ws.readyState === this.CLOSED) {
          this._connect();
        } else {
          this._disconnect(code, reason);
          this._connect();
        }
      }
      /**
       * Enqueue specified data to be transmitted to the server over the WebSocket connection
       */
      send(data) {
        if (this._ws && this._ws.readyState === this.OPEN) {
          this._debug("send", data);
          this._ws.send(data);
        } else {
          const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } = this._options;
          if (this._messageQueue.length < maxEnqueuedMessages) {
            this._debug("enqueue", data);
            this._messageQueue.push(data);
          }
        }
      }
      /**
       * Register an event handler of a specific event type
       */
      addEventListener(type, listener) {
        if (this._listeners[type]) {
          this._listeners[type].push(listener);
        }
      }
      dispatchEvent(event) {
        const listeners = this._listeners[event.type];
        if (listeners) {
          for (const listener of listeners) {
            this._callEventListener(event, listener);
          }
        }
        return true;
      }
      /**
       * Removes an event listener
       */
      removeEventListener(type, listener) {
        if (this._listeners[type]) {
          this._listeners[type] = this._listeners[type].filter(
            // @ts-ignore
            (l) => l !== listener
          );
        }
      }
      _debug(...args) {
        if (this._options.debug) {
          console.log.apply(console, ["RWS>", ...args]);
        }
      }
      _getNextDelay() {
        const { reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor, minReconnectionDelay = DEFAULT.minReconnectionDelay, maxReconnectionDelay = DEFAULT.maxReconnectionDelay } = this._options;
        let delay = 0;
        if (this._retryCount > 0) {
          delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
          if (delay > maxReconnectionDelay) {
            delay = maxReconnectionDelay;
          }
        }
        this._debug("next delay", delay);
        return delay;
      }
      _wait() {
        return new Promise((resolve) => {
          setTimeout(resolve, this._getNextDelay());
        });
      }
      _getNextUrl(urlProvider) {
        if (typeof urlProvider === "string") {
          return Promise.resolve(urlProvider);
        }
        if (typeof urlProvider === "function") {
          const url = urlProvider();
          if (typeof url === "string") {
            return Promise.resolve(url);
          }
          if (url.then) {
            return url;
          }
        }
        throw Error("Invalid URL");
      }
      _connect() {
        if (this._connectLock || !this._shouldReconnect) {
          return;
        }
        this._connectLock = true;
        const { maxRetries = DEFAULT.maxRetries, connectionTimeout = DEFAULT.connectionTimeout, WebSocket: WebSocket2 = getGlobalWebSocket() } = this._options;
        if (this._retryCount >= maxRetries) {
          this._debug("max retries reached", this._retryCount, ">=", maxRetries);
          return;
        }
        this._retryCount++;
        this._debug("connect", this._retryCount);
        this._removeListeners();
        if (!isWebSocket(WebSocket2)) {
          throw Error("No valid WebSocket class provided");
        }
        this._wait().then(() => this._getNextUrl(this._url)).then((url) => {
          if (this._closeCalled) {
            return;
          }
          this._debug("connect", { url, protocols: this._protocols });
          this._ws = this._protocols ? new WebSocket2(url, this._protocols) : new WebSocket2(url);
          this._ws.binaryType = this._binaryType;
          this._connectLock = false;
          this._addListeners();
          this._connectTimeout = setTimeout(() => this._handleTimeout(), connectionTimeout);
        });
      }
      _handleTimeout() {
        this._debug("timeout event");
        this._handleError(new Events.ErrorEvent(Error("TIMEOUT"), this));
      }
      _disconnect(code = 1e3, reason) {
        this._clearTimeouts();
        if (!this._ws) {
          return;
        }
        this._removeListeners();
        try {
          this._ws.close(code, reason);
          this._handleClose(new Events.CloseEvent(code, reason, this));
        } catch (error) {
        }
      }
      _acceptOpen() {
        this._debug("accept open");
        this._retryCount = 0;
      }
      _callEventListener(event, listener) {
        if ("handleEvent" in listener) {
          listener.handleEvent(event);
        } else {
          listener(event);
        }
      }
      _removeListeners() {
        if (!this._ws) {
          return;
        }
        this._debug("removeListeners");
        this._ws.removeEventListener("open", this._handleOpen);
        this._ws.removeEventListener("close", this._handleClose);
        this._ws.removeEventListener("message", this._handleMessage);
        this._ws.removeEventListener("error", this._handleError);
      }
      _addListeners() {
        if (!this._ws) {
          return;
        }
        this._debug("addListeners");
        this._ws.addEventListener("open", this._handleOpen);
        this._ws.addEventListener("close", this._handleClose);
        this._ws.addEventListener("message", this._handleMessage);
        this._ws.addEventListener("error", this._handleError);
      }
      _clearTimeouts() {
        clearTimeout(this._connectTimeout);
        clearTimeout(this._uptimeTimeout);
      }
    };
    exports.ReconnectingWebSocket = ReconnectingWebSocket;
  }
});

// ../../node_modules/@cartesia/cartesia-js/core/websocket/index.js
var require_websocket = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/core/websocket/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ws(), exports);
  }
});

// ../../node_modules/@cartesia/cartesia-js/wrapper/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/wrapper/utils.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ENCODING_MAP = void 0;
    exports.resolveOutputFormat = resolveOutputFormat;
    exports.base64ToArray = base64ToArray;
    exports.playAudioBuffer = playAudioBuffer;
    exports.createMessageHandlerForContextId = createMessageHandlerForContextId;
    exports.getSentinel = getSentinel;
    exports.isSentinel = isSentinel;
    exports.filterSentinel = filterSentinel;
    exports.isComplete = isComplete;
    exports.getEmitteryCallbacks = getEmitteryCallbacks;
    var base64_js_1 = __importDefault(require_base64_js());
    exports.ENCODING_MAP = {
      pcm_f32le: { arrayType: Float32Array, bytesPerElement: 4 },
      pcm_s16le: { arrayType: Int16Array, bytesPerElement: 2 },
      pcm_alaw: { arrayType: Uint8Array, bytesPerElement: 1 },
      pcm_mulaw: { arrayType: Uint8Array, bytesPerElement: 1 }
    };
    function resolveOutputFormat(container, encoding, sampleRate) {
      switch (container) {
        case "wav":
          return {
            container: "wav",
            encoding,
            sampleRate
          };
        case "raw":
          return {
            container: "raw",
            encoding,
            sampleRate
          };
        case "mp3":
          return {
            container: "mp3",
            encoding,
            sampleRate,
            bitRate: 128
          };
        default:
          throw new Error(`Unsupported container type: ${container}`);
      }
    }
    __name(resolveOutputFormat, "resolveOutputFormat");
    function base64ToArray(b64, encoding) {
      const byteArrays = filterSentinel(b64).map((b) => base64_js_1.default.toByteArray(b));
      const { arrayType: ArrayType, bytesPerElement } = exports.ENCODING_MAP[encoding];
      const totalLength = byteArrays.reduce((acc, arr) => acc + arr.length / bytesPerElement, 0);
      const result = new ArrayType(totalLength);
      let offset = 0;
      for (const arr of byteArrays) {
        const floats = new ArrayType(arr.buffer);
        result.set(floats, offset);
        offset += floats.length;
      }
      return result;
    }
    __name(base64ToArray, "base64ToArray");
    function playAudioBuffer(floats, context, startAt, sampleRate) {
      const source = context.createBufferSource();
      const buffer = context.createBuffer(1, floats.length, sampleRate);
      buffer.getChannelData(0).set(floats);
      source.buffer = buffer;
      source.connect(context.destination);
      source.start(startAt);
      return new Promise((resolve) => {
        source.onended = () => {
          resolve();
        };
      });
    }
    __name(playAudioBuffer, "playAudioBuffer");
    function createMessageHandlerForContextId(contextId, handler) {
      return (event) => {
        if (typeof event.data !== "string") {
          return;
        }
        const message = JSON.parse(event.data);
        if (message.context_id !== contextId) {
          return;
        }
        let chunk;
        if (message.done) {
          chunk = getSentinel();
        } else if (message.type === "chunk") {
          chunk = message.data;
        }
        handler({ chunk, message: event.data, data: message });
      };
    }
    __name(createMessageHandlerForContextId, "createMessageHandlerForContextId");
    function getSentinel() {
      return null;
    }
    __name(getSentinel, "getSentinel");
    function isSentinel(x) {
      return x === getSentinel();
    }
    __name(isSentinel, "isSentinel");
    function filterSentinel(collection) {
      return collection.filter((x) => !isSentinel(x));
    }
    __name(filterSentinel, "filterSentinel");
    function isComplete(chunks) {
      return isSentinel(chunks[chunks.length - 1]);
    }
    __name(isComplete, "isComplete");
    function getEmitteryCallbacks(emitter) {
      return {
        on: emitter.on.bind(emitter),
        off: emitter.off.bind(emitter),
        once: emitter.once.bind(emitter),
        events: emitter.events.bind(emitter)
      };
    }
    __name(getEmitteryCallbacks, "getEmitteryCallbacks");
  }
});

// ../../node_modules/@cartesia/cartesia-js/wrapper/source.js
var require_source = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/wrapper/source.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _Source_instances;
    var _Source_emitter;
    var _Source_buffer;
    var _Source_readIndex;
    var _Source_writeIndex;
    var _Source_closed;
    var _Source_sampleRate;
    var _Source_encoding;
    var _Source_container;
    var _Source_createBuffer;
    Object.defineProperty(exports, "__esModule", { value: true });
    var emittery_1 = __importDefault(require_emittery());
    var utils_1 = require_utils3();
    var Source = class {
      static {
        __name(this, "Source");
      }
      /**
       * Create a new Source.
       *
       * @param options - Options for the Source.
       * @param options.sampleRate - The sample rate of the audio.
       */
      constructor({ sampleRate, encoding, container }) {
        _Source_instances.add(this);
        _Source_emitter.set(this, new emittery_1.default());
        _Source_buffer.set(this, void 0);
        _Source_readIndex.set(this, 0);
        _Source_writeIndex.set(this, 0);
        _Source_closed.set(this, false);
        _Source_sampleRate.set(this, void 0);
        _Source_encoding.set(this, void 0);
        _Source_container.set(this, void 0);
        this.on = __classPrivateFieldGet(this, _Source_emitter, "f").on.bind(__classPrivateFieldGet(this, _Source_emitter, "f"));
        this.once = __classPrivateFieldGet(this, _Source_emitter, "f").once.bind(__classPrivateFieldGet(this, _Source_emitter, "f"));
        this.events = __classPrivateFieldGet(this, _Source_emitter, "f").events.bind(__classPrivateFieldGet(this, _Source_emitter, "f"));
        this.off = __classPrivateFieldGet(this, _Source_emitter, "f").off.bind(__classPrivateFieldGet(this, _Source_emitter, "f").off);
        __classPrivateFieldSet(this, _Source_sampleRate, sampleRate, "f");
        __classPrivateFieldSet(this, _Source_encoding, encoding, "f");
        __classPrivateFieldSet(this, _Source_container, container, "f");
        __classPrivateFieldSet(this, _Source_buffer, __classPrivateFieldGet(this, _Source_instances, "m", _Source_createBuffer).call(this, 1024), "f");
      }
      get sampleRate() {
        return __classPrivateFieldGet(this, _Source_sampleRate, "f");
      }
      get encoding() {
        return __classPrivateFieldGet(this, _Source_encoding, "f");
      }
      get container() {
        return __classPrivateFieldGet(this, _Source_container, "f");
      }
      /**
       * Append audio to the buffer.
       *
       * @param src The audio to append.
       */
      enqueue(src) {
        return __awaiter11(this, void 0, void 0, function* () {
          const requiredCapacity = __classPrivateFieldGet(this, _Source_writeIndex, "f") + src.length;
          if (requiredCapacity > __classPrivateFieldGet(this, _Source_buffer, "f").length) {
            let newCapacity = __classPrivateFieldGet(this, _Source_buffer, "f").length;
            while (newCapacity < requiredCapacity) {
              newCapacity *= 2;
            }
            const newBuffer = __classPrivateFieldGet(this, _Source_instances, "m", _Source_createBuffer).call(this, newCapacity);
            newBuffer.set(__classPrivateFieldGet(this, _Source_buffer, "f"));
            __classPrivateFieldSet(this, _Source_buffer, newBuffer, "f");
          }
          __classPrivateFieldGet(this, _Source_buffer, "f").set(src, __classPrivateFieldGet(this, _Source_writeIndex, "f"));
          __classPrivateFieldSet(this, _Source_writeIndex, __classPrivateFieldGet(this, _Source_writeIndex, "f") + src.length, "f");
          yield __classPrivateFieldGet(this, _Source_emitter, "f").emit("enqueue");
        });
      }
      /**
       * Read audio from the buffer.
       *
       * @param dst The buffer to read the audio into.
       * @returns The number of samples read. If the source is closed, this will be
       * less than the length of the provided buffer.
       */
      read(dst) {
        return __awaiter11(this, void 0, void 0, function* () {
          const targetReadIndex = __classPrivateFieldGet(this, _Source_readIndex, "f") + dst.length;
          while (!__classPrivateFieldGet(this, _Source_closed, "f") && targetReadIndex > __classPrivateFieldGet(this, _Source_writeIndex, "f")) {
            yield __classPrivateFieldGet(this, _Source_emitter, "f").emit("wait");
            yield Promise.race([__classPrivateFieldGet(this, _Source_emitter, "f").once("enqueue"), __classPrivateFieldGet(this, _Source_emitter, "f").once("close")]);
            yield __classPrivateFieldGet(this, _Source_emitter, "f").emit("read");
          }
          const read = Math.min(dst.length, __classPrivateFieldGet(this, _Source_writeIndex, "f") - __classPrivateFieldGet(this, _Source_readIndex, "f"));
          dst.set(__classPrivateFieldGet(this, _Source_buffer, "f").subarray(__classPrivateFieldGet(this, _Source_readIndex, "f"), __classPrivateFieldGet(this, _Source_readIndex, "f") + read));
          __classPrivateFieldSet(this, _Source_readIndex, __classPrivateFieldGet(this, _Source_readIndex, "f") + read, "f");
          return read;
        });
      }
      /**
       * Seek in the buffer.
       *
       * @param offset The offset to seek to.
       * @param whence The position to seek from.
       * @returns The new position in the buffer.
       * @throws {Error} If the seek is invalid.
       */
      seek(offset, whence) {
        return __awaiter11(this, void 0, void 0, function* () {
          let position = __classPrivateFieldGet(this, _Source_readIndex, "f");
          switch (whence) {
            case "start":
              position = offset;
              break;
            case "current":
              position += offset;
              break;
            case "end":
              position = __classPrivateFieldGet(this, _Source_writeIndex, "f") + offset;
              break;
            default:
              throw new Error(`Invalid seek mode: ${whence}`);
          }
          if (position < 0 || position > __classPrivateFieldGet(this, _Source_writeIndex, "f")) {
            throw new Error("Seek out of bounds");
          }
          __classPrivateFieldSet(this, _Source_readIndex, position, "f");
          return position;
        });
      }
      /**
       * Get the number of samples in a given duration.
       *
       * @param durationSecs The duration in seconds.
       * @returns The number of samples.
       */
      durationToSampleCount(durationSecs) {
        return Math.trunc(durationSecs * __classPrivateFieldGet(this, _Source_sampleRate, "f"));
      }
      get buffer() {
        return __classPrivateFieldGet(this, _Source_buffer, "f");
      }
      get readIndex() {
        return __classPrivateFieldGet(this, _Source_readIndex, "f");
      }
      get writeIndex() {
        return __classPrivateFieldGet(this, _Source_writeIndex, "f");
      }
      /**
       * Close the source. This signals that no more audio will be enqueued.
       *
       * This will emit a "close" event.
       *
       * @returns A promise that resolves when the source is closed.
       */
      close() {
        return __awaiter11(this, void 0, void 0, function* () {
          __classPrivateFieldSet(this, _Source_closed, true, "f");
          yield __classPrivateFieldGet(this, _Source_emitter, "f").emit("close");
          __classPrivateFieldGet(this, _Source_emitter, "f").clearListeners();
        });
      }
    };
    _Source_emitter = /* @__PURE__ */ new WeakMap(), _Source_buffer = /* @__PURE__ */ new WeakMap(), _Source_readIndex = /* @__PURE__ */ new WeakMap(), _Source_writeIndex = /* @__PURE__ */ new WeakMap(), _Source_closed = /* @__PURE__ */ new WeakMap(), _Source_sampleRate = /* @__PURE__ */ new WeakMap(), _Source_encoding = /* @__PURE__ */ new WeakMap(), _Source_container = /* @__PURE__ */ new WeakMap(), _Source_instances = /* @__PURE__ */ new WeakSet(), _Source_createBuffer = /* @__PURE__ */ __name(function _Source_createBuffer2(size) {
      const { arrayType: ArrayType } = utils_1.ENCODING_MAP[__classPrivateFieldGet(this, _Source_encoding, "f")];
      return new ArrayType(size);
    }, "_Source_createBuffer");
    exports.default = Source;
  }
});

// ../../node_modules/@cartesia/cartesia-js/wrapper/Websocket.js
var require_Websocket = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/wrapper/Websocket.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _Websocket_instances;
    var _Websocket_isConnected;
    var _Websocket_sampleRate;
    var _Websocket_container;
    var _Websocket_encoding;
    var _Websocket_connectionPromise;
    var _Websocket_ensureConnected;
    var _Websocket_generateId;
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = __importStar(require_core());
    var environments = __importStar(require_environments());
    var serializers = __importStar(require_serialization());
    var emittery_1 = __importDefault(require_emittery());
    var human_id_1 = require_dist();
    var websocket_1 = require_websocket();
    var utils_1 = require_utils3();
    var source_1 = __importDefault(require_source());
    var qs_1 = __importDefault(require_lib());
    var Websocket = class {
      static {
        __name(this, "Websocket");
      }
      constructor({ sampleRate, container, encoding }, options) {
        _Websocket_instances.add(this);
        this.options = options;
        _Websocket_isConnected.set(this, false);
        _Websocket_sampleRate.set(this, void 0);
        _Websocket_container.set(this, void 0);
        _Websocket_encoding.set(this, void 0);
        _Websocket_connectionPromise.set(this, void 0);
        __classPrivateFieldSet(this, _Websocket_sampleRate, sampleRate, "f");
        __classPrivateFieldSet(this, _Websocket_container, container !== null && container !== void 0 ? container : "raw", "f");
        __classPrivateFieldSet(this, _Websocket_encoding, encoding !== null && encoding !== void 0 ? encoding : "pcm_f32le", "f");
      }
      /**
       * Send a message over the WebSocket to start a stream.
       *
       * @param inputs - Generation parameters. Defined in the StreamRequest type.
       * @param options - Options for the stream.
       * @param options.timeout - The maximum time to wait for a chunk before cancelling the stream.
       *                          If set to `0`, the stream will not time out.
       * @returns A Source object that can be passed to a Player to play the audio.
       * @returns An Emittery instance that emits messages from the WebSocket.
       */
      send(inputs_1) {
        return __awaiter11(this, arguments, void 0, function* (inputs, { timeout = 0 } = {}) {
          var _a, _b, _c, _d;
          yield __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_ensureConnected).call(this);
          if (!inputs.contextId) {
            inputs.contextId = __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_generateId).call(this);
          }
          if (!inputs.outputFormat) {
            inputs.outputFormat = (0, utils_1.resolveOutputFormat)(__classPrivateFieldGet(this, _Websocket_container, "f"), __classPrivateFieldGet(this, _Websocket_encoding, "f"), __classPrivateFieldGet(this, _Websocket_sampleRate, "f"));
          }
          (_a = this.socket) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify(serializers.WebSocketTtsRequest.jsonOrThrow(inputs, { unrecognizedObjectKeys: "strip" })));
          const emitter = new emittery_1.default();
          const source = new source_1.default({
            sampleRate: __classPrivateFieldGet(this, _Websocket_sampleRate, "f"),
            encoding: __classPrivateFieldGet(this, _Websocket_encoding, "f"),
            container: __classPrivateFieldGet(this, _Websocket_container, "f")
          });
          const streamCompleteController = new AbortController();
          let timeoutId = null;
          if (timeout > 0) {
            timeoutId = setTimeout(streamCompleteController.abort, timeout);
          }
          const handleMessage = (0, utils_1.createMessageHandlerForContextId)(inputs.contextId, (_a2) => __awaiter11(this, [_a2], void 0, function* ({ chunk, message, data }) {
            emitter.emit("message", message);
            if (data.type === "timestamps" && data.wordTimestamps) {
              emitter.emit("timestamps", data.wordTimestamps);
              return;
            }
            if ((0, utils_1.isSentinel)(chunk)) {
              yield source.close();
              streamCompleteController.abort();
              return;
            }
            if (timeoutId) {
              clearTimeout(timeoutId);
              timeoutId = setTimeout(streamCompleteController.abort, timeout);
            }
            if (!chunk) {
              return;
            }
            yield source.enqueue((0, utils_1.base64ToArray)([chunk], __classPrivateFieldGet(this, _Websocket_encoding, "f")));
          }));
          (_b = this.socket) === null || _b === void 0 ? void 0 : _b.addEventListener("message", handleMessage);
          (_c = this.socket) === null || _c === void 0 ? void 0 : _c.addEventListener("close", () => {
            streamCompleteController.abort();
          });
          (_d = this.socket) === null || _d === void 0 ? void 0 : _d.addEventListener("error", () => {
            streamCompleteController.abort();
          });
          streamCompleteController.signal.addEventListener("abort", () => {
            source.close();
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            emitter.clearListeners();
          });
          return Object.assign(Object.assign({ source }, (0, utils_1.getEmitteryCallbacks)(emitter)), { stop: streamCompleteController.abort.bind(streamCompleteController) });
        });
      }
      continue(inputs) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a;
          yield __classPrivateFieldGet(this, _Websocket_instances, "m", _Websocket_ensureConnected).call(this);
          if (!inputs.contextId) {
            throw new Error("context_id is required to continue a context.");
          }
          if (!inputs.outputFormat) {
            inputs.outputFormat = (0, utils_1.resolveOutputFormat)(__classPrivateFieldGet(this, _Websocket_container, "f"), __classPrivateFieldGet(this, _Websocket_encoding, "f"), __classPrivateFieldGet(this, _Websocket_sampleRate, "f"));
          }
          (_a = this.socket) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify(Object.assign({ continue: true }, serializers.WebSocketTtsRequest.jsonOrThrow(inputs, { unrecognizedObjectKeys: "strip" }))));
        });
      }
      /**
       * Authenticate and connect to a Cartesia streaming WebSocket.
       *
       * @returns A promise that resolves when the WebSocket is connected.
       * @throws {Error} If the WebSocket fails to connect.
       */
      connect() {
        return __awaiter11(this, arguments, void 0, function* (options = {}) {
          if (__classPrivateFieldGet(this, _Websocket_isConnected, "f")) {
            throw new Error("WebSocket is already connected.");
          }
          const emitter = new emittery_1.default();
          this.socket = new websocket_1.ReconnectingWebSocket(() => __awaiter11(this, void 0, void 0, function* () {
            var _a;
            const baseUrl = ((_a = yield core.Supplier.get(this.options.environment)) !== null && _a !== void 0 ? _a : environments.CartesiaEnvironment.Production).replace(/^https?:\/\//, "");
            const params = {
              cartesia_version: this.options.cartesiaVersion || "2025-04-16"
            };
            const apiKey = yield core.Supplier.get(this.options.apiKey);
            if (apiKey) {
              params.api_key = apiKey;
            } else if (options.accessToken) {
              params.access_token = options.accessToken;
            }
            return `wss://${baseUrl}/tts/websocket${qs_1.default.stringify(params, { addQueryPrefix: true })}`;
          }), void 0, options);
          this.socket.reconnect();
          this.socket.onopen = () => {
            __classPrivateFieldSet(this, _Websocket_isConnected, true, "f");
            emitter.emit("open");
          };
          this.socket.onclose = () => {
            __classPrivateFieldSet(this, _Websocket_isConnected, false, "f");
            emitter.emit("close");
          };
          return new Promise((resolve, reject) => {
            var _a, _b, _c;
            (_a = this.socket) === null || _a === void 0 ? void 0 : _a.addEventListener("open", () => {
              resolve((0, utils_1.getEmitteryCallbacks)(emitter));
            });
            const aborter = new AbortController();
            (_b = this.socket) === null || _b === void 0 ? void 0 : _b.addEventListener("error", () => {
              aborter.abort();
              reject(new Error("WebSocket failed to connect."));
            });
            (_c = this.socket) === null || _c === void 0 ? void 0 : _c.addEventListener("close", () => {
              aborter.abort();
              reject(new Error("WebSocket closed before it could connect."));
            });
          });
        });
      }
      /**
       * Disconnect from the Cartesia streaming WebSocket.
       */
      disconnect() {
        var _a;
        (_a = this.socket) === null || _a === void 0 ? void 0 : _a.close();
      }
    };
    _Websocket_isConnected = /* @__PURE__ */ new WeakMap(), _Websocket_sampleRate = /* @__PURE__ */ new WeakMap(), _Websocket_container = /* @__PURE__ */ new WeakMap(), _Websocket_encoding = /* @__PURE__ */ new WeakMap(), _Websocket_connectionPromise = /* @__PURE__ */ new WeakMap(), _Websocket_instances = /* @__PURE__ */ new WeakSet(), _Websocket_ensureConnected = /* @__PURE__ */ __name(function _Websocket_ensureConnected2() {
      return __awaiter11(this, void 0, void 0, function* () {
        if (__classPrivateFieldGet(this, _Websocket_isConnected, "f"))
          return;
        if (!__classPrivateFieldGet(this, _Websocket_connectionPromise, "f")) {
          __classPrivateFieldSet(this, _Websocket_connectionPromise, this.connect(), "f");
        }
        yield __classPrivateFieldGet(this, _Websocket_connectionPromise, "f");
      });
    }, "_Websocket_ensureConnected"), _Websocket_generateId = /* @__PURE__ */ __name(function _Websocket_generateId2() {
      return (0, human_id_1.humanId)({
        separator: "-",
        capitalize: false
      });
    }, "_Websocket_generateId");
    exports.default = Websocket;
  }
});

// ../../node_modules/@cartesia/cartesia-js/wrapper/StreamingTTSClient.js
var require_StreamingTTSClient = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/wrapper/StreamingTTSClient.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingTTSClient = void 0;
    var Client_1 = require_Client5();
    var Websocket_1 = __importDefault(require_Websocket());
    var StreamingTTSClient = class extends Client_1.Tts {
      static {
        __name(this, "StreamingTTSClient");
      }
      constructor(options = {}) {
        super(options);
      }
      /**
       * Get a WebSocket client for streaming TTS.
       *
       * @param options - Options for the WebSocket client.
       * @returns A WebSocket client configured for streaming TTS.
       */
      websocket({ sampleRate, container, encoding }) {
        return new Websocket_1.default({ sampleRate, container, encoding }, Object.assign({ cartesiaVersion: "2024-06-10" }, this._options));
      }
    };
    exports.StreamingTTSClient = StreamingTTSClient;
  }
});

// ../../node_modules/@cartesia/cartesia-js/wrapper/SttWebsocket.js
var require_SttWebsocket = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/wrapper/SttWebsocket.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _SttWebsocket_instances;
    var _SttWebsocket_isConnected;
    var _SttWebsocket_model;
    var _SttWebsocket_language;
    var _SttWebsocket_encoding;
    var _SttWebsocket_sampleRate;
    var _SttWebsocket_minVolume;
    var _SttWebsocket_maxSilenceDurationSecs;
    var _SttWebsocket_connectionPromise;
    var _SttWebsocket_ensureConnected;
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = __importStar(require_core());
    var environments = __importStar(require_environments());
    var websocket_1 = require_websocket();
    var SttWebsocket = class {
      static {
        __name(this, "SttWebsocket");
      }
      constructor({ model = "ink-whisper", language = "en", encoding, sampleRate, minVolume, maxSilenceDurationSecs }, options) {
        _SttWebsocket_instances.add(this);
        this.options = options;
        _SttWebsocket_isConnected.set(this, false);
        _SttWebsocket_model.set(this, void 0);
        _SttWebsocket_language.set(this, void 0);
        _SttWebsocket_encoding.set(this, void 0);
        _SttWebsocket_sampleRate.set(this, void 0);
        _SttWebsocket_minVolume.set(this, void 0);
        _SttWebsocket_maxSilenceDurationSecs.set(this, void 0);
        _SttWebsocket_connectionPromise.set(this, void 0);
        if (!model) {
          throw new Error("model parameter is required");
        }
        if (!encoding) {
          throw new Error("encoding parameter is required");
        }
        if (!sampleRate) {
          throw new Error("sampleRate parameter is required");
        }
        __classPrivateFieldSet(this, _SttWebsocket_model, model, "f");
        __classPrivateFieldSet(this, _SttWebsocket_language, language, "f");
        __classPrivateFieldSet(this, _SttWebsocket_encoding, encoding, "f");
        __classPrivateFieldSet(this, _SttWebsocket_sampleRate, sampleRate, "f");
        __classPrivateFieldSet(this, _SttWebsocket_minVolume, minVolume, "f");
        __classPrivateFieldSet(this, _SttWebsocket_maxSilenceDurationSecs, maxSilenceDurationSecs, "f");
      }
      send(audioData) {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a;
          yield __classPrivateFieldGet(this, _SttWebsocket_instances, "m", _SttWebsocket_ensureConnected).call(this);
          (_a = this.socket) === null || _a === void 0 ? void 0 : _a.send(audioData);
        });
      }
      finalize() {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a;
          yield __classPrivateFieldGet(this, _SttWebsocket_instances, "m", _SttWebsocket_ensureConnected).call(this);
          (_a = this.socket) === null || _a === void 0 ? void 0 : _a.send("finalize");
        });
      }
      done() {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a;
          yield __classPrivateFieldGet(this, _SttWebsocket_instances, "m", _SttWebsocket_ensureConnected).call(this);
          (_a = this.socket) === null || _a === void 0 ? void 0 : _a.send("done");
        });
      }
      onMessage(callback) {
        return __awaiter11(this, void 0, void 0, function* () {
          yield __classPrivateFieldGet(this, _SttWebsocket_instances, "m", _SttWebsocket_ensureConnected).call(this);
          if (!this.socket) {
            throw new Error("WebSocket failed to initialize after connection attempt.");
          }
          this.socket.addEventListener("message", (event) => {
            try {
              const data = JSON.parse(event.data);
              const result = {
                type: data.type,
                requestId: data.request_id || ""
              };
              if (data.type === "transcript") {
                result.text = data.text || "";
                result.isFinal = data.is_final || false;
                result.duration = data.duration;
                result.language = data.language;
                if (data.words) {
                  result.words = data.words;
                }
              } else if (data.type === "flush_done") {
              } else if (data.type === "done") {
              } else if (data.type === "error") {
                result.message = data.message;
              }
              callback(result);
            } catch (error) {
              callback({
                type: "error",
                requestId: "",
                message: `Failed to parse message: ${error}`
              });
            }
          });
        });
      }
      connect() {
        return __awaiter11(this, arguments, void 0, function* (connectOptions = {}) {
          if (__classPrivateFieldGet(this, _SttWebsocket_isConnected, "f")) {
            throw new Error("WebSocket is already connected.");
          }
          this.socket = new websocket_1.ReconnectingWebSocket(() => __awaiter11(this, void 0, void 0, function* () {
            var _a;
            const baseUrl = ((_a = yield core.Supplier.get(this.options.environment)) !== null && _a !== void 0 ? _a : environments.CartesiaEnvironment.Production).replace(/^https?:\/\//, "");
            const params = {
              model: __classPrivateFieldGet(this, _SttWebsocket_model, "f"),
              cartesia_version: this.options.cartesiaVersion || "2024-06-10",
              encoding: __classPrivateFieldGet(this, _SttWebsocket_encoding, "f"),
              sample_rate: __classPrivateFieldGet(this, _SttWebsocket_sampleRate, "f").toString()
            };
            if (__classPrivateFieldGet(this, _SttWebsocket_language, "f"))
              params.language = __classPrivateFieldGet(this, _SttWebsocket_language, "f");
            if (__classPrivateFieldGet(this, _SttWebsocket_minVolume, "f") !== void 0)
              params.min_volume = __classPrivateFieldGet(this, _SttWebsocket_minVolume, "f").toString();
            if (__classPrivateFieldGet(this, _SttWebsocket_maxSilenceDurationSecs, "f") !== void 0)
              params.max_silence_duration_secs = __classPrivateFieldGet(this, _SttWebsocket_maxSilenceDurationSecs, "f").toString();
            const apiKey = yield core.Supplier.get(this.options.apiKey);
            if (apiKey) {
              params.api_key = apiKey;
            } else if (connectOptions.accessToken) {
              params.access_token = connectOptions.accessToken;
            }
            const queryString = Object.keys(params).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`).join("&");
            return `wss://${baseUrl}/stt/websocket?${queryString}`;
          }), void 0, connectOptions);
          return new Promise((resolve, reject) => {
            this.socket.onopen = () => {
              __classPrivateFieldSet(this, _SttWebsocket_isConnected, true, "f");
              resolve();
            };
            this.socket.onclose = () => {
              __classPrivateFieldSet(this, _SttWebsocket_isConnected, false, "f");
            };
            this.socket.onerror = () => {
              reject(new Error("WebSocket failed to connect."));
            };
            this.socket.reconnect();
          });
        });
      }
      disconnect() {
        var _a;
        (_a = this.socket) === null || _a === void 0 ? void 0 : _a.close();
        __classPrivateFieldSet(this, _SttWebsocket_isConnected, false, "f");
      }
    };
    _SttWebsocket_isConnected = /* @__PURE__ */ new WeakMap(), _SttWebsocket_model = /* @__PURE__ */ new WeakMap(), _SttWebsocket_language = /* @__PURE__ */ new WeakMap(), _SttWebsocket_encoding = /* @__PURE__ */ new WeakMap(), _SttWebsocket_sampleRate = /* @__PURE__ */ new WeakMap(), _SttWebsocket_minVolume = /* @__PURE__ */ new WeakMap(), _SttWebsocket_maxSilenceDurationSecs = /* @__PURE__ */ new WeakMap(), _SttWebsocket_connectionPromise = /* @__PURE__ */ new WeakMap(), _SttWebsocket_instances = /* @__PURE__ */ new WeakSet(), _SttWebsocket_ensureConnected = /* @__PURE__ */ __name(function _SttWebsocket_ensureConnected2() {
      return __awaiter11(this, void 0, void 0, function* () {
        if (__classPrivateFieldGet(this, _SttWebsocket_isConnected, "f"))
          return;
        if (!__classPrivateFieldGet(this, _SttWebsocket_connectionPromise, "f")) {
          __classPrivateFieldSet(this, _SttWebsocket_connectionPromise, this.connect(), "f");
        }
        yield __classPrivateFieldGet(this, _SttWebsocket_connectionPromise, "f");
      });
    }, "_SttWebsocket_ensureConnected");
    exports.default = SttWebsocket;
  }
});

// ../../node_modules/@cartesia/cartesia-js/wrapper/StreamingSTTClient.js
var require_StreamingSTTClient = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/wrapper/StreamingSTTClient.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __await = exports && exports.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      __name(verb, "verb");
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
      __name(settle, "settle");
    };
    var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      __name(awaitReturn, "awaitReturn");
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f) i[n] = f(i[n]);
        }
      }
      __name(verb, "verb");
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      __name(resume, "resume");
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      __name(step, "step");
      function fulfill(value) {
        resume("next", value);
      }
      __name(fulfill, "fulfill");
      function reject(value) {
        resume("throw", value);
      }
      __name(reject, "reject");
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
      __name(settle, "settle");
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingSTTClient = void 0;
    var Client_1 = require_Client4();
    var SttWebsocket_1 = __importDefault(require_SttWebsocket());
    var StreamingSTTClient = class extends Client_1.Stt {
      static {
        __name(this, "StreamingSTTClient");
      }
      constructor(options = {}) {
        super(options);
      }
      /**
       * Create a WebSocket connection for real-time speech transcription.
       *
       * @param options - Configuration options for the STT WebSocket
       * @param options.model - ID of the model to use for transcription (required)
       * @param options.language - The language of the input audio in ISO-639-1 format (defaults to "en")
       * @param options.encoding - The encoding format of the audio data (required). Must be one of: "pcm_s16le", "pcm_s32le", "pcm_f16le", "pcm_f32le", "pcm_mulaw", "pcm_alaw"
       * @param options.sampleRate - The sample rate of the audio in Hz (required)
       * @param options.minVolume - Volume threshold for voice activity detection (0.0-1.0)
       * @param options.maxSilenceDurationSecs - Maximum duration of silence before endpointing
       * @returns SttWebsocket instance for STT operations
       */
      websocket(options) {
        return new SttWebsocket_1.default(options, Object.assign({ cartesiaVersion: "2024-06-10" }, this._options));
      }
      /**
       * Transcribe audio chunks using WebSocket with automatic connection management.
       *
       * @param audioChunks - Iterator of audio chunks as ArrayBuffer
       * @param options - Configuration options for the STT WebSocket
       * @returns AsyncGenerator yielding transcription results
       */
      transcribeChunks(audioChunks, options) {
        return __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function* transcribeChunks_1() {
          const ws = this.websocket(options);
          try {
            const resultQueue = [];
            let isComplete = false;
            let error = null;
            yield __await(ws.onMessage((result) => {
              if (result.type === "error") {
                error = new Error(result.message || "STT error occurred");
              } else if (result.type === "done") {
                isComplete = true;
              }
              resultQueue.push(result);
            }));
            const sendAudio = /* @__PURE__ */ __name(() => __awaiter11(this, void 0, void 0, function* () {
              var _a, e_1, _b, _c;
              try {
                try {
                  for (var _d = true, audioChunks_1 = __asyncValues(audioChunks), audioChunks_1_1; audioChunks_1_1 = yield audioChunks_1.next(), _a = audioChunks_1_1.done, !_a; _d = true) {
                    _c = audioChunks_1_1.value;
                    _d = false;
                    const chunk = _c;
                    yield ws.send(chunk);
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (!_d && !_a && (_b = audioChunks_1.return)) yield _b.call(audioChunks_1);
                  } finally {
                    if (e_1) throw e_1.error;
                  }
                }
                yield ws.finalize();
                yield ws.done();
              } catch (e) {
                error = e instanceof Error ? e : new Error(String(e));
              }
            }), "sendAudio");
            const sendPromise = sendAudio();
            while (!isComplete && !error) {
              if (resultQueue.length > 0) {
                const result = resultQueue.shift();
                yield yield __await(result);
                if (result.type === "done") {
                  break;
                }
              } else {
                yield __await(new Promise((resolve) => setTimeout(resolve, 10)));
              }
            }
            yield __await(sendPromise);
            if (error) {
              throw error;
            }
            while (resultQueue.length > 0) {
              yield yield __await(resultQueue.shift());
            }
          } finally {
            ws.disconnect();
          }
        }, "transcribeChunks_1"));
      }
    };
    exports.StreamingSTTClient = StreamingSTTClient;
  }
});

// ../../node_modules/@cartesia/cartesia-js/wrapper/Client.js
var require_Client9 = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/wrapper/Client.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CartesiaClient = void 0;
    var Client_1 = require_Client8();
    var StreamingTTSClient_1 = require_StreamingTTSClient();
    var StreamingSTTClient_1 = require_StreamingSTTClient();
    var CartesiaClient2 = class extends Client_1.CartesiaClient {
      static {
        __name(this, "CartesiaClient");
      }
      get stt() {
        var _a;
        return (_a = this._stt) !== null && _a !== void 0 ? _a : this._stt = new StreamingSTTClient_1.StreamingSTTClient(this._options);
      }
      get tts() {
        var _a;
        return (_a = this._tts) !== null && _a !== void 0 ? _a : this._tts = new StreamingTTSClient_1.StreamingTTSClient(this._options);
      }
    };
    exports.CartesiaClient = CartesiaClient2;
  }
});

// ../../node_modules/@cartesia/cartesia-js/wrapper/WebPlayer.js
var require_WebPlayer = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/wrapper/WebPlayer.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __awaiter11 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _WebPlayer_instances;
    var _WebPlayer_context;
    var _WebPlayer_startNextPlaybackAt;
    var _WebPlayer_bufferDuration;
    var _WebPlayer_playBuffer;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebPlayer = void 0;
    var utils_1 = require_utils3();
    var WebPlayer = class {
      static {
        __name(this, "WebPlayer");
      }
      /**
       * Create a new Player.
       *
       * @param options - Options for the Player.
       * @param options.bufferDuration - The duration of the audio buffer to play.
       */
      constructor({ bufferDuration }) {
        _WebPlayer_instances.add(this);
        _WebPlayer_context.set(this, null);
        _WebPlayer_startNextPlaybackAt.set(this, 0);
        _WebPlayer_bufferDuration.set(this, void 0);
        __classPrivateFieldSet(this, _WebPlayer_bufferDuration, bufferDuration, "f");
      }
      /**
       * Play audio from a source.
       *
       * @param source The source to play audio from.
       * @returns A promise that resolves when the audio has finished playing.
       */
      play(source) {
        return __awaiter11(this, void 0, void 0, function* () {
          __classPrivateFieldSet(this, _WebPlayer_startNextPlaybackAt, 0, "f");
          __classPrivateFieldSet(this, _WebPlayer_context, new AudioContext({ sampleRate: source.sampleRate }), "f");
          const buffer = new Float32Array(source.durationToSampleCount(__classPrivateFieldGet(this, _WebPlayer_bufferDuration, "f")));
          const plays = [];
          while (true) {
            const read = yield source.read(buffer);
            const playableAudio = buffer.subarray(0, read);
            plays.push(__classPrivateFieldGet(this, _WebPlayer_instances, "m", _WebPlayer_playBuffer).call(this, playableAudio, source.sampleRate));
            if (read < buffer.length) {
              break;
            }
          }
          yield Promise.all(plays);
        });
      }
      /**
       * Pause the audio.
       *
       * @returns A promise that resolves when the audio has been paused.
       */
      pause() {
        return __awaiter11(this, void 0, void 0, function* () {
          if (!__classPrivateFieldGet(this, _WebPlayer_context, "f")) {
            throw new Error("AudioContext not initialized.");
          }
          yield __classPrivateFieldGet(this, _WebPlayer_context, "f").suspend();
        });
      }
      /**
       * Resume the audio.
       *
       * @returns A promise that resolves when the audio has been resumed.
       */
      resume() {
        return __awaiter11(this, void 0, void 0, function* () {
          if (!__classPrivateFieldGet(this, _WebPlayer_context, "f")) {
            throw new Error("AudioContext not initialized.");
          }
          yield __classPrivateFieldGet(this, _WebPlayer_context, "f").resume();
        });
      }
      /**
       * Toggle the audio.
       *
       * @returns A promise that resolves when the audio has been toggled.
       */
      toggle() {
        return __awaiter11(this, void 0, void 0, function* () {
          if (!__classPrivateFieldGet(this, _WebPlayer_context, "f")) {
            throw new Error("AudioContext not initialized.");
          }
          if (__classPrivateFieldGet(this, _WebPlayer_context, "f").state === "running") {
            yield this.pause();
          } else {
            yield this.resume();
          }
        });
      }
      /**
       * Stop the audio.
       *
       * @returns A promise that resolves when the audio has been stopped.
       */
      stop() {
        return __awaiter11(this, void 0, void 0, function* () {
          var _a;
          if (!__classPrivateFieldGet(this, _WebPlayer_context, "f")) {
            throw new Error("AudioContext not initialized.");
          }
          yield (_a = __classPrivateFieldGet(this, _WebPlayer_context, "f")) === null || _a === void 0 ? void 0 : _a.close();
        });
      }
    };
    exports.WebPlayer = WebPlayer;
    _WebPlayer_context = /* @__PURE__ */ new WeakMap(), _WebPlayer_startNextPlaybackAt = /* @__PURE__ */ new WeakMap(), _WebPlayer_bufferDuration = /* @__PURE__ */ new WeakMap(), _WebPlayer_instances = /* @__PURE__ */ new WeakSet(), _WebPlayer_playBuffer = /* @__PURE__ */ __name(function _WebPlayer_playBuffer2(buf, sampleRate) {
      return __awaiter11(this, void 0, void 0, function* () {
        if (!__classPrivateFieldGet(this, _WebPlayer_context, "f")) {
          throw new Error("AudioContext not initialized.");
        }
        if (buf.length === 0) {
          return;
        }
        const startAt = __classPrivateFieldGet(this, _WebPlayer_startNextPlaybackAt, "f");
        const duration = buf.length / sampleRate;
        __classPrivateFieldSet(this, _WebPlayer_startNextPlaybackAt, duration + Math.max(__classPrivateFieldGet(this, _WebPlayer_context, "f").currentTime, __classPrivateFieldGet(this, _WebPlayer_startNextPlaybackAt, "f")), "f");
        yield (0, utils_1.playAudioBuffer)(buf, __classPrivateFieldGet(this, _WebPlayer_context, "f"), startAt, sampleRate);
      });
    }, "_WebPlayer_playBuffer");
  }
});

// ../../node_modules/@cartesia/cartesia-js/index.js
var require_cartesia_js = __commonJS({
  "../../node_modules/@cartesia/cartesia-js/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
      var ownKeys = /* @__PURE__ */ __name(function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      }, "ownKeys");
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CartesiaTimeoutError = exports.CartesiaError = exports.CartesiaEnvironment = exports.StreamingSTTClient = exports.SttWebsocket = exports.WebPlayer = exports.CartesiaClient = exports.Cartesia = void 0;
    exports.Cartesia = __importStar(require_api());
    var Client_1 = require_Client9();
    Object.defineProperty(exports, "CartesiaClient", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return Client_1.CartesiaClient;
    }, "get") });
    var WebPlayer_1 = require_WebPlayer();
    Object.defineProperty(exports, "WebPlayer", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return WebPlayer_1.WebPlayer;
    }, "get") });
    var SttWebsocket_1 = require_SttWebsocket();
    Object.defineProperty(exports, "SttWebsocket", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return __importDefault(SttWebsocket_1).default;
    }, "get") });
    var StreamingSTTClient_1 = require_StreamingSTTClient();
    Object.defineProperty(exports, "StreamingSTTClient", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return StreamingSTTClient_1.StreamingSTTClient;
    }, "get") });
    var environments_1 = require_environments();
    Object.defineProperty(exports, "CartesiaEnvironment", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return environments_1.CartesiaEnvironment;
    }, "get") });
    var errors_1 = require_errors2();
    Object.defineProperty(exports, "CartesiaError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return errors_1.CartesiaError;
    }, "get") });
    Object.defineProperty(exports, "CartesiaTimeoutError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return errors_1.CartesiaTimeoutError;
    }, "get") });
  }
});

// .wrangler/tmp/bundle-f5RJD0/middleware-loader.entry.ts
init_modules_watch_stub();

// .wrangler/tmp/bundle-f5RJD0/middleware-insertion-facade.js
init_modules_watch_stub();

// src/worker.ts
init_modules_watch_stub();

// ../../packages/server/dist/index.js
init_modules_watch_stub();
var FIVE_MINUTES_IN_MS = 5 * 60 * 1e3;
var VoiceSessionManager = class {
  static {
    __name(this, "VoiceSessionManager");
  }
  constructor(options) {
    this.options = options;
    this.transcriptionProvider = options.transcriptionProvider;
    this.agentProcessor = options.agentProcessor;
    this.ttsStreamer = options.ttsStreamer;
  }
  transcriptionProvider;
  agentProcessor;
  ttsStreamer;
  inactivityTimer = null;
  lastActivity = Date.now();
  activeCommand = null;
  handleOpen() {
    this.touch();
    this.options.sendJson({
      type: "ready",
      data: {
        message: "voice channel established",
        timeoutMs: this.options.idleTimeoutMs ?? FIVE_MINUTES_IN_MS
      }
    });
  }
  async handleMessage(message) {
    this.touch();
    if (typeof message === "string") {
      await this.handleJson(message);
      return;
    }
    if (message instanceof Blob) {
      await this.forwardAudioChunk(await message.arrayBuffer());
      return;
    }
    await this.forwardAudioChunk(message);
  }
  handleClose(code, reason) {
    this.clearInactivityTimer();
    this.teardownActiveCommand(reason ?? `socket closed (${code ?? "unknown"})`);
  }
  async handleJson(raw) {
    let payload;
    try {
      payload = JSON.parse(raw);
    } catch {
      this.sendError("Invalid JSON payload");
      return;
    }
    switch (payload.type) {
      case "start":
        await this.startCommand(payload);
        break;
      case "end":
        await this.completeCommand();
        break;
      case "cancel":
        this.cancelCommand();
        break;
      case "ping":
        this.options.sendJson({
          type: "pong",
          data: { timestamp: payload.timestamp ?? Date.now() }
        });
        break;
      default:
        this.sendError(`Unsupported event type ${payload.type}`);
    }
  }
  async startCommand(payload) {
    if (this.activeCommand) {
      this.sendError("A command is already in progress");
      return;
    }
    try {
      const transcriber = await this.transcriptionProvider.createStream({
        encoding: payload.audio?.encoding,
        sampleRate: payload.audio?.sampleRate,
        channels: payload.audio?.channels,
        onTranscript: /* @__PURE__ */ __name((event) => this.handleTranscript(event), "onTranscript"),
        onError: /* @__PURE__ */ __name((error) => this.handleTranscriptionError(error), "onError")
      });
      this.activeCommand = {
        timezone: payload.timezone ?? "UTC",
        transcriber,
        finalTranscriptChunks: [],
        startedAt: Date.now()
      };
      this.options.sendJson({ type: "command-started" });
    } catch (error) {
      this.sendError(
        error instanceof Error ? error.message : "Failed to start transcription stream"
      );
    }
  }
  async completeCommand() {
    if (!this.activeCommand) {
      this.sendError("No active command");
      return;
    }
    try {
      await this.activeCommand.transcriber.finish();
      const finalTranscript = this.activeCommand.finalTranscriptChunks.join(" ").trim();
      await this.processTranscript(finalTranscript);
    } catch (error) {
      this.sendError(
        error instanceof Error ? error.message : "Failed to finalize command"
      );
      this.teardownActiveCommand("finalization failed");
    }
  }
  cancelCommand() {
    if (!this.activeCommand) {
      return;
    }
    this.activeCommand.transcriber.abort("command cancelled");
    this.activeCommand = null;
    this.options.sendJson({ type: "command-cancelled" });
  }
  async forwardAudioChunk(buffer) {
    if (!this.activeCommand) {
      return;
    }
    try {
      this.activeCommand.transcriber.send(buffer);
    } catch (error) {
      this.sendError(
        error instanceof Error ? error.message : "Failed to forward audio chunk"
      );
    }
  }
  async processTranscript(transcript) {
    this.options.sendJson({
      type: "transcript.final",
      data: { transcript }
    });
    if (!this.activeCommand) {
      return;
    }
    try {
      await this.agentProcessor.process({
        transcript,
        userId: this.options.userId,
        timezone: this.activeCommand.timezone,
        send: /* @__PURE__ */ __name((event) => this.forwardAgentEvent(event), "send")
      });
    } catch (error) {
      this.sendError(
        error instanceof Error ? error.message : "Agentic processing failed"
      );
    } finally {
      this.teardownActiveCommand("command complete");
    }
  }
  async forwardAgentEvent(event) {
    this.options.sendJson(event);
    if (event.type !== "complete") {
      return;
    }
    const text = event.data?.formattedContent?.content;
    if (!text || typeof text !== "string") {
      return;
    }
    if (!this.ttsStreamer) {
      return;
    }
    this.options.sendJson({
      type: "tts.start",
      data: {
        encoding: "linear16",
        sampleRate: 48e3,
        mimeType: "audio/raw"
      }
    });
    let handled = false;
    try {
      await this.ttsStreamer.stream(text, {
        onAudioChunk: /* @__PURE__ */ __name((chunk) => this.options.sendBinary(chunk), "onAudioChunk"),
        onClose: /* @__PURE__ */ __name(() => {
          this.options.sendJson({ type: "tts.end" });
        }, "onClose"),
        onError: /* @__PURE__ */ __name((error) => {
          handled = true;
          this.sendError(error.message);
          this.options.sendJson({ type: "tts.end", data: { errored: true } });
        }, "onError")
      });
    } catch (error) {
      if (!handled) {
        const message = error instanceof Error ? error.message : "Failed to stream TTS audio";
        this.sendError(message);
        this.options.sendJson({ type: "tts.end", data: { errored: true } });
      }
    }
  }
  handleTranscript(event) {
    if (!this.activeCommand) {
      return;
    }
    const trimmed = event.transcript.trim();
    if (trimmed.length === 0 && this.activeCommand.finalTranscriptChunks.length === 0) {
      return;
    }
    const combine = /* @__PURE__ */ __name((...segments) => segments.map((segment) => segment.trim()).filter((segment) => segment.length > 0).join(" "), "combine");
    if (event.isFinal) {
      if (trimmed.length === 0) {
        return;
      }
      this.activeCommand.finalTranscriptChunks.push(trimmed);
      const aggregate2 = combine(...this.activeCommand.finalTranscriptChunks);
      if (aggregate2.length > 0) {
        this.options.sendJson({
          type: "transcript.partial",
          data: { transcript: aggregate2 }
        });
      }
      return;
    }
    const aggregate = combine(...this.activeCommand.finalTranscriptChunks, trimmed);
    if (aggregate.length === 0) {
      return;
    }
    this.options.sendJson({
      type: "transcript.partial",
      data: { transcript: aggregate }
    });
  }
  handleTranscriptionError(error) {
    this.sendError(error.message);
    this.teardownActiveCommand("transcriber error");
  }
  teardownActiveCommand(reason) {
    if (!this.activeCommand) {
      return;
    }
    try {
      this.activeCommand.transcriber.abort(reason);
    } catch {
    }
    this.activeCommand = null;
  }
  sendError(message) {
    this.options.sendJson({
      type: "error",
      data: { error: message }
    });
  }
  touch() {
    this.lastActivity = Date.now();
    this.scheduleInactivityTimer();
  }
  scheduleInactivityTimer() {
    if (typeof setTimeout !== "function") {
      return;
    }
    if (this.inactivityTimer) {
      clearTimeout(this.inactivityTimer);
    }
    const timeout = this.options.idleTimeoutMs ?? FIVE_MINUTES_IN_MS;
    this.inactivityTimer = setTimeout(() => {
      const idleTime = Date.now() - this.lastActivity;
      if (idleTime >= timeout) {
        this.options.sendJson({
          type: "timeout",
          data: { idleMs: idleTime }
        });
        this.options.closeSocket(4e3, "idle timeout");
      } else {
        this.scheduleInactivityTimer();
      }
    }, timeout);
  }
  clearInactivityTimer() {
    if (this.inactivityTimer) {
      clearTimeout(this.inactivityTimer);
      this.inactivityTimer = null;
    }
  }
};
var MockAgentProcessor = class {
  static {
    __name(this, "MockAgentProcessor");
  }
  constructor(options = {}) {
    this.options = options;
  }
  async process({
    transcript,
    send
  }) {
    const prefix = this.options.responsePrefix ?? "Agent response:";
    await send({
      type: "complete",
      data: {
        intent: "fetch",
        transcript,
        graphPaths: [],
        fallbackResults: [],
        formattedContent: {
          format: "paragraph",
          content: `${prefix} ${transcript}`
        },
        timestamp: Date.now()
      }
    });
  }
};
function createVoiceDurableObject(factory) {
  return class VoiceDurableObject {
    static {
      __name(this, "VoiceDurableObject");
    }
    constructor(state, env) {
      this.state = state;
      this.env = env;
      for (const socket of this.state.getWebSockets()) {
        const attachment = socket.deserializeAttachment();
        if (attachment?.userId) {
          this.session = this.createSession(socket, attachment.userId);
        }
      }
    }
    // Internal session tracking for the currently connected user.
    session = null;
    async fetch(request) {
      if (request.method !== "GET") {
        return new Response("Method not allowed", { status: 405 });
      }
      const upgradeHeader = request.headers.get("Upgrade");
      if (!upgradeHeader || upgradeHeader.toLowerCase() !== "websocket") {
        return new Response("Expected WebSocket upgrade", { status: 426 });
      }
      const userHeader = request.headers.get("X-Voice-User");
      if (!userHeader) {
        return new Response("Missing user context", { status: 400 });
      }
      const user = JSON.parse(userHeader);
      if (!user.id) {
        return new Response("Unauthorized voice session", { status: 401 });
      }
      const pair = new WebSocketPair();
      const [client, server] = Object.values(pair);
      this.session = this.createSession(server, user.id);
      server.serializeAttachment({ userId: user.id });
      this.state.acceptWebSocket(server);
      this.session.handleOpen();
      const responseInit = {
        status: 101,
        webSocket: client
      };
      return new Response(null, responseInit);
    }
    async webSocketMessage(ws, message) {
      this.ensureSession(ws);
      await this.session?.handleMessage(message);
    }
    async webSocketClose(ws, code, reason) {
      this.ensureSession(ws);
      this.session?.handleClose(code, reason);
    }
    async webSocketError(ws, error) {
      this.ensureSession(ws);
      const message = error instanceof Error ? error.message : "WebSocket error";
      this.session?.handleClose(1011, message);
    }
    createSession(ws, userId) {
      const { transcriptionProvider, agentProcessor, ttsStreamer } = factory.createProviders(this.env, userId);
      return new VoiceSessionManager({
        userId,
        transcriptionProvider,
        agentProcessor,
        ttsStreamer,
        sendJson: /* @__PURE__ */ __name((payload) => {
          ws.send(JSON.stringify(payload));
        }, "sendJson"),
        sendBinary: /* @__PURE__ */ __name((chunk) => ws.send(chunk), "sendBinary"),
        closeSocket: /* @__PURE__ */ __name((code, reason) => ws.close(code, reason), "closeSocket")
      });
    }
    ensureSession(ws) {
      if (this.session) {
        return;
      }
      const attachment = ws.deserializeAttachment();
      if (!attachment?.userId) {
        ws.close(1011, "missing voice session context");
        return;
      }
      this.session = this.createSession(ws, attachment.userId);
    }
  };
}
__name(createVoiceDurableObject, "createVoiceDurableObject");

// ../../packages/deepgram/dist/index.js
init_modules_watch_stub();

// ../../node_modules/@deepgram/sdk/dist/module/index.js
init_modules_watch_stub();

// ../../node_modules/@deepgram/sdk/dist/module/lib/errors.js
init_modules_watch_stub();
var DeepgramError = class extends Error {
  static {
    __name(this, "DeepgramError");
  }
  constructor(message) {
    super(message);
    this.__dgError = true;
    this.name = "DeepgramError";
  }
};
function isDeepgramError(error) {
  return typeof error === "object" && error !== null && "__dgError" in error;
}
__name(isDeepgramError, "isDeepgramError");
var DeepgramApiError = class extends DeepgramError {
  static {
    __name(this, "DeepgramApiError");
  }
  constructor(message, status) {
    super(message);
    this.name = "DeepgramApiError";
    this.status = status;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
};
var DeepgramUnknownError = class extends DeepgramError {
  static {
    __name(this, "DeepgramUnknownError");
  }
  constructor(message, originalError) {
    super(message);
    this.name = "DeepgramUnknownError";
    this.originalError = originalError;
  }
};
var DeepgramVersionError = class extends DeepgramError {
  static {
    __name(this, "DeepgramVersionError");
  }
  constructor() {
    super(`You are attempting to use an old format for a newer SDK version. Read more here: https://dpgr.am/js-v3`);
    this.name = "DeepgramVersionError";
  }
};
var DeepgramWebSocketError = class extends DeepgramError {
  static {
    __name(this, "DeepgramWebSocketError");
  }
  constructor(message, options = {}) {
    super(message);
    this.name = "DeepgramWebSocketError";
    this.originalEvent = options.originalEvent;
    this.statusCode = options.statusCode;
    this.requestId = options.requestId;
    this.responseHeaders = options.responseHeaders;
    this.url = options.url;
    this.readyState = options.readyState;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      statusCode: this.statusCode,
      requestId: this.requestId,
      responseHeaders: this.responseHeaders,
      url: this.url,
      readyState: this.readyState,
      originalEvent: this.originalEvent ? {
        type: this.originalEvent.type,
        timeStamp: this.originalEvent.timeStamp
      } : void 0
    };
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/DeepgramClient.js
init_modules_watch_stub();

// ../../node_modules/@deepgram/sdk/dist/module/packages/AbstractClient.js
init_modules_watch_stub();
var import_events = __toESM(require_events());

// ../../node_modules/@deepgram/sdk/dist/module/lib/constants.js
init_modules_watch_stub();

// ../../node_modules/@deepgram/sdk/dist/module/lib/helpers.js
init_modules_watch_stub();
var import_cross_fetch = __toESM(require_browser_ponyfill());
var import_deepmerge = __toESM(require_cjs());

// ../../node_modules/@deepgram/sdk/dist/module/lib/runtime.js
init_modules_watch_stub();
var NODE_VERSION = typeof process !== "undefined" && process.versions && process.versions.node ? process.versions.node : "unknown";
var BUN_VERSION = typeof process !== "undefined" && process.versions && process.versions.bun ? process.versions.bun : "unknown";
var BROWSER_AGENT = typeof window !== "undefined" && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : "unknown";
var isBrowser = /* @__PURE__ */ __name(() => BROWSER_AGENT !== "unknown", "isBrowser");
var isNode = /* @__PURE__ */ __name(() => NODE_VERSION !== "unknown", "isNode");
var isBun = /* @__PURE__ */ __name(() => BUN_VERSION !== "unknown", "isBun");

// ../../node_modules/@deepgram/sdk/dist/module/lib/helpers.js
function applyDefaults(options = {}, subordinate = {}) {
  return (0, import_deepmerge.default)(subordinate, options);
}
__name(applyDefaults, "applyDefaults");
function appendSearchParams(searchParams, options) {
  Object.keys(options).forEach((i) => {
    if (Array.isArray(options[i])) {
      const arrayParams = options[i];
      arrayParams.forEach((param) => {
        searchParams.append(i, String(param));
      });
    } else {
      searchParams.append(i, String(options[i]));
    }
  });
}
__name(appendSearchParams, "appendSearchParams");
var resolveHeadersConstructor = /* @__PURE__ */ __name(() => {
  if (typeof Headers === "undefined") {
    return import_cross_fetch.Headers;
  }
  return Headers;
}, "resolveHeadersConstructor");
var isUrlSource = /* @__PURE__ */ __name((providedSource) => {
  if (providedSource && providedSource.url)
    return true;
  return false;
}, "isUrlSource");
var isTextSource = /* @__PURE__ */ __name((providedSource) => {
  if (providedSource && providedSource.text)
    return true;
  return false;
}, "isTextSource");
var isFileSource = /* @__PURE__ */ __name((providedSource) => {
  if (isReadStreamSource(providedSource) || isBufferSource(providedSource))
    return true;
  return false;
}, "isFileSource");
var isBufferSource = /* @__PURE__ */ __name((providedSource) => {
  return providedSource != null && Buffer.isBuffer(providedSource);
}, "isBufferSource");
var isReadStreamSource = /* @__PURE__ */ __name((providedSource) => {
  if (providedSource == null)
    return false;
  if (isBrowser())
    return false;
  return typeof providedSource === "object" && typeof providedSource.pipe === "function" && typeof providedSource.read === "function" && typeof providedSource._readableState === "object";
}, "isReadStreamSource");
var convertProtocolToWs = /* @__PURE__ */ __name((url) => {
  const convert = /* @__PURE__ */ __name((string) => string.toLowerCase().replace(/^http/, "ws"), "convert");
  return convert(url);
}, "convertProtocolToWs");
var convertLegacyOptions = /* @__PURE__ */ __name((optionsArg) => {
  var _a, _b, _c, _d, _e, _f;
  const newOptions = {};
  if (optionsArg._experimentalCustomFetch) {
    newOptions.global = {
      fetch: {
        client: optionsArg._experimentalCustomFetch
      }
    };
  }
  optionsArg = (0, import_deepmerge.default)(optionsArg, newOptions);
  if ((_a = optionsArg.restProxy) === null || _a === void 0 ? void 0 : _a.url) {
    newOptions.global = {
      fetch: {
        options: {
          proxy: {
            url: (_b = optionsArg.restProxy) === null || _b === void 0 ? void 0 : _b.url
          }
        }
      }
    };
  }
  optionsArg = (0, import_deepmerge.default)(optionsArg, newOptions);
  if ((_c = optionsArg.global) === null || _c === void 0 ? void 0 : _c.url) {
    newOptions.global = {
      fetch: {
        options: {
          url: optionsArg.global.url
        }
      },
      websocket: {
        options: {
          url: optionsArg.global.url
        }
      }
    };
  }
  optionsArg = (0, import_deepmerge.default)(optionsArg, newOptions);
  if ((_d = optionsArg.global) === null || _d === void 0 ? void 0 : _d.headers) {
    newOptions.global = {
      fetch: {
        options: {
          headers: (_e = optionsArg.global) === null || _e === void 0 ? void 0 : _e.headers
        }
      },
      websocket: {
        options: {
          _nodeOnlyHeaders: (_f = optionsArg.global) === null || _f === void 0 ? void 0 : _f.headers
        }
      }
    };
  }
  optionsArg = (0, import_deepmerge.default)(optionsArg, newOptions);
  return optionsArg;
}, "convertLegacyOptions");

// ../../node_modules/@deepgram/sdk/dist/module/lib/version.js
init_modules_watch_stub();
var version = "4.11.2";

// ../../node_modules/@deepgram/sdk/dist/module/lib/constants.js
var getAgent = /* @__PURE__ */ __name(() => {
  if (isNode()) {
    return `node/${NODE_VERSION}`;
  } else if (isBun()) {
    return `bun/${BUN_VERSION}`;
  } else if (isBrowser()) {
    return `javascript ${BROWSER_AGENT}`;
  } else {
    return `unknown`;
  }
}, "getAgent");
var DEFAULT_HEADERS = {
  "Content-Type": `application/json`,
  "X-Client-Info": `@deepgram/sdk; ${isBrowser() ? "browser" : "server"}; v${version}`,
  "User-Agent": `@deepgram/sdk/${version} ${getAgent()}`
};
var DEFAULT_URL = "https://api.deepgram.com";
var DEFAULT_AGENT_URL = "wss://agent.deepgram.com";
var DEFAULT_GLOBAL_OPTIONS = {
  fetch: { options: { url: DEFAULT_URL, headers: DEFAULT_HEADERS } },
  websocket: {
    options: { url: convertProtocolToWs(DEFAULT_URL), _nodeOnlyHeaders: DEFAULT_HEADERS }
  }
};
var DEFAULT_AGENT_OPTIONS = {
  fetch: { options: { url: DEFAULT_URL, headers: DEFAULT_HEADERS } },
  websocket: {
    options: { url: DEFAULT_AGENT_URL, _nodeOnlyHeaders: DEFAULT_HEADERS }
  }
};
var DEFAULT_OPTIONS = {
  global: DEFAULT_GLOBAL_OPTIONS,
  agent: DEFAULT_AGENT_OPTIONS
};
var SOCKET_STATES;
(function(SOCKET_STATES2) {
  SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
  SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
  SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
  SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CONNECTION_STATE;
(function(CONNECTION_STATE2) {
  CONNECTION_STATE2["Connecting"] = "connecting";
  CONNECTION_STATE2["Open"] = "open";
  CONNECTION_STATE2["Closing"] = "closing";
  CONNECTION_STATE2["Closed"] = "closed";
})(CONNECTION_STATE || (CONNECTION_STATE = {}));

// ../../node_modules/@deepgram/sdk/dist/module/packages/AbstractClient.js
var noop = /* @__PURE__ */ __name(() => {
}, "noop");
var AbstractClient = class extends import_events.EventEmitter {
  static {
    __name(this, "AbstractClient");
  }
  /**
   * Constructs a new instance of the DeepgramClient class with the provided options.
   *
   * @param options - The options to configure the DeepgramClient instance.
   * @param options.key - The Deepgram API key to use for authentication. If not provided, the `DEEPGRAM_API_KEY` environment variable will be used.
   * @param options.accessToken - The Deepgram access token to use for authentication. If not provided, the `DEEPGRAM_ACCESS_TOKEN` environment variable will be used.
   * @param options.global - Global options that apply to all requests made by the DeepgramClient instance.
   * @param options.global.fetch - Options to configure the fetch requests made by the DeepgramClient instance.
   * @param options.global.fetch.options - Additional options to pass to the fetch function, such as `url` and `headers`.
   * @param options.namespace - Options specific to a particular namespace within the DeepgramClient instance.
   */
  constructor(options) {
    super();
    this.factory = void 0;
    this.key = void 0;
    this.accessToken = void 0;
    this.namespace = "global";
    this.version = "v1";
    this.baseUrl = DEFAULT_URL;
    this.logger = noop;
    if (typeof options.accessToken === "function") {
      this.factory = options.accessToken;
      this.accessToken = this.factory();
    } else {
      this.accessToken = options.accessToken;
    }
    if (typeof options.key === "function") {
      this.factory = options.key;
      this.key = this.factory();
    } else {
      this.key = options.key;
    }
    if (!this.key && !this.accessToken) {
      this.accessToken = process.env.DEEPGRAM_ACCESS_TOKEN;
      if (!this.accessToken) {
        this.key = process.env.DEEPGRAM_API_KEY;
      }
    }
    if (!this.key && !this.accessToken) {
      throw new DeepgramError("A deepgram API key or access token is required.");
    }
    options = convertLegacyOptions(options);
    this.options = applyDefaults(options, DEFAULT_OPTIONS);
  }
  /**
   * Sets the version for the current instance of the Deepgram API and returns the instance.
   *
   * @param version - The version to set for the Deepgram API instance. Defaults to "v1" if not provided.
   * @returns The current instance of the AbstractClient with the updated version.
   */
  v(version2 = "v1") {
    this.version = version2;
    return this;
  }
  /**
   * Gets the namespace options for the current instance of the AbstractClient.
   * The namespace options include the default options merged with the global options,
   * and the API key for the current instance.
   *
   * @returns The namespace options for the current instance.
   */
  get namespaceOptions() {
    const defaults = applyDefaults(this.options[this.namespace], this.options.global);
    return Object.assign(Object.assign({}, defaults), { key: this.key });
  }
  /**
   * Generates a URL for an API endpoint with optional query parameters and transcription options.
   *
   * @param endpoint - The API endpoint URL, which may contain placeholders for fields.
   * @param fields - An optional object containing key-value pairs to replace placeholders in the endpoint URL.
   * @param transcriptionOptions - Optional transcription options to include as query parameters in the URL.
   * @returns A URL object representing the constructed API request URL.
   */
  getRequestUrl(endpoint, fields = { version: this.version }, transcriptionOptions) {
    fields.version = this.version;
    endpoint = endpoint.replace(/:(\w+)/g, function(_, key) {
      return fields[key];
    });
    const url = new URL(endpoint, this.baseUrl);
    if (transcriptionOptions) {
      appendSearchParams(url.searchParams, transcriptionOptions);
    }
    return url;
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(kind, msg, data) {
    this.logger(kind, msg, data);
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/AbstractLiveClient.js
init_modules_watch_stub();
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== "undefined";
var AbstractLiveClient = class extends AbstractClient {
  static {
    __name(this, "AbstractLiveClient");
  }
  constructor(options) {
    super(options);
    this.conn = null;
    this.sendBuffer = [];
    this.reconnect = noop;
    const { key, websocket: { options: websocketOptions, client } } = this.namespaceOptions;
    if (this.proxy) {
      this.baseUrl = websocketOptions.proxy.url;
    } else {
      this.baseUrl = websocketOptions.url;
    }
    if (client) {
      this.transport = client;
    } else {
      this.transport = null;
    }
    if (websocketOptions._nodeOnlyHeaders) {
      this.headers = websocketOptions._nodeOnlyHeaders;
    } else {
      this.headers = {};
    }
    if (!("Authorization" in this.headers)) {
      if (this.accessToken) {
        this.headers["Authorization"] = `Bearer ${this.accessToken}`;
      } else {
        this.headers["Authorization"] = `Token ${key}`;
      }
    }
  }
  /**
   * Connects the socket, unless already connected.
   *
   * @protected Can only be called from within the class.
   */
  connect(transcriptionOptions, endpoint) {
    if (this.conn) {
      return;
    }
    this.reconnect = (options = transcriptionOptions) => {
      this.connect(options, endpoint);
    };
    const requestUrl = this.getRequestUrl(endpoint, {}, transcriptionOptions);
    const accessToken = this.accessToken;
    const apiKey = this.key;
    if (!accessToken && !apiKey) {
      throw new Error("No key or access token provided for WebSocket connection.");
    }
    if (this.transport) {
      this.conn = new this.transport(requestUrl, void 0, {
        headers: this.headers
      });
      this.setupConnection();
      return;
    }
    if (isBun()) {
      Promise.resolve().then(() => __toESM(require_browser())).then(({ default: WS }) => {
        this.conn = new WS(requestUrl, {
          headers: this.headers
        });
        console.log(`Using WS package`);
        this.setupConnection();
      });
      return;
    }
    if (NATIVE_WEBSOCKET_AVAILABLE) {
      this.conn = new WebSocket(requestUrl, accessToken ? ["bearer", accessToken] : ["token", apiKey]);
      this.setupConnection();
      return;
    }
    this.conn = new WSWebSocketDummy(requestUrl, void 0, {
      close: /* @__PURE__ */ __name(() => {
        this.conn = null;
      }, "close")
    });
    Promise.resolve().then(() => __toESM(require_browser())).then(({ default: WS }) => {
      this.conn = new WS(requestUrl, void 0, {
        headers: this.headers
      });
      this.setupConnection();
    });
  }
  /**
   * Disconnects the socket from the client.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(code, reason) {
    if (this.conn) {
      this.conn.onclose = function() {
      };
      if (code) {
        this.conn.close(code, reason !== null && reason !== void 0 ? reason : "");
      } else {
        this.conn.close();
      }
      this.conn = null;
    }
  }
  /**
   * Returns the current connection state of the WebSocket connection.
   *
   * @returns The current connection state of the WebSocket connection.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case SOCKET_STATES.connecting:
        return CONNECTION_STATE.Connecting;
      case SOCKET_STATES.open:
        return CONNECTION_STATE.Open;
      case SOCKET_STATES.closing:
        return CONNECTION_STATE.Closing;
      default:
        return CONNECTION_STATE.Closed;
    }
  }
  /**
   * Returns the current ready state of the WebSocket connection.
   *
   * @returns The current ready state of the WebSocket connection.
   */
  getReadyState() {
    var _a, _b;
    return (_b = (_a = this.conn) === null || _a === void 0 ? void 0 : _a.readyState) !== null && _b !== void 0 ? _b : SOCKET_STATES.closed;
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === CONNECTION_STATE.Open;
  }
  /**
   * Sends data to the Deepgram API via websocket connection
   * @param data Audio data to send to Deepgram
   *
   * Conforms to RFC #146 for Node.js - does not send an empty byte.
   * @see https://github.com/deepgram/deepgram-python-sdk/issues/146
   */
  send(data) {
    const callback = /* @__PURE__ */ __name(() => __awaiter(this, void 0, void 0, function* () {
      var _a;
      if (data instanceof Blob) {
        if (data.size === 0) {
          this.log("warn", "skipping `send` for zero-byte blob", data);
          return;
        }
        data = yield data.arrayBuffer();
      }
      if (typeof data !== "string") {
        if (!(data === null || data === void 0 ? void 0 : data.byteLength)) {
          this.log("warn", "skipping `send` for zero-byte payload", data);
          return;
        }
      }
      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(data);
    }), "callback");
    if (this.isConnected()) {
      callback();
    } else {
      this.sendBuffer.push(callback);
    }
  }
  /**
   * Determines whether the current instance should proxy requests.
   * @returns {boolean} true if the current instance should proxy requests; otherwise, false
   */
  get proxy() {
    var _a;
    return this.key === "proxy" && !!((_a = this.namespaceOptions.websocket.options.proxy) === null || _a === void 0 ? void 0 : _a.url);
  }
  /**
   * Extracts enhanced error information from a WebSocket error event.
   * This method attempts to capture additional debugging information such as
   * status codes, request IDs, and response headers when available.
   *
   * @example
   * ```typescript
   * // Enhanced error information is now available in error events:
   * connection.on(LiveTranscriptionEvents.Error, (err) => {
   *   console.error("WebSocket Error:", err.message);
   *
   *   // Access HTTP status code (e.g., 502, 403, etc.)
   *   if (err.statusCode) {
   *     console.error(`HTTP Status Code: ${err.statusCode}`);
   *   }
   *
   *   // Access Deepgram request ID for support tickets
   *   if (err.requestId) {
   *     console.error(`Deepgram Request ID: ${err.requestId}`);
   *   }
   *
   *   // Access WebSocket URL and connection state
   *   if (err.url) {
   *     console.error(`WebSocket URL: ${err.url}`);
   *   }
   *
   *   if (err.readyState !== undefined) {
   *     const stateNames = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
   *     console.error(`Connection State: ${stateNames[err.readyState]}`);
   *   }
   *
   *   // Access response headers for additional debugging
   *   if (err.responseHeaders) {
   *     console.error("Response Headers:", err.responseHeaders);
   *   }
   *
   *   // Access the enhanced error object for detailed debugging
   *   if (err.error?.name === 'DeepgramWebSocketError') {
   *     console.error("Enhanced Error Details:", err.error.toJSON());
   *   }
   * });
   * ```
   *
   * @param event - The error event from the WebSocket
   * @param conn - The WebSocket connection object
   * @returns Enhanced error information object
   */
  extractErrorInformation(event, conn) {
    var _a;
    const errorInfo = {};
    if (conn) {
      errorInfo.readyState = conn.readyState;
      errorInfo.url = typeof conn.url === "string" ? conn.url : (_a = conn.url) === null || _a === void 0 ? void 0 : _a.toString();
    }
    if (conn && typeof conn === "object") {
      const wsConn = conn;
      if (wsConn._req && wsConn._req.res) {
        errorInfo.statusCode = wsConn._req.res.statusCode;
        if (wsConn._req.res.headers) {
          errorInfo.responseHeaders = Object.assign({}, wsConn._req.res.headers);
          const requestId = wsConn._req.res.headers["dg-request-id"] || wsConn._req.res.headers["x-dg-request-id"];
          if (requestId) {
            errorInfo.requestId = requestId;
          }
        }
      }
      if (event && "target" in event && event.target) {
        const target = event.target;
        if (target.url) {
          errorInfo.url = target.url;
        }
        if (target.readyState !== void 0) {
          errorInfo.readyState = target.readyState;
        }
      }
    }
    return errorInfo;
  }
  /**
   * Creates an enhanced error object with additional debugging information.
   * This method provides backward compatibility by including both the original
   * error event and enhanced error information.
   *
   * @param event - The original error event
   * @param enhancedInfo - Additional error information extracted from the connection
   * @returns An object containing both original and enhanced error information
   */
  createEnhancedError(event, enhancedInfo) {
    const enhancedError = new DeepgramWebSocketError(event.message || "WebSocket connection error", Object.assign({ originalEvent: event }, enhancedInfo));
    return Object.assign(Object.assign({}, event), {
      // Enhanced error information
      error: enhancedError,
      // Additional fields for easier access
      statusCode: enhancedInfo.statusCode,
      requestId: enhancedInfo.requestId,
      responseHeaders: enhancedInfo.responseHeaders,
      url: enhancedInfo.url,
      readyState: enhancedInfo.readyState,
      // Enhanced message with more context
      message: this.buildEnhancedErrorMessage(event, enhancedInfo)
    });
  }
  /**
   * Builds an enhanced error message with additional context information.
   *
   * @param event - The original error event
   * @param enhancedInfo - Additional error information
   * @returns A more descriptive error message
   */
  buildEnhancedErrorMessage(event, enhancedInfo) {
    let message = event.message || "WebSocket connection error";
    const details = [];
    if (enhancedInfo.statusCode) {
      details.push(`Status: ${enhancedInfo.statusCode}`);
    }
    if (enhancedInfo.requestId) {
      details.push(`Request ID: ${enhancedInfo.requestId}`);
    }
    if (enhancedInfo.readyState !== void 0) {
      const stateNames = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
      const stateName = stateNames[enhancedInfo.readyState] || `Unknown(${enhancedInfo.readyState})`;
      details.push(`Ready State: ${stateName}`);
    }
    if (enhancedInfo.url) {
      details.push(`URL: ${enhancedInfo.url}`);
    }
    if (details.length > 0) {
      message += ` (${details.join(", ")})`;
    }
    return message;
  }
  /**
   * Sets up the standard connection event handlers (open, close, error) for WebSocket connections.
   * This method abstracts the common connection event registration pattern used across all live clients.
   *
   * @param events - Object containing the event constants for the specific client type
   * @param events.Open - Event constant for connection open
   * @param events.Close - Event constant for connection close
   * @param events.Error - Event constant for connection error
   * @protected
   */
  setupConnectionEvents(events) {
    if (this.conn) {
      this.conn.onopen = () => {
        this.emit(events.Open, this);
      };
      this.conn.onclose = (event) => {
        this.emit(events.Close, event);
      };
      this.conn.onerror = (event) => {
        const enhancedInfo = this.extractErrorInformation(event, this.conn || void 0);
        const enhancedError = this.createEnhancedError(event, enhancedInfo);
        this.emit(events.Error, enhancedError);
      };
    }
  }
};
var WSWebSocketDummy = class {
  static {
    __name(this, "WSWebSocketDummy");
  }
  constructor(address, _protocols, options) {
    this.binaryType = "arraybuffer";
    this.onclose = () => {
    };
    this.onerror = () => {
    };
    this.onmessage = () => {
    };
    this.onopen = () => {
    };
    this.readyState = SOCKET_STATES.connecting;
    this.send = () => {
    };
    this.url = null;
    this.url = address.toString();
    this.close = options.close;
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/AbstractRestClient.js
init_modules_watch_stub();

// ../../node_modules/@deepgram/sdk/dist/module/lib/fetch.js
init_modules_watch_stub();
var import_cross_fetch2 = __toESM(require_browser_ponyfill());
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var resolveFetch = /* @__PURE__ */ __name((customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = import_cross_fetch2.default;
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
}, "resolveFetch");
var fetchWithAuth = /* @__PURE__ */ __name(({ apiKey, customFetch, accessToken }) => {
  const fetch2 = resolveFetch(customFetch);
  const HeadersConstructor = resolveHeadersConstructor();
  return (input, init) => __awaiter2(void 0, void 0, void 0, function* () {
    const headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
    if (!headers.has("Authorization")) {
      headers.set("Authorization", accessToken ? `Bearer ${accessToken}` : `Token ${apiKey}`);
    }
    return fetch2(input, Object.assign(Object.assign({}, init), { headers }));
  });
}, "fetchWithAuth");
var resolveResponse = /* @__PURE__ */ __name(() => __awaiter2(void 0, void 0, void 0, function* () {
  if (typeof Response === "undefined") {
    return (yield Promise.resolve().then(() => __toESM(require_browser_ponyfill()))).Response;
  }
  return Response;
}), "resolveResponse");

// ../../node_modules/@deepgram/sdk/dist/module/packages/AbstractRestClient.js
var import_deepmerge2 = __toESM(require_cjs());
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AbstractRestClient = class extends AbstractClient {
  static {
    __name(this, "AbstractRestClient");
  }
  /**
   * Constructs a new instance of the `AbstractRestClient` class with the provided options.
   *
   * @param options - The client options to use for this instance.
   * @throws {DeepgramError} If the client is being used in a browser and no proxy is provided.
   */
  constructor(options) {
    super(options);
    if (isBrowser() && !this.proxy) {
      throw new DeepgramError("Due to CORS we are unable to support REST-based API calls to our API from the browser. Please consider using a proxy: https://dpgr.am/js-proxy for more information.");
    }
    const { accessToken, key: apiKey, fetch: customFetch } = this;
    this.fetch = fetchWithAuth({ accessToken, apiKey, customFetch });
    if (this.proxy) {
      this.baseUrl = this.namespaceOptions.fetch.options.proxy.url;
    } else {
      this.baseUrl = this.namespaceOptions.fetch.options.url;
    }
  }
  /**
   * Constructs an error message from the provided error object.
   *
   * @param err - The error object to extract the error message from.
   * @returns The constructed error message.
   */
  _getErrorMessage(err) {
    return err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
  }
  /**
   * Handles an error that occurred during a request.
   *
   * @param error - The error that occurred during the request.
   * @param reject - The rejection function to call with the error.
   * @returns A Promise that resolves when the error has been handled.
   */
  _handleError(error, reject) {
    return __awaiter3(this, void 0, void 0, function* () {
      const Res = yield resolveResponse();
      if (error instanceof Res) {
        error.json().then((err) => {
          reject(new DeepgramApiError(this._getErrorMessage(err), error.status || 500));
        }).catch((err) => {
          reject(new DeepgramUnknownError(this._getErrorMessage(err), err));
        });
      } else {
        reject(new DeepgramUnknownError(this._getErrorMessage(error), error));
      }
    });
  }
  /**
   * Constructs the options object to be used for a fetch request.
   *
   * @param method - The HTTP method to use for the request, such as "GET", "POST", "PUT", "PATCH", or "DELETE".
   * @param bodyOrOptions - For "POST", "PUT", and "PATCH" requests, the request body as a string, Buffer, or Readable stream. For "GET" and "DELETE" requests, the fetch options to use.
   * @param options - Additional fetch options to use for the request.
   * @returns The constructed fetch options object.
   */
  _getRequestOptions(method, bodyOrOptions, options) {
    let reqOptions = { method };
    if (method === "GET" || method === "DELETE") {
      reqOptions = Object.assign(Object.assign({}, reqOptions), bodyOrOptions);
    } else {
      reqOptions = Object.assign(Object.assign({ duplex: "half", body: bodyOrOptions }, reqOptions), options);
    }
    return (0, import_deepmerge2.default)(this.namespaceOptions.fetch.options, reqOptions, { clone: false });
  }
  _handleRequest(method, url, bodyOrOptions, options) {
    return __awaiter3(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => {
        const fetcher = this.fetch;
        fetcher(url, this._getRequestOptions(method, bodyOrOptions, options)).then((result) => {
          if (!result.ok)
            throw result;
          resolve(result);
        }).catch((error) => this._handleError(error, reject));
      });
    });
  }
  /**
   * Handles an HTTP GET request using the provided URL and optional request options.
   *
   * @param url - The URL to send the GET request to.
   * @param options - Additional fetch options to use for the GET request.
   * @returns A Promise that resolves to the Response object for the GET request.
   */
  get(url, options) {
    return __awaiter3(this, void 0, void 0, function* () {
      return this._handleRequest("GET", url, options);
    });
  }
  /**
   * Handles an HTTP POST request using the provided URL, request body, and optional request options.
   *
   * @param url - The URL to send the POST request to.
   * @param body - The request body as a string, Buffer, or Readable stream.
   * @param options - Additional fetch options to use for the POST request.
   * @returns A Promise that resolves to the Response object for the POST request.
   */
  post(url, body, options) {
    return __awaiter3(this, void 0, void 0, function* () {
      return this._handleRequest("POST", url, body, options);
    });
  }
  /**
   * Handles an HTTP PUT request using the provided URL, request body, and optional request options.
   *
   * @param url - The URL to send the PUT request to.
   * @param body - The request body as a string, Buffer, or Readable stream.
   * @param options - Additional fetch options to use for the PUT request.
   * @returns A Promise that resolves to the Response object for the PUT request.
   */
  put(url, body, options) {
    return __awaiter3(this, void 0, void 0, function* () {
      return this._handleRequest("PUT", url, body, options);
    });
  }
  /**
   * Handles an HTTP PATCH request using the provided URL, request body, and optional request options.
   *
   * @param url - The URL to send the PATCH request to.
   * @param body - The request body as a string, Buffer, or Readable stream.
   * @param options - Additional fetch options to use for the PATCH request.
   * @returns A Promise that resolves to the Response object for the PATCH request.
   */
  patch(url, body, options) {
    return __awaiter3(this, void 0, void 0, function* () {
      return this._handleRequest("PATCH", url, body, options);
    });
  }
  /**
   * Handles an HTTP DELETE request using the provided URL and optional request options.
   *
   * @param url - The URL to send the DELETE request to.
   * @param options - Additional fetch options to use for the DELETE request.
   * @returns A Promise that resolves to the Response object for the DELETE request.
   */
  delete(url, options) {
    return __awaiter3(this, void 0, void 0, function* () {
      return this._handleRequest("DELETE", url, options);
    });
  }
  /**
   * Determines whether the current instance should proxy requests.
   * @returns {boolean} true if the current instance should proxy requests; otherwise, false
   */
  get proxy() {
    var _a;
    return this.key === "proxy" && !!((_a = this.namespaceOptions.fetch.options.proxy) === null || _a === void 0 ? void 0 : _a.url);
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/AgentLiveClient.js
init_modules_watch_stub();

// ../../node_modules/@deepgram/sdk/dist/module/lib/enums/AgentEvents.js
init_modules_watch_stub();
var AgentEvents;
(function(AgentEvents2) {
  AgentEvents2["Open"] = "Open";
  AgentEvents2["Close"] = "Close";
  AgentEvents2["Error"] = "Error";
  AgentEvents2["Audio"] = "Audio";
  AgentEvents2["Welcome"] = "Welcome";
  AgentEvents2["SettingsApplied"] = "SettingsApplied";
  AgentEvents2["ConversationText"] = "ConversationText";
  AgentEvents2["UserStartedSpeaking"] = "UserStartedSpeaking";
  AgentEvents2["AgentThinking"] = "AgentThinking";
  AgentEvents2["FunctionCallRequest"] = "FunctionCallRequest";
  AgentEvents2["AgentStartedSpeaking"] = "AgentStartedSpeaking";
  AgentEvents2["AgentAudioDone"] = "AgentAudioDone";
  AgentEvents2["InjectionRefused"] = "InjectionRefused";
  AgentEvents2["PromptUpdated"] = "PromptUpdated";
  AgentEvents2["SpeakUpdated"] = "SpeakUpdated";
  AgentEvents2["Unhandled"] = "Unhandled";
})(AgentEvents || (AgentEvents = {}));

// ../../node_modules/@deepgram/sdk/dist/module/packages/AgentLiveClient.js
var AgentLiveClient = class extends AbstractLiveClient {
  static {
    __name(this, "AgentLiveClient");
  }
  constructor(options, endpoint = "/:version/agent/converse") {
    var _a, _b, _c, _d;
    super(options);
    this.namespace = "agent";
    this.baseUrl = (_d = (_c = (_b = (_a = options.agent) === null || _a === void 0 ? void 0 : _a.websocket) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.url) !== null && _d !== void 0 ? _d : DEFAULT_AGENT_URL;
    this.connect({}, endpoint);
  }
  /**
   * Sets up the connection event handlers.
   * This method is responsible for handling the various events that can occur on the WebSocket connection, such as opening, closing, and receiving messages.
   * - When the connection is opened, it emits the `AgentEvents.Open` event.
   * - When the connection is closed, it emits the `AgentEvents.Close` event.
   * - When an error occurs on the connection, it emits the `AgentEvents.Error` event.
   * - When a message is received, it parses the message and emits the appropriate event based on the message type.
   */
  setupConnection() {
    this.setupConnectionEvents({
      Open: AgentEvents.Open,
      Close: AgentEvents.Close,
      Error: AgentEvents.Error
    });
    if (this.conn) {
      this.conn.onmessage = (event) => {
        this.handleMessage(event);
      };
    }
  }
  /**
   * Handles incoming messages from the WebSocket connection.
   * @param event - The MessageEvent object representing the received message.
   */
  handleMessage(event) {
    var _a, _b, _c, _d, _e, _f;
    if (typeof event.data === "string") {
      try {
        const data = JSON.parse(event.data);
        this.handleTextMessage(data);
      } catch (error) {
        this.emit(AgentEvents.Error, {
          event,
          data: ((_a = event.data) === null || _a === void 0 ? void 0 : _a.toString().substring(0, 200)) + (((_b = event.data) === null || _b === void 0 ? void 0 : _b.toString().length) > 200 ? "..." : ""),
          message: "Unable to parse `data` as JSON.",
          error,
          url: (_c = this.conn) === null || _c === void 0 ? void 0 : _c.url,
          readyState: (_d = this.conn) === null || _d === void 0 ? void 0 : _d.readyState
        });
      }
    } else if (event.data instanceof Blob) {
      event.data.arrayBuffer().then((buffer) => {
        this.handleBinaryMessage(Buffer.from(buffer));
      });
    } else if (event.data instanceof ArrayBuffer) {
      this.handleBinaryMessage(Buffer.from(event.data));
    } else if (Buffer.isBuffer(event.data)) {
      this.handleBinaryMessage(event.data);
    } else {
      console.log("Received unknown data type", event.data);
      this.emit(AgentEvents.Error, {
        event,
        message: "Received unknown data type.",
        url: (_e = this.conn) === null || _e === void 0 ? void 0 : _e.url,
        readyState: (_f = this.conn) === null || _f === void 0 ? void 0 : _f.readyState,
        dataType: typeof event.data
      });
    }
  }
  /**
   * Handles binary messages received from the WebSocket connection.
   * @param data - The binary data.
   */
  handleBinaryMessage(data) {
    this.emit(AgentEvents.Audio, data);
  }
  /**
   * Handles text messages received from the WebSocket connection.
   * @param data - The parsed JSON data.
   */
  handleTextMessage(data) {
    if (data.type in AgentEvents) {
      this.emit(data.type, data);
    } else {
      this.emit(AgentEvents.Unhandled, data);
    }
  }
  /**
   * To be called with your model configuration BEFORE sending
   * any audio data.
   * @param options - The SettingsConfiguration object.
   */
  configure(options) {
    const string = JSON.stringify(Object.assign({ type: "Settings" }, options));
    this.send(string);
  }
  /**
   * Provide new system prompt to the LLM.
   * @param prompt - The system prompt to provide.
   */
  updatePrompt(prompt) {
    this.send(JSON.stringify({ type: "UpdatePrompt", prompt }));
  }
  /**
   * Change the speak model.
   * @param model - The new model to use.
   */
  updateSpeak(speakConfig) {
    this.send(JSON.stringify({ type: "UpdateSpeak", speak: speakConfig }));
  }
  /**
   * Immediately trigger an agent message. If this message
   * is sent while the user is speaking, or while the server is in the
   * middle of sending audio, then the request will be ignored and an InjectionRefused
   * event will be emitted.
   * @example "Hold on while I look that up for you."
   * @example "Are you still on the line?"
   * @param content - The message to speak.
   */
  injectAgentMessage(content) {
    this.send(JSON.stringify({ type: "InjectAgentMessage", content }));
  }
  /**
   * Send a text-based message to the agent as if it came from the user.
   * This allows you to inject user messages into the conversation for the agent to respond to.
   * @example "Hello! Can you hear me?"
   * @example "What's the weather like today?"
   * @param content - The specific phrase or statement the agent should respond to.
   */
  injectUserMessage(content) {
    this.send(JSON.stringify({ type: "InjectUserMessage", content }));
  }
  /**
   * Respond to a function call request.
   * @param response  - The response to the function call request.
   */
  functionCallResponse(response) {
    this.send(JSON.stringify(Object.assign({ type: "FunctionCallResponse" }, response)));
  }
  /**
   * Send a keepalive to avoid closing the websocket while you
   * are not transmitting audio. This should be sent at least
   * every 8 seconds.
   */
  keepAlive() {
    this.send(JSON.stringify({ type: "KeepAlive" }));
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/AuthRestClient.js
init_modules_watch_stub();
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AuthRestClient = class extends AbstractRestClient {
  static {
    __name(this, "AuthRestClient");
  }
  constructor() {
    super(...arguments);
    this.namespace = "auth";
  }
  /**
   * Generates a new temporary token for the Deepgram API.
   * @param options Optional configuration options for the token generation. Includes ttl_seconds to set token expiration.
   * @param endpoint Optional custom endpoint to use for the request. Defaults to ":version/auth/grant".
   * @returns Object containing the result of the request or an error if one occurred. Result will contain access_token and expires_in properties.
   */
  grantToken(options = {}, endpoint = ":version/auth/grant") {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint);
        const body = JSON.stringify(options);
        const result = yield this.post(requestUrl, body, {
          headers: { "Content-Type": "application/json" }
        }).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/ListenClient.js
init_modules_watch_stub();

// ../../node_modules/@deepgram/sdk/dist/module/packages/ListenLiveClient.js
init_modules_watch_stub();

// ../../node_modules/@deepgram/sdk/dist/module/lib/enums/LiveTranscriptionEvents.js
init_modules_watch_stub();
var LiveTranscriptionEvents;
(function(LiveTranscriptionEvents2) {
  LiveTranscriptionEvents2["Open"] = "open";
  LiveTranscriptionEvents2["Close"] = "close";
  LiveTranscriptionEvents2["Error"] = "error";
  LiveTranscriptionEvents2["Transcript"] = "Results";
  LiveTranscriptionEvents2["Metadata"] = "Metadata";
  LiveTranscriptionEvents2["UtteranceEnd"] = "UtteranceEnd";
  LiveTranscriptionEvents2["SpeechStarted"] = "SpeechStarted";
  LiveTranscriptionEvents2["Unhandled"] = "Unhandled";
})(LiveTranscriptionEvents || (LiveTranscriptionEvents = {}));

// ../../node_modules/@deepgram/sdk/dist/module/lib/enums/LiveTTSEvents.js
init_modules_watch_stub();
var LiveTTSEvents;
(function(LiveTTSEvents2) {
  LiveTTSEvents2["Open"] = "Open";
  LiveTTSEvents2["Close"] = "Close";
  LiveTTSEvents2["Error"] = "Error";
  LiveTTSEvents2["Metadata"] = "Metadata";
  LiveTTSEvents2["Flushed"] = "Flushed";
  LiveTTSEvents2["Warning"] = "Warning";
  LiveTTSEvents2["Audio"] = "Audio";
  LiveTTSEvents2["Unhandled"] = "Unhandled";
})(LiveTTSEvents || (LiveTTSEvents = {}));

// ../../node_modules/@deepgram/sdk/dist/module/packages/ListenLiveClient.js
var ListenLiveClient = class extends AbstractLiveClient {
  static {
    __name(this, "ListenLiveClient");
  }
  /**
   * Constructs a new `ListenLiveClient` instance with the provided options.
   *
   * @param options - The `DeepgramClientOptions` to use for the client connection.
   * @param transcriptionOptions - An optional `LiveSchema` object containing additional configuration options for the live transcription.
   * @param endpoint - An optional string representing the WebSocket endpoint to connect to. Defaults to `:version/listen`.
   */
  constructor(options, transcriptionOptions = {}, endpoint = ":version/listen") {
    var _a, _b;
    super(options);
    this.namespace = "listen";
    if (((_a = transcriptionOptions.keyterm) === null || _a === void 0 ? void 0 : _a.length) && !((_b = transcriptionOptions.model) === null || _b === void 0 ? void 0 : _b.startsWith("nova-3"))) {
      throw new DeepgramError("Keyterms are only supported with the Nova 3 models.");
    }
    this.connect(transcriptionOptions, endpoint);
  }
  /**
   * Sets up the connection event handlers.
   * This method is responsible for handling the various events that can occur on the WebSocket connection, such as opening, closing, and receiving messages.
   * - When the connection is opened, it emits the `LiveTranscriptionEvents.Open` event.
   * - When the connection is closed, it emits the `LiveTranscriptionEvents.Close` event.
   * - When an error occurs on the connection, it emits the `LiveTranscriptionEvents.Error` event.
   * - When a message is received, it parses the message and emits the appropriate event based on the message type, such as `LiveTranscriptionEvents.Metadata`, `LiveTranscriptionEvents.Transcript`, `LiveTranscriptionEvents.UtteranceEnd`, and `LiveTranscriptionEvents.SpeechStarted`.
   */
  setupConnection() {
    this.setupConnectionEvents({
      Open: LiveTranscriptionEvents.Open,
      Close: LiveTranscriptionEvents.Close,
      Error: LiveTranscriptionEvents.Error
    });
    if (this.conn) {
      this.conn.onmessage = (event) => {
        var _a, _b, _c, _d;
        try {
          const data = JSON.parse(event.data.toString());
          if (data.type === LiveTranscriptionEvents.Metadata) {
            this.emit(LiveTranscriptionEvents.Metadata, data);
          } else if (data.type === LiveTranscriptionEvents.Transcript) {
            this.emit(LiveTranscriptionEvents.Transcript, data);
          } else if (data.type === LiveTranscriptionEvents.UtteranceEnd) {
            this.emit(LiveTranscriptionEvents.UtteranceEnd, data);
          } else if (data.type === LiveTranscriptionEvents.SpeechStarted) {
            this.emit(LiveTranscriptionEvents.SpeechStarted, data);
          } else {
            this.emit(LiveTranscriptionEvents.Unhandled, data);
          }
        } catch (error) {
          this.emit(LiveTranscriptionEvents.Error, {
            event,
            message: "Unable to parse `data` as JSON.",
            error,
            url: (_a = this.conn) === null || _a === void 0 ? void 0 : _a.url,
            readyState: (_b = this.conn) === null || _b === void 0 ? void 0 : _b.readyState,
            data: ((_c = event.data) === null || _c === void 0 ? void 0 : _c.toString().substring(0, 200)) + (((_d = event.data) === null || _d === void 0 ? void 0 : _d.toString().length) > 200 ? "..." : "")
          });
        }
      };
    }
  }
  /**
   * Sends additional config to the connected session.
   *
   * @param config - The configuration options to apply to the LiveClient.
   * @param config.numerals - We currently only support numerals.
   */
  configure(config) {
    this.send(JSON.stringify({
      type: "Configure",
      processors: config
    }));
  }
  /**
   * Sends a "KeepAlive" message to the server to maintain the connection.
   */
  keepAlive() {
    this.send(JSON.stringify({
      type: "KeepAlive"
    }));
  }
  /**
   * Sends a "Finalize" message to flush any transcription sitting in the server's buffer.
   */
  finalize() {
    this.send(JSON.stringify({
      type: "Finalize"
    }));
  }
  /**
   * @deprecated Since version 3.4. Will be removed in version 4.0. Use `requestClose` instead.
   */
  finish() {
    this.requestClose();
  }
  /**
   * Requests the server close the connection.
   */
  requestClose() {
    this.send(JSON.stringify({
      type: "CloseStream"
    }));
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/ListenRestClient.js
init_modules_watch_stub();
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ListenRestClient = class extends AbstractRestClient {
  static {
    __name(this, "ListenRestClient");
  }
  constructor() {
    super(...arguments);
    this.namespace = "listen";
  }
  /**
   * Transcribes audio from a URL synchronously.
   *
   * @param source - The URL source object containing the audio URL to transcribe.
   * @param options - An optional `PrerecordedSchema` object containing additional options for the transcription.
   * @param endpoint - An optional endpoint string to use for the transcription request.
   * @returns A `DeepgramResponse` object containing the transcription result or an error.
   */
  transcribeUrl(source, options, endpoint = ":version/listen") {
    var _a, _b;
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        let body;
        if (isUrlSource(source)) {
          body = JSON.stringify(source);
        } else {
          throw new DeepgramError("Unknown transcription source type");
        }
        if (options !== void 0 && "callback" in options) {
          throw new DeepgramError("Callback cannot be provided as an option to a synchronous transcription. Use `transcribeUrlCallback` or `transcribeFileCallback` instead.");
        }
        if (((_a = options === null || options === void 0 ? void 0 : options.keyterm) === null || _a === void 0 ? void 0 : _a.length) && !((_b = options.model) === null || _b === void 0 ? void 0 : _b.startsWith("nova-3"))) {
          throw new DeepgramError("Keyterms are only supported with the Nova 3 models.");
        }
        const requestUrl = this.getRequestUrl(endpoint, {}, Object.assign({}, options));
        const result = yield this.post(requestUrl, body).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Transcribes audio from a file asynchronously.
   *
   * @param source - The file source object containing the audio file to transcribe.
   * @param options - An optional `PrerecordedSchema` object containing additional options for the transcription.
   * @param endpoint - An optional endpoint string to use for the transcription request.
   * @returns A `DeepgramResponse` object containing the transcription result or an error.
   */
  transcribeFile(source, options, endpoint = ":version/listen") {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        let body;
        if (isFileSource(source)) {
          body = source;
        } else {
          throw new DeepgramError("Unknown transcription source type");
        }
        if (options !== void 0 && "callback" in options) {
          throw new DeepgramError("Callback cannot be provided as an option to a synchronous transcription. Use `transcribeUrlCallback` or `transcribeFileCallback` instead.");
        }
        const requestUrl = this.getRequestUrl(endpoint, {}, Object.assign({}, options));
        const result = yield this.post(requestUrl, body, {
          headers: { "Content-Type": "deepgram/audio+video" }
        }).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Transcribes audio from a URL asynchronously.
   *
   * @param source - The URL source object containing the audio file to transcribe.
   * @param callback - The callback URL to receive the transcription result.
   * @param options - An optional `PrerecordedSchema` object containing additional options for the transcription.
   * @param endpoint - An optional endpoint string to use for the transcription request.
   * @returns A `DeepgramResponse` object containing the transcription result or an error.
   */
  transcribeUrlCallback(source, callback, options, endpoint = ":version/listen") {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        let body;
        if (isUrlSource(source)) {
          body = JSON.stringify(source);
        } else {
          throw new DeepgramError("Unknown transcription source type");
        }
        const requestUrl = this.getRequestUrl(endpoint, {}, Object.assign(Object.assign({}, options), { callback: callback.toString() }));
        const result = yield this.post(requestUrl, body).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Transcribes audio from a file asynchronously.
   *
   * @param source - The file source object containing the audio file to transcribe.
   * @param callback - The callback URL to receive the transcription result.
   * @param options - An optional `PrerecordedSchema` object containing additional options for the transcription.
   * @param endpoint - An optional endpoint string to use for the transcription request.
   * @returns A `DeepgramResponse` object containing the transcription result or an error.
   */
  transcribeFileCallback(source, callback, options, endpoint = ":version/listen") {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        let body;
        if (isFileSource(source)) {
          body = source;
        } else {
          throw new DeepgramError("Unknown transcription source type");
        }
        const requestUrl = this.getRequestUrl(endpoint, {}, Object.assign(Object.assign({}, options), { callback: callback.toString() }));
        const result = yield this.post(requestUrl, body, {
          headers: { "Content-Type": "deepgram/audio+video" }
        }).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/ListenClient.js
var ListenClient = class extends AbstractClient {
  static {
    __name(this, "ListenClient");
  }
  constructor() {
    super(...arguments);
    this.namespace = "listen";
  }
  /**
   * Returns a `ListenRestClient` instance for interacting with the prerecorded listen API.
   */
  get prerecorded() {
    return new ListenRestClient(this.options);
  }
  /**
   * Returns a `ListenLiveClient` instance for interacting with the live listen API, with the provided transcription options and endpoint.
   * @param {LiveSchema} [transcriptionOptions={}] - The transcription options to use for the live listen API.
   * @param {string} [endpoint=":version/listen"] - The endpoint to use for the live listen API.
   * @returns {ListenLiveClient} - A `ListenLiveClient` instance for interacting with the live listen API.
   */
  live(transcriptionOptions = {}, endpoint = ":version/listen") {
    return new ListenLiveClient(this.options, transcriptionOptions, endpoint);
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/ManageRestClient.js
init_modules_watch_stub();
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ManageRestClient = class extends AbstractRestClient {
  static {
    __name(this, "ManageRestClient");
  }
  constructor() {
    super(...arguments);
    this.namespace = "manage";
  }
  /**
   * Retrieves the details of the current authentication token.
   *
   * @returns A promise that resolves to an object containing the token details, or an error object if an error occurs.
   * @see https://developers.deepgram.com/docs/authenticating#test-request
   */
  getTokenDetails(endpoint = ":version/auth/token") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint);
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves a list of all projects associated with the authenticated user.
   *
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects".
   * @returns A promise that resolves to an object containing the list of projects, or an error object if an error occurs.
   * @see https://developers.deepgram.com/reference/get-projects
   */
  getProjects(endpoint = ":version/projects") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint);
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of a specific project associated with the authenticated user.
   *
   * @param projectId - The ID of the project to retrieve.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId".
   * @returns A promise that resolves to an object containing the project details, or an error object if an error occurs.
   * @see https://developers.deepgram.com/reference/get-project
   */
  getProject(projectId, endpoint = ":version/projects/:projectId") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId });
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Updates an existing project associated with the authenticated user.
   *
   * @param projectId - The ID of the project to update.
   * @param options - An object containing the updated project details.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId".
   * @returns A promise that resolves to an object containing the response message, or an error object if an error occurs.
   * @see https://developers.deepgram.com/reference/update-project
   */
  updateProject(projectId, options, endpoint = ":version/projects/:projectId") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId }, options);
        const body = JSON.stringify(options);
        const result = yield this.patch(requestUrl, body).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes an existing project associated with the authenticated user.
   *
   * @param projectId - The ID of the project to delete.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId".
   * @returns A promise that resolves to an object containing the response message, or an error object if an error occurs.
   * @see https://developers.deepgram.com/reference/delete-project
   */
  deleteProject(projectId, endpoint = ":version/projects/:projectId") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId });
        yield this.delete(requestUrl);
        return { error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves a list of project keys associated with the specified project.
   *
   * @param projectId - The ID of the project to retrieve the keys for.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/keys".
   * @returns A promise that resolves to an object containing the list of project keys, or an error object if an error occurs.
   * @see https://developers.deepgram.com/reference/list-keys
   */
  getProjectKeys(projectId, endpoint = ":version/projects/:projectId/keys") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId });
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves a specific project key associated with the specified project.
   *
   * @param projectId - The ID of the project to retrieve the key for.
   * @param keyId - The ID of the project key to retrieve.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/keys/:keyId".
   * @returns A promise that resolves to an object containing the project key, or an error object if an error occurs.
   * @see https://developers.deepgram.com/reference/get-key
   */
  getProjectKey(projectId, keyId, endpoint = ":version/projects/:projectId/keys/:keyId") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId, keyId });
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a new project key for the specified project.
   *
   * @param projectId - The ID of the project to create the key for.
   * @param options - An object containing the options for creating the project key.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/keys".
   * @returns A promise that resolves to an object containing the created project key, or an error object if an error occurs.
   * @see https://developers.deepgram.com/reference/create-key
   */
  createProjectKey(projectId, options, endpoint = ":version/projects/:projectId/keys") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId }, options);
        const body = JSON.stringify(options);
        const result = yield this.post(requestUrl, body).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes the specified project key.
   *
   * @param projectId - The ID of the project the key belongs to.
   * @param keyId - The ID of the key to delete.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/keys/:keyId".
   * @returns A promise that resolves to an object containing a null result and an error object if an error occurs.
   * @see https://developers.deepgram.com/reference/delete-key
   */
  deleteProjectKey(projectId, keyId, endpoint = ":version/projects/:projectId/keys/:keyId") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId, keyId });
        yield this.delete(requestUrl);
        return { error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the members of the specified project.
   *
   * @param projectId - The ID of the project to retrieve members for.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/members".
   * @returns A promise that resolves to an object containing the project members and an error object if an error occurs.
   * @see https://developers.deepgram.com/reference/get-members
   */
  getProjectMembers(projectId, endpoint = ":version/projects/:projectId/members") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId });
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Removes a member from the specified project.
   *
   * @param projectId - The ID of the project to remove the member from.
   * @param memberId - The ID of the member to remove.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/members/:memberId".
   * @returns A promise that resolves to an object containing a null error if the operation was successful, or an error object if an error occurred.
   * @see https://developers.deepgram.com/reference/remove-member
   */
  removeProjectMember(projectId, memberId, endpoint = ":version/projects/:projectId/members/:memberId") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId, memberId });
        yield this.delete(requestUrl);
        return { error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the scopes for the specified project member.
   *
   * @param projectId - The ID of the project to retrieve the member scopes for.
   * @param memberId - The ID of the member to retrieve the scopes for.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/members/:memberId/scopes".
   * @returns A promise that resolves to an object containing the retrieved scopes or an error object if an error occurred.
   * @see https://developers.deepgram.com/reference/get-member-scopes
   */
  getProjectMemberScopes(projectId, memberId, endpoint = ":version/projects/:projectId/members/:memberId/scopes") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId, memberId });
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Updates the scopes for the specified project member.
   *
   * @param projectId - The ID of the project to update the member scopes for.
   * @param memberId - The ID of the member to update the scopes for.
   * @param options - An object containing the new scopes to apply to the member.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/members/:memberId/scopes".
   * @returns A promise that resolves to an object containing the result of the update operation or an error object if an error occurred.
   * @see https://developers.deepgram.com/reference/update-scope
   */
  updateProjectMemberScope(projectId, memberId, options, endpoint = ":version/projects/:projectId/members/:memberId/scopes") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId, memberId }, options);
        const body = JSON.stringify(options);
        const result = yield this.put(requestUrl, body).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the project invites for the specified project.
   *
   * @param projectId - The ID of the project to retrieve the invites for.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/invites".
   * @returns A promise that resolves to an object containing the result of the get operation or an error object if an error occurred.
   * @see https://developers.deepgram.com/reference/list-invites
   */
  getProjectInvites(projectId, endpoint = ":version/projects/:projectId/invites") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId });
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Sends a project invite to the specified email addresses.
   *
   * @param projectId - The ID of the project to send the invite for.
   * @param options - An object containing the email addresses to invite and any additional options.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/invites".
   * @returns A promise that resolves to an object containing the result of the post operation or an error object if an error occurred.
   * @see https://developers.deepgram.com/reference/send-invites
   */
  sendProjectInvite(projectId, options, endpoint = ":version/projects/:projectId/invites") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId }, options);
        const body = JSON.stringify(options);
        const result = yield this.post(requestUrl, body).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes a project invite for the specified email address.
   *
   * @param projectId - The ID of the project to delete the invite for.
   * @param email - The email address of the invite to delete.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/invites/:email".
   * @returns A promise that resolves to an object containing a null result and an error object if an error occurred.
   * @see https://developers.deepgram.com/reference/delete-invite
   */
  deleteProjectInvite(projectId, email, endpoint = ":version/projects/:projectId/invites/:email") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId, email });
        yield this.delete(requestUrl);
        return { error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { error };
        }
        throw error;
      }
    });
  }
  /**
   * Leaves the specified project.
   *
   * @param projectId - The ID of the project to leave.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/leave".
   * @returns A promise that resolves to an object containing a null result and an error object if an error occurred.
   * @see https://developers.deepgram.com/reference/leave-project
   */
  leaveProject(projectId, endpoint = ":version/projects/:projectId/leave") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId });
        const result = yield this.delete(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves a list of usage requests for the specified project.
   *
   * @param projectId - The ID of the project to retrieve usage requests for.
   * @param options - An object containing options to filter the usage requests, such as pagination parameters.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/requests".
   * @returns A promise that resolves to an object containing the list of usage requests and an error object if an error occurred.
   * @see https://developers.deepgram.com/reference/get-all-requests
   */
  getProjectUsageRequests(projectId, options, endpoint = ":version/projects/:projectId/requests") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId }, options);
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of a specific usage request for the specified project.
   *
   * @param projectId - The ID of the project to retrieve the usage request for.
   * @param requestId - The ID of the usage request to retrieve.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/requests/:requestId".
   * @returns A promise that resolves to an object containing the usage request details and an error object if an error occurred.
   * @see https://developers.deepgram.com/reference/get-request
   */
  getProjectUsageRequest(projectId, requestId, endpoint = ":version/projects/:projectId/requests/:requestId") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId, requestId });
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the usage summary for the specified project.
   *
   * @param projectId - The ID of the project to retrieve the usage summary for.
   * @param options - An object containing optional parameters for the request, such as filters and pagination options.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/usage".
   * @returns A promise that resolves to an object containing the usage summary and an error object if an error occurred.
   * @see https://developers.deepgram.com/reference/get-usage
   */
  getProjectUsageSummary(projectId, options, endpoint = ":version/projects/:projectId/usage") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId }, options);
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the usage fields for the specified project.
   *
   * @param projectId - The ID of the project to retrieve the usage fields for.
   * @param options - An object containing optional parameters for the request, such as filters and pagination options.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/usage/fields".
   * @returns A promise that resolves to an object containing the usage fields and an error object if an error occurred.
   * @see https://developers.deepgram.com/reference/get-fields
   */
  getProjectUsageFields(projectId, options, endpoint = ":version/projects/:projectId/usage/fields") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId }, options);
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the balances for the specified project.
   *
   * @param projectId - The ID of the project to retrieve the balances for.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/balances".
   * @returns A promise that resolves to an object containing the project balances and an error object if an error occurred.
   * @see https://developers.deepgram.com/reference/get-all-balances
   */
  getProjectBalances(projectId, endpoint = ":version/projects/:projectId/balances") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId });
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the balance for the specified project and balance ID.
   *
   * @param projectId - The ID of the project to retrieve the balance for.
   * @param balanceId - The ID of the balance to retrieve.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/projects/:projectId/balances/:balanceId".
   * @returns A promise that resolves to an object containing the project balance and an error object if an error occurred.
   * @see https://developers.deepgram.com/reference/get-balance
   */
  getProjectBalance(projectId, balanceId, endpoint = ":version/projects/:projectId/balances/:balanceId") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId, balanceId });
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves all models for a given project.
   *
   * @param projectId - The ID of the project.
   * @param endpoint - (optional) The endpoint URL for retrieving models. Defaults to ":version/projects/:projectId/models".
   * @returns A promise that resolves to a DeepgramResponse containing the GetModelsResponse.
   * @example
   * ```typescript
   * import { createClient } from "@deepgram/sdk";
   *
   * const deepgram = createClient(DEEPGRAM_API_KEY);
   * const { result: models, error } = deepgram.manage.getAllModels("projectId");
   *
   * if (error) {
   *   console.error(error);
   * } else {
   *   console.log(models);
   * }
   * ```
   */
  getAllModels(projectId, options = {}, endpoint = ":version/projects/:projectId/models") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId }, options);
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves a model from the specified project.
   *
   * @param projectId - The ID of the project.
   * @param modelId - The ID of the model.
   * @param endpoint - (optional) The endpoint URL for the request. Default value is ":version/projects/:projectId/models/:modelId".
   * @returns A promise that resolves to a DeepgramResponse containing the GetModelResponse.
   * @example
   * ```typescript
   * import { createClient } from "@deepgram/sdk";
   *
   * const deepgram = createClient(DEEPGRAM_API_KEY);
   * const { result: model, error } = deepgram.models.getModel("projectId", "modelId");
   *
   * if (error) {
   *   console.error(error);
   * } else {
   *   console.log(model);
   * }
   * ```
   */
  getModel(projectId, modelId, endpoint = ":version/projects/:projectId/models/:modelId") {
    return __awaiter6(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId, modelId });
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/ModelsRestClient.js
init_modules_watch_stub();
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ModelsRestClient = class extends AbstractRestClient {
  static {
    __name(this, "ModelsRestClient");
  }
  constructor() {
    super(...arguments);
    this.namespace = "models";
  }
  /**
   * Retrieves a list of all available models.
   *
   * @param endpoint - (optional) The endpoint to request.
   * @returns A promise that resolves with the response from the Deepgram API.
   * @example
   * ```typescript
   * import { createClient } from "@deepgram/sdk";
   *
   * const deepgram = createClient(DEEPGRAM_API_KEY);
   * const { result: models, error } = deepgram.models.getAll();
   *
   * if (error) {
   *   console.error(error);
   * } else {
   *   console.log(models);
   * }
   * ```
   */
  getAll(endpoint = ":version/models", options = {}) {
    return __awaiter7(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, {}, options);
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves information about a specific model.
   *
   * @param modelId - The UUID of the model to retrieve.
   * @param endpoint - (optional) The endpoint to request.
   * @returns A promise that resolves with the response from the Deepgram API.
   * @example
   * ```typescript
   * import { createClient } from "@deepgram/sdk";
   *
   * const deepgram = createClient(DEEPGRAM_API_KEY);
   * const { result: model, error } = deepgram.models.getModel("modelId");
   *
   * if (error) {
   *   console.error(error);
   * } else {
   *   console.log(model);
   * }
   * ```
   */
  getModel(modelId, endpoint = ":version/models/:modelId") {
    return __awaiter7(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { modelId });
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/ReadRestClient.js
init_modules_watch_stub();
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ReadRestClient = class extends AbstractRestClient {
  static {
    __name(this, "ReadRestClient");
  }
  constructor() {
    super(...arguments);
    this.namespace = "read";
  }
  /**
   * Analyzes a URL-based audio source synchronously.
   *
   * @param source - The URL-based audio source to analyze.
   * @param options - Optional analysis options.
   * @param endpoint - The API endpoint to use for the analysis. Defaults to ":version/read".
   * @returns A promise that resolves to the analysis response, or an error if the analysis fails.
   */
  analyzeUrl(source, options, endpoint = ":version/read") {
    return __awaiter8(this, void 0, void 0, function* () {
      try {
        let body;
        if (isUrlSource(source)) {
          body = JSON.stringify(source);
        } else {
          throw new DeepgramError("Unknown source type");
        }
        if (options !== void 0 && "callback" in options) {
          throw new DeepgramError("Callback cannot be provided as an option to a synchronous transcription. Use `analyzeUrlCallback` or `analyzeTextCallback` instead.");
        }
        const requestUrl = this.getRequestUrl(endpoint, {}, Object.assign({}, options));
        const result = yield this.post(requestUrl, body).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Analyzes a text-based audio source synchronously.
   *
   * @param source - The text-based audio source to analyze.
   * @param options - Optional analysis options.
   * @param endpoint - The API endpoint to use for the analysis. Defaults to ":version/read".
   * @returns A promise that resolves to the analysis response, or an error if the analysis fails.
   */
  analyzeText(source, options, endpoint = ":version/read") {
    return __awaiter8(this, void 0, void 0, function* () {
      try {
        let body;
        if (isTextSource(source)) {
          body = JSON.stringify(source);
        } else {
          throw new DeepgramError("Unknown source type");
        }
        if (options !== void 0 && "callback" in options) {
          throw new DeepgramError("Callback cannot be provided as an option to a synchronous requests. Use `analyzeUrlCallback` or `analyzeTextCallback` instead.");
        }
        const requestUrl = this.getRequestUrl(endpoint, {}, Object.assign({}, options));
        const result = yield this.post(requestUrl, body).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Analyzes a URL-based audio source asynchronously.
   *
   * @param source - The URL-based audio source to analyze.
   * @param callback - The URL to call back with the analysis results.
   * @param options - Optional analysis options.
   * @param endpoint - The API endpoint to use for the analysis. Defaults to ":version/read".
   * @returns A promise that resolves to the analysis response, or an error if the analysis fails.
   */
  analyzeUrlCallback(source, callback, options, endpoint = ":version/read") {
    return __awaiter8(this, void 0, void 0, function* () {
      try {
        let body;
        if (isUrlSource(source)) {
          body = JSON.stringify(source);
        } else {
          throw new DeepgramError("Unknown source type");
        }
        const requestUrl = this.getRequestUrl(endpoint, {}, Object.assign(Object.assign({}, options), { callback: callback.toString() }));
        const result = yield this.post(requestUrl, body).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Analyzes a text-based audio source asynchronously.
   *
   * @param source - The text-based audio source to analyze.
   * @param callback - The URL to call back with the analysis results.
   * @param options - Optional analysis options.
   * @param endpoint - The API endpoint to use for the analysis. Defaults to ":version/read".
   * @returns A promise that resolves to the analysis response, or an error if the analysis fails.
   */
  analyzeTextCallback(source, callback, options, endpoint = ":version/read") {
    return __awaiter8(this, void 0, void 0, function* () {
      try {
        let body;
        if (isTextSource(source)) {
          body = JSON.stringify(source);
        } else {
          throw new DeepgramError("Unknown source type");
        }
        const requestUrl = this.getRequestUrl(endpoint, {}, Object.assign(Object.assign({}, options), { callback: callback.toString() }));
        const result = yield this.post(requestUrl, body, {
          headers: { "Content-Type": "deepgram/audio+video" }
        }).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/SelfHostedRestClient.js
init_modules_watch_stub();
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SelfHostedRestClient = class extends AbstractRestClient {
  static {
    __name(this, "SelfHostedRestClient");
  }
  constructor() {
    super(...arguments);
    this.namespace = "selfhosted";
  }
  /**
   * Lists the self-hosted credentials for a Deepgram project.
   *
   * @param projectId - The ID of the Deepgram project.
   * @returns A promise that resolves to an object containing the list of self-hosted credentials and any error that occurred.
   * @see https://developers.deepgram.com/reference/list-credentials
   */
  listCredentials(projectId, endpoint = ":version/projects/:projectId/onprem/distribution/credentials") {
    return __awaiter9(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId });
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the self-hosted credentials for a specific Deepgram project and credentials ID.
   *
   * @param projectId - The ID of the Deepgram project.
   * @param credentialsId - The ID of the self-hosted credentials to retrieve.
   * @returns A promise that resolves to an object containing the self-hosted credentials and any error that occurred.
   * @see https://developers.deepgram.com/reference/get-credentials
   */
  getCredentials(projectId, credentialsId, endpoint = ":version/projects/:projectId/onprem/distribution/credentials/:credentialsId") {
    return __awaiter9(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId, credentialsId });
        const result = yield this.get(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates self-hosted credentials for a specific Deepgram project.
   *
   * @param projectId - The ID of the Deepgram project.
   * @param options - The options for creating the self-hosted credentials.
   * @returns A promise that resolves to an object containing the created self-hosted credentials and any error that occurred.
   * @see https://developers.deepgram.com/reference/create-credentials
   */
  createCredentials(projectId, options, endpoint = ":version/projects/:projectId/onprem/distribution/credentials") {
    return __awaiter9(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId });
        const body = JSON.stringify(options);
        const result = yield this.post(requestUrl, body).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes self-hosted credentials for a specific Deepgram project.
   *
   * @param projectId - The ID of the Deepgram project.
   * @param credentialsId - The ID of the self-hosted credentials to delete.
   * @returns A promise that resolves to an object containing a message response and any error that occurred.
   * @see https://developers.deepgram.com/reference/delete-credentials
   */
  deleteCredentials(projectId, credentialsId, endpoint = ":version/projects/:projectId/onprem/distribution/credentials/:credentialsId") {
    return __awaiter9(this, void 0, void 0, function* () {
      try {
        const requestUrl = this.getRequestUrl(endpoint, { projectId, credentialsId });
        const result = yield this.delete(requestUrl).then((result2) => result2.json());
        return { result, error: null };
      } catch (error) {
        if (isDeepgramError(error)) {
          return { result: null, error };
        }
        throw error;
      }
    });
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/SpeakClient.js
init_modules_watch_stub();

// ../../node_modules/@deepgram/sdk/dist/module/packages/SpeakLiveClient.js
init_modules_watch_stub();
var SpeakLiveClient = class extends AbstractLiveClient {
  static {
    __name(this, "SpeakLiveClient");
  }
  /**
   * Constructs a new `SpeakLiveClient` instance with the provided options.
   *
   * @param options - The `DeepgramClientOptions` to use for the client connection.
   * @param speakOptions - An optional `SpeakSchema` object containing additional configuration options for the text-to-speech.
   * @param endpoint - An optional string representing the WebSocket endpoint to connect to. Defaults to `:version/speak`.
   */
  constructor(options, speakOptions = {}, endpoint = ":version/speak") {
    super(options);
    this.namespace = "speak";
    this.connect(speakOptions, endpoint);
  }
  /**
   * Sets up the connection event handlers.
   * This method is responsible for handling the various events that can occur on the WebSocket connection, such as opening, closing, and receiving data.
   * - When the connection is opened, it emits the `LiveTTSEvents.Open` event.
   * - When the connection is closed, it emits the `LiveTTSEvents.Close` event.
   * - When an error occurs on the connection, it emits the `LiveTTSEvents.Error` event.
   * - When a message is received, it parses the message and emits the appropriate event based on the message type, such as `LiveTTSEvents.Metadata`, `LiveTTSEvents.Flushed`, and `LiveTTSEvents.Warning`.
   */
  setupConnection() {
    this.setupConnectionEvents({
      Open: LiveTTSEvents.Open,
      Close: LiveTTSEvents.Close,
      Error: LiveTTSEvents.Error
    });
    if (this.conn) {
      this.conn.onmessage = (event) => {
        this.handleMessage(event);
      };
    }
  }
  /**
   * Handles text messages received from the WebSocket connection.
   * @param data - The parsed JSON data.
   */
  handleTextMessage(data) {
    if (data.type === LiveTTSEvents.Metadata) {
      this.emit(LiveTTSEvents.Metadata, data);
    } else if (data.type === LiveTTSEvents.Flushed) {
      this.emit(LiveTTSEvents.Flushed, data);
    } else if (data.type === LiveTTSEvents.Warning) {
      this.emit(LiveTTSEvents.Warning, data);
    } else {
      this.emit(LiveTTSEvents.Unhandled, data);
    }
  }
  /**
   * Handles binary messages received from the WebSocket connection.
   * @param data - The binary data.
   */
  handleBinaryMessage(data) {
    this.emit(LiveTTSEvents.Audio, data);
  }
  /**
   * Sends a text input message to the server.
   *
   * @param {string} text - The text to convert to speech.
   */
  sendText(text) {
    this.send(JSON.stringify({
      type: "Speak",
      text
    }));
  }
  /**
   * Requests the server flush the current buffer and return generated audio.
   */
  flush() {
    this.send(JSON.stringify({
      type: "Flush"
    }));
  }
  /**
   * Requests the server clear the current buffer.
   */
  clear() {
    this.send(JSON.stringify({
      type: "Clear"
    }));
  }
  /**
   * Requests the server close the connection.
   */
  requestClose() {
    this.send(JSON.stringify({
      type: "Close"
    }));
  }
  /**
   * Handles incoming messages from the WebSocket connection.
   * @param event - The MessageEvent object representing the received message.
   */
  handleMessage(event) {
    var _a, _b, _c, _d, _e, _f;
    if (typeof event.data === "string") {
      try {
        const data = JSON.parse(event.data);
        this.handleTextMessage(data);
      } catch (error) {
        this.emit(LiveTTSEvents.Error, {
          event,
          message: "Unable to parse `data` as JSON.",
          error,
          url: (_a = this.conn) === null || _a === void 0 ? void 0 : _a.url,
          readyState: (_b = this.conn) === null || _b === void 0 ? void 0 : _b.readyState,
          data: ((_c = event.data) === null || _c === void 0 ? void 0 : _c.toString().substring(0, 200)) + (((_d = event.data) === null || _d === void 0 ? void 0 : _d.toString().length) > 200 ? "..." : "")
        });
      }
    } else if (event.data instanceof Blob) {
      event.data.arrayBuffer().then((buffer) => {
        this.handleBinaryMessage(Buffer.from(buffer));
      });
    } else if (event.data instanceof ArrayBuffer) {
      this.handleBinaryMessage(Buffer.from(event.data));
    } else if (Buffer.isBuffer(event.data)) {
      this.handleBinaryMessage(event.data);
    } else {
      console.log("Received unknown data type", event.data);
      this.emit(LiveTTSEvents.Error, {
        event,
        message: "Received unknown data type.",
        url: (_e = this.conn) === null || _e === void 0 ? void 0 : _e.url,
        readyState: (_f = this.conn) === null || _f === void 0 ? void 0 : _f.readyState,
        dataType: typeof event.data
      });
    }
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/SpeakRestClient.js
init_modules_watch_stub();
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SpeakRestClient = class extends AbstractRestClient {
  static {
    __name(this, "SpeakRestClient");
  }
  constructor() {
    super(...arguments);
    this.namespace = "speak";
  }
  /**
   * Sends a request to the Deepgram Text-to-Speech API to generate audio from the provided text source.
   *
   * @param source - The text source to be converted to audio.
   * @param options - Optional configuration options for the text-to-speech request.
   * @param endpoint - The API endpoint to use for the request. Defaults to ":version/speak".
   * @returns A promise that resolves to the SpeakRestClient instance, which can be used to retrieve the response headers and body.
   * @throws {DeepgramError} If the text source type is unknown.
   * @throws {DeepgramUnknownError} If the request was made before a previous request completed.
   * @see https://developers.deepgram.com/reference/text-to-speech-api
   */
  request(source, options, endpoint = ":version/speak") {
    return __awaiter10(this, void 0, void 0, function* () {
      let body;
      if (isTextSource(source)) {
        body = JSON.stringify(source);
      } else {
        throw new DeepgramError("Unknown transcription source type");
      }
      const requestUrl = this.getRequestUrl(endpoint, {}, Object.assign({ model: "aura-2-thalia-en" }, options));
      this.result = yield this.post(requestUrl, body, {
        headers: { Accept: "audio/*", "Content-Type": "application/json" }
      });
      return this;
    });
  }
  /**
   * Retrieves the response body as a readable stream.
   *
   * @returns A promise that resolves to the response body as a readable stream, or `null` if no request has been made yet.
   * @throws {DeepgramUnknownError} If a request has not been made yet.
   */
  getStream() {
    return __awaiter10(this, void 0, void 0, function* () {
      if (!this.result)
        throw new DeepgramUnknownError("Tried to get stream before making request", "");
      return this.result.body;
    });
  }
  /**
   * Retrieves the response headers from the previous request.
   *
   * @returns A promise that resolves to the response headers, or throws a `DeepgramUnknownError` if no request has been made yet.
   */
  getHeaders() {
    return __awaiter10(this, void 0, void 0, function* () {
      if (!this.result)
        throw new DeepgramUnknownError("Tried to get headers before making request", "");
      return this.result.headers;
    });
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/packages/SpeakClient.js
var SpeakClient = class extends AbstractClient {
  static {
    __name(this, "SpeakClient");
  }
  constructor() {
    super(...arguments);
    this.namespace = "speak";
  }
  /**
   * Returns a `SpeakRestClient` instance for interacting with the rest speak API.
   */
  request(source, options, endpoint = ":version/speak") {
    const client = new SpeakRestClient(this.options);
    return client.request(source, options, endpoint);
  }
  /**
   * Returns a `SpeakLiveClient` instance for interacting with the live speak API, with the provided TTS options and endpoint.
   * @param {SpeakSchema} [ttsOptions={}] - The TTS options to use for the live speak API.
   * @param {string} [endpoint=":version/speak"] - The endpoint to use for the live speak API.
   * @returns {SpeakLiveClient} - A `SpeakLiveClient` instance for interacting with the live speak API.
   */
  live(ttsOptions = {}, endpoint = ":version/speak") {
    return new SpeakLiveClient(this.options, ttsOptions, endpoint);
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/DeepgramClient.js
var DeepgramClient = class extends AbstractClient {
  static {
    __name(this, "DeepgramClient");
  }
  /**
   * Returns a new instance of the AuthRestClient, which provides access to the Deepgram API's temporary token endpoints.
   *
   * @returns {AuthRestClient} A new instance of the AuthRestClient.
   * @see https://developers.deepgram.com/reference/token-based-auth-api/grant-token
   */
  get auth() {
    return new AuthRestClient(this.options);
  }
  /**
   * Returns a new instance of the ListenClient, which provides access to the Deepgram API's listening functionality.
   *
   * @returns {ListenClient} A new instance of the ListenClient.
   */
  get listen() {
    return new ListenClient(this.options);
  }
  /**
   * Returns a new instance of the ManageClient, which provides access to the Deepgram API's management functionality.
   *
   * @returns {ManageClient} A new instance of the ManageClient.
   */
  get manage() {
    return new ManageRestClient(this.options);
  }
  /**
   * Returns a new instance of the ModelsRestClient, which provides access to the Deepgram API's model functionality.
   *
   * @returns {ModelsRestClient} A new instance of the ModelsRestClient.
   */
  get models() {
    return new ModelsRestClient(this.options);
  }
  /**
   * Returns a new instance of the SelfHostedRestClient, which provides access to the Deepgram API's self-hosted functionality.
   *
   * @returns {OnPremClient} A new instance of the SelfHostedRestClient named as OnPremClient.
   * @deprecated use selfhosted() instead
   */
  get onprem() {
    return this.selfhosted;
  }
  /**
   * Returns a new instance of the SelfHostedRestClient, which provides access to the Deepgram API's self-hosted functionality.
   *
   * @returns {SelfHostedRestClient} A new instance of the SelfHostedRestClient.
   */
  get selfhosted() {
    return new SelfHostedRestClient(this.options);
  }
  /**
   * Returns a new instance of the ReadClient, which provides access to the Deepgram API's reading functionality.
   *
   * @returns {ReadClient} A new instance of the ReadClient.
   */
  get read() {
    return new ReadRestClient(this.options);
  }
  /**
   * Returns a new instance of the SpeakClient, which provides access to the Deepgram API's speaking functionality.
   *
   * @returns {SpeakClient} A new instance of the SpeakClient.
   */
  get speak() {
    return new SpeakClient(this.options);
  }
  /**
   * Returns a new instance of the AgentLiveClient, which provides access to Deepgram's Voice Agent API.
   *
   * @returns {AgentLiveClient} A new instance of the AgentLiveClient.
   * @beta
   */
  agent(endpoint = "/:version/agent/converse") {
    return new AgentLiveClient(this.options, endpoint);
  }
  /**
   * @deprecated
   * @see https://dpgr.am/js-v3
   */
  get transcription() {
    throw new DeepgramVersionError();
  }
  /**
   * @deprecated
   * @see https://dpgr.am/js-v3
   */
  get projects() {
    throw new DeepgramVersionError();
  }
  /**
   * @deprecated
   * @see https://dpgr.am/js-v3
   */
  get keys() {
    throw new DeepgramVersionError();
  }
  /**
   * @deprecated
   * @see https://dpgr.am/js-v3
   */
  get members() {
    throw new DeepgramVersionError();
  }
  /**
   * @deprecated
   * @see https://dpgr.am/js-v3
   */
  get scopes() {
    throw new DeepgramVersionError();
  }
  /**
   * @deprecated
   * @see https://dpgr.am/js-v3
   */
  get invitation() {
    throw new DeepgramVersionError();
  }
  /**
   * @deprecated
   * @see https://dpgr.am/js-v3
   */
  get usage() {
    throw new DeepgramVersionError();
  }
  /**
   * @deprecated
   * @see https://dpgr.am/js-v3
   */
  get billing() {
    throw new DeepgramVersionError();
  }
};

// ../../node_modules/@deepgram/sdk/dist/module/index.js
function createClient(keyOrOptions, options) {
  let resolvedOptions = {};
  if (typeof keyOrOptions === "string" || typeof keyOrOptions === "function") {
    if (typeof options === "object") {
      resolvedOptions = options;
    }
    resolvedOptions.key = keyOrOptions;
  } else if (typeof keyOrOptions === "object") {
    resolvedOptions = keyOrOptions;
  }
  return new DeepgramClient(resolvedOptions);
}
__name(createClient, "createClient");

// ../../packages/deepgram/dist/index.js
var DeepgramEvents = {
  Open: LiveTranscriptionEvents.Open,
  Transcript: LiveTranscriptionEvents.Transcript,
  Close: LiveTranscriptionEvents.Close,
  Error: LiveTranscriptionEvents.Error
};
var DeepgramTranscriptionProvider = class {
  static {
    __name(this, "DeepgramTranscriptionProvider");
  }
  apiKey;
  model;
  keepAliveIntervalMs;
  defaultEncoding;
  defaultSampleRate;
  defaultChannels;
  createClient;
  constructor(config) {
    if (!config?.apiKey) {
      throw new Error("DeepgramTranscriptionProvider requires an apiKey");
    }
    this.apiKey = config.apiKey;
    this.model = config.model ?? "nova-3";
    this.keepAliveIntervalMs = config.keepAliveIntervalMs ?? 3e3;
    this.defaultEncoding = config.defaultEncoding ?? "opus";
    this.defaultSampleRate = config.defaultSampleRate ?? 48e3;
    this.defaultChannels = config.defaultChannels ?? 1;
    this.createClient = config.clientFactory ?? createClient;
  }
  async createStream({
    onTranscript,
    onError,
    onClose
  }) {
    const client = this.createClient(this.apiKey);
    const stream = client.listen.live({
      model: this.model,
      punctuate: true,
      interim_results: true,
      utterance_end_ms: 1500,
      encoding: this.defaultEncoding,
      sampleRate: this.defaultSampleRate,
      channels: this.defaultChannels
    });
    let keepAliveTimer = null;
    let isOpen = false;
    const pending = [];
    let finishResolve = null;
    let finishReject = null;
    let finishSettled = false;
    const finishPromise = new Promise((resolve, reject) => {
      finishResolve = resolve;
      finishReject = reject;
    });
    const settleFinish = /* @__PURE__ */ __name((error) => {
      if (finishSettled) {
        return;
      }
      finishSettled = true;
      if (error) {
        finishReject?.(error);
      } else {
        finishResolve?.();
      }
    }, "settleFinish");
    const clearKeepAlive = /* @__PURE__ */ __name(() => {
      if (keepAliveTimer) {
        clearInterval(keepAliveTimer);
        keepAliveTimer = null;
      }
    }, "clearKeepAlive");
    const toArrayBuffer = /* @__PURE__ */ __name((chunk) => {
      if (chunk instanceof ArrayBuffer) {
        return chunk;
      }
      const view = chunk;
      const copied = new ArrayBuffer(view.byteLength);
      new Uint8Array(copied).set(
        new Uint8Array(view.buffer, view.byteOffset, view.byteLength)
      );
      return copied;
    }, "toArrayBuffer");
    stream.on(DeepgramEvents.Open, () => {
      isOpen = true;
      for (const chunk of pending.splice(0, pending.length)) {
        try {
          stream.send(chunk);
        } catch (error) {
          console.warn("Failed to flush Deepgram chunk", error);
        }
      }
      keepAliveTimer = setInterval(() => {
        try {
          stream.keepAlive();
        } catch (error) {
          console.warn("Deepgram keepAlive failed", error);
        }
      }, this.keepAliveIntervalMs);
    });
    stream.on(DeepgramEvents.Transcript, (data) => {
      const alternative = data?.channel?.alternatives?.[0];
      const transcript = alternative?.transcript;
      if (!transcript) return;
      onTranscript({
        transcript,
        isFinal: Boolean(data?.is_final)
      });
    });
    stream.on(DeepgramEvents.Close, () => {
      isOpen = false;
      clearKeepAlive();
      settleFinish();
      onClose?.();
    });
    stream.on(DeepgramEvents.Error, (cause) => {
      isOpen = false;
      pending.length = 0;
      clearKeepAlive();
      const error = cause instanceof Error ? cause : new Error(
        typeof cause === "string" ? cause : "Deepgram live transcription error"
      );
      settleFinish(error);
      onError?.(error);
    });
    return {
      send: /* @__PURE__ */ __name((chunk) => {
        if (!isOpen) {
          pending.push(toArrayBuffer(chunk));
          return;
        }
        try {
          stream.send(toArrayBuffer(chunk));
        } catch (error) {
          console.warn("Failed to send Deepgram chunk", error);
        }
      }, "send"),
      finish: /* @__PURE__ */ __name(async () => {
        isOpen = false;
        clearKeepAlive();
        stream.finalize();
        stream.requestClose();
        await finishPromise;
      }, "finish"),
      abort: /* @__PURE__ */ __name((reason) => {
        isOpen = false;
        pending.length = 0;
        clearKeepAlive();
        stream.requestClose();
        settleFinish(
          reason ? new Error(reason) : new Error("transcription aborted")
        );
      }, "abort")
    };
  }
};

// ../../packages/cartesia/dist/index.js
init_modules_watch_stub();
var import_cartesia_js = __toESM(require_cartesia_js(), 1);
var DEFAULT_MODEL_ID = "sonic-3";
var DEFAULT_VOICE_ID = "66c6b81c-ddb7-4892-bdd5-19b5a7be38e7";
var CartesiaTtsStreamer = class {
  static {
    __name(this, "CartesiaTtsStreamer");
  }
  apiKey;
  modelId;
  voiceId;
  constructor(config) {
    if (!config?.apiKey) {
      throw new Error("CartesiaTtsStreamer requires an apiKey");
    }
    this.apiKey = config.apiKey;
    this.voiceId = config.voiceId ?? DEFAULT_VOICE_ID;
    this.modelId = config.modelId ?? DEFAULT_MODEL_ID;
  }
  async stream(text, handlers) {
    const normalized = text?.trim();
    if (!normalized) {
      handlers.onClose?.();
      return;
    }
    const client = new import_cartesia_js.CartesiaClient({ apiKey: this.apiKey });
    let stream = null;
    try {
      stream = await client.tts.sse({
        modelId: this.modelId,
        transcript: normalized,
        voice: { mode: "id", id: this.voiceId },
        outputFormat: {
          container: "raw",
          encoding: "pcm_s16le",
          sampleRate: 48e3
        }
      });
      let completed = false;
      for await (const event of stream) {
        if (!event) continue;
        switch (event.type) {
          case "chunk":
            if (typeof event.data === "string" && event.data.length > 0) {
              handlers.onAudioChunk(base64ToArrayBuffer(event.data));
            }
            break;
          case "done":
            completed = true;
            break;
          case "error": {
            const message = typeof event.error === "string" && event.error.length > 0 ? event.error : "Cartesia stream error";
            throw new Error(message);
          }
          default:
            break;
        }
        if (completed) {
          break;
        }
      }
      handlers.onClose?.();
    } catch (cause) {
      const error = normalizeCartesiaError(cause);
      handlers.onError?.(error);
      throw error;
    }
  }
};
function normalizeCartesiaError(cause) {
  if (cause instanceof Error) {
    return cause;
  }
  if (cause && typeof cause === "object" && "message" in cause) {
    return new Error(String(cause.message));
  }
  return new Error("Cartesia TTS stream error");
}
__name(normalizeCartesiaError, "normalizeCartesiaError");
function base64ToArrayBuffer(base64) {
  if (typeof atob === "function") {
    const binary = atob(base64);
    const len = binary.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
  }
  const buffer = Buffer.from(base64, "base64");
  return buffer.buffer.slice(
    buffer.byteOffset,
    buffer.byteOffset + buffer.byteLength
  );
}
__name(base64ToArrayBuffer, "base64ToArrayBuffer");

// src/worker.ts
var VoiceSessionDO = createVoiceDurableObject({
  createProviders(env) {
    return {
      transcriptionProvider: new DeepgramTranscriptionProvider({
        apiKey: env.DEEPGRAM_API_KEY
      }),
      agentProcessor: new MockAgentProcessor({
        responsePrefix: "VoiceCN demo agent:"
      }),
      ttsStreamer: new CartesiaTtsStreamer({
        apiKey: env.CARTESIA_API_KEY
      })
    };
  }
});
var worker_default = {
  async fetch(request, env) {
    const url = new URL(request.url);
    if (url.pathname === "/voice-command/ws") {
      const userId = url.searchParams.get("userId") ?? "demo-user";
      const id = env.VOICE_SESSION.newUniqueId();
      const stub = env.VOICE_SESSION.get(id);
      const headers = new Headers(request.headers);
      headers.set("X-Voice-User", JSON.stringify({ id: userId }));
      return stub.fetch(new Request(request, { headers }));
    }
    if (url.pathname === "/health") {
      return new Response(
        JSON.stringify({
          ok: true,
          message: "VoiceCN worker running"
        }),
        { headers: { "content-type": "application/json" } }
      );
    }
    return new Response("Not found", { status: 404 });
  }
};

// ../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_modules_watch_stub();
var drainBody = /* @__PURE__ */ __name(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// ../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_modules_watch_stub();
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e) {
    const error = reduceError(e);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-f5RJD0/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = worker_default;

// ../../node_modules/wrangler/templates/middleware/common.ts
init_modules_watch_stub();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-f5RJD0/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type, init) {
        if (type === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request, env, ctx) => {
      this.env = env;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type, init) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  VoiceSessionDO,
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=worker.js.map
